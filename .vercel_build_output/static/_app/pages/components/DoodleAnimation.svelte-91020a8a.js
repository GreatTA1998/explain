import{S as W,i as j,s as C,J as E,ac as M,a2 as v,ad as D,e as N,k as A,j as w,c as q,a as B,d as y,n as S,m as z,f as k,o as R,E as H,ae as J,af as L,x as $,u as x,v as I,ag as V,A as G,t as K,g as O}from"../../chunks/vendor-0c80fc2b.js";import{r as Q,c as U}from"../../chunks/canvasHelpers-a780b7c6.js";function X(l){let o;return{c(){o=K("Play")},l(n){o=O(n,"Play")},m(n,u){k(n,o,u)},d(n){n&&y(o)}}}function Y(l){let o,n,u,s,f,a,c,r,m,h;s=new E({props:{$$slots:{default:[X]},$$scope:{ctx:l}}}),s.$on("click",l[4]);function b(e){l[9](e)}let _={min:0,max:l[2].length+1,step:1,discrete:!0};return l[3]!==void 0&&(_.value=l[3]),a=new M({props:_}),v.push(()=>D(a,"value",b)),{c(){o=N("canvas"),u=A(),w(s.$$.fragment),f=A(),w(a.$$.fragment)},l(e){o=q(e,"CANVAS",{});var i=B(o);i.forEach(y),u=S(e),z(s.$$.fragment,e),f=S(e),z(a.$$.fragment,e)},m(e,i){k(e,o,i),l[8](o),k(e,u,i),R(s,e,i),k(e,f,i),R(a,e,i),r=!0,m||(h=H(n=Q.call(null,o,{strokesArray:l[0],onResize:l[5]})),m=!0)},p(e,[i]){n&&J(n.update)&&i&1&&n.update.call(null,{strokesArray:e[0],onResize:e[5]});const t={};i&4096&&(t.$$scope={dirty:i,ctx:e}),s.$set(t);const d={};i&4&&(d.max=e[2].length+1),!c&&i&8&&(c=!0,d.value=e[3],L(()=>c=!1)),a.$set(d)},i(e){r||($(s.$$.fragment,e),$(a.$$.fragment,e),r=!0)},o(e){x(s.$$.fragment,e),x(a.$$.fragment,e),r=!1},d(e){e&&y(o),l[8](null),e&&y(u),I(s,e),e&&y(f),I(a,e),m=!1,h()}}}let T=1;function Z(l,o,n){let{strokesArray:u}=o,s,f,a=[],c=0,r=0,m;V(()=>{m&&clearTimeout(m)}),G(()=>{n(6,f=s.getContext("2d"));const t=[];for(let d=0;d<u.length;d++)for(let g=1;g<u[d].points.length;g++){const p={strokeIndex:d,pointIndex:g};t.push(p)}n(2,a=t)});async function h(){if(console.log("sync recursively"),m||(f.clearRect(0,0,s.width,s.height),n(7,c=0),n(3,r=0)),console.log("nextFrameIdx =",c),c<a.length-1){const t=0;n(3,r+=1),m=setTimeout(h,t/T)}else clearTimeout(m),m=null,console.log("I expect it to be null recursiveSyncer =",m)}async function b(){console.log("resized"),f.clearRect(0,0,s.width,s.height);for(let t=0;t<=c;t++)await _(a[t],!0)}async function _({strokeIndex:t,pointIndex:d},g=!1){const p=u[t],F=p.lineWidth*(s.scrollWidth/1e3);U(p.points,d,p.isErasing,f,p.color,F,s),g||await new Promise(P=>setTimeout(P,10/T))}function e(t){v[t?"unshift":"push"](()=>{s=t,n(1,s)})}function i(t){r=t,n(3,r)}return l.$$set=t=>{"strokesArray"in t&&n(0,u=t.strokesArray)},l.$$.update=()=>{if(l.$$.dirty&206){if(c<r)for(let t=c;t<Math.min(r,a.length);t++)_(a[t],!1);else if(c>r){f.clearRect(0,0,s.width,s.height);for(let t=0;t<Math.min(r,a.length);t++)_(a[t],!0)}n(7,c=r)}},[u,s,a,r,h,b,f,c,e,i]}class ne extends W{constructor(o){super();j(this,o,Z,Y,C,{strokesArray:0})}}export{ne as default};
