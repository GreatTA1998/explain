var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[Object.keys(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb2, mod) => function __require() {
  return mod || (0, cb2[Object.keys(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name6 in all)
    __defProp(target, name6, { get: all[name6], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base642 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base642 = true;
    } else {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base642 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0;
      while (position !== part.size) {
        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
function getHeader(boundary, name6, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name6}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
async function* formDataIterator(form, boundary) {
  for (const [name6, value] of form) {
    yield getHeader(boundary, name6, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name6, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name6, value));
    length += isBlob(value) ? value.size : Buffer.byteLength(String(value));
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  let { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = import_stream.default.Readable.from(body.stream());
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof import_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error3 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error3);
        throw error3;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error3) {
    const error_ = error3 instanceof FetchBaseError ? error3 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error3.message}`, "system", error3);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error3) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error3.message}`, "system", error3);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers2 = []) {
  return new Headers(headers2.reduce((result, value, index, array) => {
    if (index % 2 === 0) {
      result.push(array.slice(index, index + 2));
    }
    return result;
  }, []).filter(([name6, value]) => {
    try {
      validateHeaderName(name6);
      validateHeaderValue(name6, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
async function fetch(url2, options_) {
  return new Promise((resolve2, reject2) => {
    const request = new Request(url2, options_);
    const options2 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options2.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url2}. URL scheme "${options2.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options2.protocol === "data:") {
      const data = dataUriToBuffer$1(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (options2.protocol === "https:" ? import_https.default : import_http.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error3 = new AbortError("The operation was aborted.");
      reject2(error3);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        request.body.destroy(error3);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error3);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error3) => {
      reject2(new FetchError(`request to ${request.url} failed, reason: ${error3.message}`, "system", error3));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error3) => {
      response.body.destroy(error3);
    });
    if (process.version < "v14") {
      request_.on("socket", (s2) => {
        let endedWithEventsCount;
        s2.prependListener("end", () => {
          endedWithEventsCount = s2._eventsCount;
        });
        s2.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
            const error3 = new Error("Premature close");
            error3.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error3);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers2 = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location2 = headers2.get("Location");
        const locationURL = location2 === null ? null : new URL(location2, request.url);
        switch (request.redirect) {
          case "error":
            reject2(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              headers2.set("Location", locationURL);
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject2(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_stream.default.Readable) {
              reject2(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve2(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject2(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), reject2);
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers: headers2,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers2.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createGunzip(zlibOptions), reject2);
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), reject2);
        raw.once("data", (chunk) => {
          body = (chunk[0] & 15) === 8 ? (0, import_stream.pipeline)(body, import_zlib.default.createInflate(), reject2) : (0, import_stream.pipeline)(body, import_zlib.default.createInflateRaw(), reject2);
          response = new Response(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createBrotliDecompress(), reject2);
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers: headers2 } = response;
    isChunkedTransfer = headers2["transfer-encoding"] === "chunked" && !headers2["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error3 = new Error("Premature close");
        error3.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error3);
      }
    };
    socket.prependListener("close", onSocketClose);
    request.on("abort", () => {
      socket.removeListener("close", onSocketClose);
    });
    socket.on("data", (buf) => {
      properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    });
  });
}
var import_http, import_https, import_zlib, import_stream, import_util, import_crypto, import_url, commonjsGlobal, src, dataUriToBuffer$1, ponyfill_es2018, POOL_SIZE$1, POOL_SIZE, _Blob, Blob2, Blob$1, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, carriage, dashes, carriageLength, getFooter, getBoundary, INTERNALS$2, Body, clone, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers, redirectStatus, isRedirect, INTERNALS$1, Response, getSearch, INTERNALS, isRequest, Request, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    init_shims();
    import_http = __toModule(require("http"));
    import_https = __toModule(require("https"));
    import_zlib = __toModule(require("zlib"));
    import_stream = __toModule(require("stream"));
    import_util = __toModule(require("util"));
    import_crypto = __toModule(require("crypto"));
    import_url = __toModule(require("url"));
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    src = dataUriToBuffer;
    dataUriToBuffer$1 = src;
    ponyfill_es2018 = { exports: {} };
    (function(module2, exports) {
      (function(global2, factory2) {
        factory2(exports);
      })(commonjsGlobal, function(exports2) {
        const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
        function noop3() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        const globals2 = getGlobals();
        function typeIsObject(x2) {
          return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
        }
        const rethrowAssertionErrorRejection = noop3;
        const originalPromise = Promise;
        const originalPromiseThen = Promise.prototype.then;
        const originalPromiseResolve = Promise.resolve.bind(originalPromise);
        const originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        const queueMicrotask = (() => {
          const globalQueueMicrotask = globals2 && globals2.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          const resolvedPromise = promiseResolvedWith(void 0);
          return (fn2) => PerformPromiseThen(resolvedPromise, fn2);
        })();
        function reflectCall(F2, V2, args) {
          if (typeof F2 !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F2, V2, args);
        }
        function promiseCall(F2, V2, args) {
          try {
            return promiseResolvedWith(reflectCall(F2, V2, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        const QUEUE_MAX_ARRAY_SIZE = 16384;
        class SimpleQueue {
          constructor() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          }
          shift() {
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          }
          forEach(callback) {
            let i = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i !== elements.length || node._next !== void 0) {
              if (i === elements.length) {
                node = node._next;
                elements = node._elements;
                i = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i]);
              ++i;
            }
          }
          peek() {
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
          }
        }
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          const stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name6) {
          return new TypeError("Cannot " + name6 + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise((resolve2, reject2) => {
            reader._closedPromise_resolve = resolve2;
            reader._closedPromise_reject = reject2;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        const PullSteps = SymbolPolyfill("[[PullSteps]]");
        const NumberIsFinite = Number.isFinite || function(x2) {
          return typeof x2 === "number" && isFinite(x2);
        };
        const MathTrunc = Math.trunc || function(v2) {
          return v2 < 0 ? Math.ceil(v2) : Math.floor(v2);
        };
        function isDictionary(x2) {
          return typeof x2 === "object" || typeof x2 === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertFunction(x2, context) {
          if (typeof x2 !== "function") {
            throw new TypeError(`${context} is not a function.`);
          }
        }
        function isObject2(x2) {
          return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
        }
        function assertObject(x2, context) {
          if (!isObject2(x2)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertRequiredArgument(x2, position, context) {
          if (x2 === void 0) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
          }
        }
        function assertRequiredField(x2, field, context) {
          if (x2 === void 0) {
            throw new TypeError(`${field} is required in '${context}'.`);
          }
        }
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        function censorNegativeZero(x2) {
          return x2 === 0 ? 0 : x2;
        }
        function integerPart(x2) {
          return censorNegativeZero(MathTrunc(x2));
        }
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          const lowerBound = 0;
          const upperBound = Number.MAX_SAFE_INTEGER;
          let x2 = Number(value);
          x2 = censorNegativeZero(x2);
          if (!NumberIsFinite(x2)) {
            throw new TypeError(`${context} is not a finite number`);
          }
          x2 = integerPart(x2);
          if (x2 < lowerBound || x2 > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
          }
          if (!NumberIsFinite(x2) || x2 === 0) {
            return 0;
          }
          return x2;
        }
        function assertReadableStream(x2, context) {
          if (!IsReadableStream(x2)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamDefaultReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject2) => {
              resolvePromise = resolve2;
              rejectPromise = reject2;
            });
            const readRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: () => resolvePromise({ value: void 0, done: true }),
              _errorSteps: (e) => rejectPromise(e)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
            return false;
          }
          return x2 instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name6) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${name6} can only be used on a ReadableStreamDefaultReader`);
        }
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
        }).prototype);
        class ReadableStreamAsyncIteratorImpl {
          constructor(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          }
          return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }
          _nextSteps() {
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject2) => {
              resolvePromise = resolve2;
              rejectPromise = reject2;
            });
            const readRequest = {
              _chunkSteps: (chunk) => {
                this._ongoingPromise = void 0;
                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
              },
              _closeSteps: () => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: (reason) => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          }
          _returnSteps(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              const result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          }
        }
        const ReadableStreamAsyncIteratorPrototype = {
          next() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a2) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name6) {
          return new TypeError(`ReadableStreamAsyncIterator.${name6} can only be used on a ReadableSteamAsyncIterator`);
        }
        const NumberIsNaN3 = Number.isNaN || function(x2) {
          return x2 !== x2;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src2, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src2, srcOffset, n), destOffset);
        }
        function TransferArrayBuffer(O2) {
          return O2;
        }
        function IsDetachedBuffer(O2) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          const length = end - begin;
          const slice = new ArrayBuffer(length);
          CopyDataBlockBytes(slice, 0, buffer, begin, length);
          return slice;
        }
        function IsNonNegativeNumber(v2) {
          if (typeof v2 !== "number") {
            return false;
          }
          if (NumberIsNaN3(v2)) {
            return false;
          }
          if (v2 < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O2) {
          const buffer = ArrayBufferSlice(O2.buffer, O2.byteOffset, O2.byteOffset + O2.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          const pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          const pair = container._queue.peek();
          return pair.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          }
          respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }
          respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          }
          get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
          }
          enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          }
          error(e = void 0) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e);
          }
          [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              const entry = this._queue.shift();
              this._queueTotalSize -= entry.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              let buffer;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              const pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          }
        }
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
            return false;
          }
          return x2 instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x2 instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, (e) => {
            ReadableByteStreamControllerError(controller, e);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          let done = false;
          if (stream._state === "closed") {
            done = true;
          }
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          const bytesFilled = pullIntoDescriptor.bytesFilled;
          const elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          const elementSize = pullIntoDescriptor.elementSize;
          const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          let totalBytesToCopyRemaining = maxBytesToCopy;
          let ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          const queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          const stream = controller._controlledReadableByteStream;
          let elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          const ctor = view.constructor;
          const buffer = TransferArrayBuffer(view.buffer);
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e);
              readIntoRequest._errorSteps(e);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          const stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          const descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e);
              throw e;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          const buffer = chunk.buffer;
          const byteOffset = chunk.byteOffset;
          const byteLength = chunk.byteLength;
          const transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, (r) => {
            ReadableByteStreamControllerError(controller, r);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          const controller = Object.create(ReadableByteStreamController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = () => underlyingByteSource.start(controller);
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
          }
          const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name6) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${name6} can only be used on a ReadableStreamBYOBRequest`);
        }
        function byteStreamControllerBrandCheckException(name6) {
          return new TypeError(`ReadableByteStreamController.prototype.${name6} can only be used on a ReadableByteStreamController`);
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamBYOBReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject2) => {
              resolvePromise = resolve2;
              rejectPromise = reject2;
            });
            const readIntoRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
              _errorSteps: (e) => rejectPromise(e)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
            return false;
          }
          return x2 instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name6) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${name6} can only be used on a ReadableStreamBYOBReader`);
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          const { highWaterMark } = strategy;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN3(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          const { size } = strategy;
          if (!size) {
            return () => 1;
          }
          return size;
        }
        function convertQueuingStrategy(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          const size = init2 === null || init2 === void 0 ? void 0 : init2.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
          };
        }
        function convertQueuingStrategySize(fn2, context) {
          assertFunction(fn2, context);
          return (chunk) => convertUnrestrictedDouble(fn2(chunk));
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          const abort = original === null || original === void 0 ? void 0 : original.abort;
          const close = original === null || original === void 0 ? void 0 : original.close;
          const start2 = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          const write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start2 === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start2, original, `${context} has member 'start' that`),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
          };
        }
        function convertUnderlyingSinkAbortCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (reason) => promiseCall(fn2, original, [reason]);
        }
        function convertUnderlyingSinkCloseCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return () => promiseCall(fn2, original, []);
        }
        function convertUnderlyingSinkStartCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (controller) => reflectCall(fn2, original, [controller]);
        }
        function convertUnderlyingSinkWriteCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (chunk, controller) => promiseCall(fn2, original, [chunk, controller]);
        }
        function assertWritableStream(x2, context) {
          if (!IsWritableStream(x2)) {
            throw new TypeError(`${context} is not a WritableStream.`);
          }
        }
        function isAbortSignal2(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a2) {
            return false;
          }
        }
        const supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        class WritableStream {
          constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          get locked() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          }
          abort(reason = void 0) {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          }
          close() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          }
          getWriter() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          }
        }
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          const controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
            return false;
          }
          return x2 instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a2;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a2 = stream._writableStreamController._abortController) === null || _a2 === void 0 ? void 0 : _a2.abort();
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          let wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          const promise = newPromise((resolve2, reject2) => {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve2,
              _reject: reject2,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
          }
          const promise = newPromise((resolve2, reject2) => {
            const closeRequest = {
              _resolve: resolve2,
              _reject: reject2
            };
            stream._closeRequest = closeRequest;
          });
          const writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          const promise = newPromise((resolve2, reject2) => {
            const writeRequest = {
              _resolve: resolve2,
              _reject: reject2
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error3) {
          const state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error3);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          const controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          const writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          const storedError = stream._storedError;
          stream._writeRequests.forEach((writeRequest) => {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error3) {
          stream._inFlightWriteRequest._reject(error3);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error3);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          const state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error3) {
          stream._inFlightCloseRequest._reject(error3);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error3);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error3);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          const writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        class WritableStreamDefaultWriter {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              const storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          }
          get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          }
          abort(reason = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          }
          close() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          }
          releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          }
          write(chunk = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          }
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
            return false;
          }
          return x2 instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          const stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          const stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error3) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error3);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error3);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error3) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error3);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error3);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          const stream = writer._ownerWritableStream;
          const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          const stream = writer._ownerWritableStream;
          const controller = stream._writableStreamController;
          const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          const state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          const promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        const closeSentinel = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          }
          get signal() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          }
          error(e = void 0) {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            const state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e);
          }
          [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [ErrorSteps]() {
            ResetQueue(this);
          }
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
            return false;
          }
          return x2 instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          const startResult = startAlgorithm();
          const startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (r) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(WritableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let writeAlgorithm = () => promiseResolvedWith(void 0);
          let closeAlgorithm = () => promiseResolvedWith(void 0);
          let abortAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSink.start !== void 0) {
            startAlgorithm = () => underlyingSink.start(controller);
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = () => underlyingSink.close();
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = (reason) => underlyingSink.abort(reason);
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          const stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          const stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          const state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          const value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error3) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error3);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          const sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
          }, (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          const sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error3) {
          const stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error3);
        }
        function streamBrandCheckException$2(name6) {
          return new TypeError(`WritableStream.prototype.${name6} can only be used on a WritableStream`);
        }
        function defaultControllerBrandCheckException$2(name6) {
          return new TypeError(`WritableStreamDefaultController.prototype.${name6} can only be used on a WritableStreamDefaultController`);
        }
        function defaultWriterBrandCheckException(name6) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${name6} can only be used on a WritableStreamDefaultWriter`);
        }
        function defaultWriterLockException(name6) {
          return new TypeError("Cannot " + name6 + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise((resolve2, reject2) => {
            writer._closedPromise_resolve = resolve2;
            writer._closedPromise_reject = reject2;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise((resolve2, reject2) => {
            writer._readyPromise_resolve = resolve2;
            writer._readyPromise_reject = reject2;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a2) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          const ctor = function DOMException2(message2, name6) {
            this.message = message2 || "";
            this.name = name6 || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          const reader = AcquireReadableStreamDefaultReader(source);
          const writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          let shuttingDown = false;
          let currentWrite = promiseResolvedWith(void 0);
          return newPromise((resolve2, reject2) => {
            let abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = () => {
                const error3 = new DOMException$1("Aborted", "AbortError");
                const actions = [];
                if (!preventAbort) {
                  actions.push(() => {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error3);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(() => {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error3);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error3);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise((resolveLoop, rejectLoop) => {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, () => {
                return newPromise((resolveRead, rejectRead) => {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: (chunk) => {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop3);
                      resolveRead(false);
                    },
                    _closeSteps: () => resolveRead(true),
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
              if (!preventAbort) {
                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, () => {
              if (!preventClose) {
                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
              } else {
                shutdown(true, destClosed);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              const oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              }
            }
            function shutdown(isError, error3) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error3));
              } else {
                finalize(isError, error3);
              }
            }
            function finalize(isError, error3) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject2(error3);
              } else {
                resolve2(void 0);
              }
            }
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          }
          enqueue(chunk = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }
          error(e = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e);
          }
          [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          }
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
            return false;
          }
          return x2 instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, (e) => {
            ReadableStreamDefaultControllerError(controller, e);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            let chunkSize;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e) {
          const stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          const state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, (r) => {
            ReadableStreamDefaultControllerError(controller, r);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSource.start !== void 0) {
            startAlgorithm = () => underlyingSource.start(controller);
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = () => underlyingSource.pull(controller);
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name6) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${name6} can only be used on a ReadableStreamDefaultController`);
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function pullAlgorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const chunk1 = chunk;
                  const chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, (r) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          let reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, (r) => {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r);
              ReadableByteStreamControllerError(branch2._readableStreamController, r);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const chunk1 = chunk;
                  let chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    let clonedChunk;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                });
              },
              _closeSteps: (chunk) => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          const original = source;
          const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          const cancel = original === null || original === void 0 ? void 0 : original.cancel;
          const pull = original === null || original === void 0 ? void 0 : original.pull;
          const start2 = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start2 === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start2, original, `${context} has member 'start' that`),
            type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
          };
        }
        function convertUnderlyingSourceCancelCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (reason) => promiseCall(fn2, original, [reason]);
        }
        function convertUnderlyingSourcePullCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (controller) => promiseCall(fn2, original, [controller]);
        }
        function convertUnderlyingSourceStartCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (controller) => reflectCall(fn2, original, [controller]);
        }
        function convertReadableStreamType(type, context) {
          type = `${type}`;
          if (type !== "bytes") {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
          }
          return type;
        }
        function convertReaderOptions(options2, context) {
          assertDictionary(options2, context);
          const mode = options2 === null || options2 === void 0 ? void 0 : options2.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
          };
        }
        function convertReadableStreamReaderMode(mode, context) {
          mode = `${mode}`;
          if (mode !== "byob") {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
          }
          return mode;
        }
        function convertIteratorOptions(options2, context) {
          assertDictionary(options2, context);
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options2, context) {
          assertDictionary(options2, context);
          const preventAbort = options2 === null || options2 === void 0 ? void 0 : options2.preventAbort;
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          const preventClose = options2 === null || options2 === void 0 ? void 0 : options2.preventClose;
          const signal = options2 === null || options2 === void 0 ? void 0 : options2.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal2(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
          }
        }
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          const readable2 = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable2, "readable", "ReadableWritablePair");
          assertReadableStream(readable2, `${context} has member 'readable' that`);
          const writable3 = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable3, "writable", "ReadableWritablePair");
          assertWritableStream(writable3, `${context} has member 'writable' that`);
          return { readable: readable2, writable: writable3 };
        }
        class ReadableStream2 {
          constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              const highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          get locked() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          }
          cancel(reason = void 0) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          }
          getReader(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            const options2 = convertReaderOptions(rawOptions, "First parameter");
            if (options2.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          }
          pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            const transform = convertReadableWritablePair(rawTransform, "First parameter");
            const options2 = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          }
          pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options2;
            try {
              options2 = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e) {
              return promiseRejectedWith(e);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
          }
          tee() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }
          values(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            const options2 = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options2.preventCancel);
          }
        }
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
            return false;
          }
          return x2 instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          const reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop3);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e) {
          stream._state = "errored";
          stream._storedError = e;
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._errorSteps(e);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._errorSteps(e);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name6) {
          return new TypeError(`ReadableStream.prototype.${name6} can only be used on a ReadableStream`);
        }
        function convertQueuingStrategyInit(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        const byteLengthSizeFunction = (chunk) => {
          return chunk.byteLength;
        };
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class ByteLengthQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "ByteLengthQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          }
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name6) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${name6} can only be used on a ByteLengthQueuingStrategy`);
        }
        function IsByteLengthQueuingStrategy(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x2 instanceof ByteLengthQueuingStrategy;
        }
        const countSizeFunction = () => {
          return 1;
        };
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class CountQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "CountQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._countQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          }
        }
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name6) {
          return new TypeError(`CountQueuingStrategy.prototype.${name6} can only be used on a CountQueuingStrategy`);
        }
        function IsCountQueuingStrategy(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x2 instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          const flush2 = original === null || original === void 0 ? void 0 : original.flush;
          const readableType = original === null || original === void 0 ? void 0 : original.readableType;
          const start2 = original === null || original === void 0 ? void 0 : original.start;
          const transform = original === null || original === void 0 ? void 0 : original.transform;
          const writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush2 === void 0 ? void 0 : convertTransformerFlushCallback(flush2, original, `${context} has member 'flush' that`),
            readableType,
            start: start2 === void 0 ? void 0 : convertTransformerStartCallback(start2, original, `${context} has member 'start' that`),
            transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (controller) => promiseCall(fn2, original, [controller]);
        }
        function convertTransformerStartCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (controller) => reflectCall(fn2, original, [controller]);
        }
        function convertTransformerTransformCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (chunk, controller) => promiseCall(fn2, original, [chunk, controller]);
        }
        class TransformStream {
          constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            const transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise((resolve2) => {
              startPromise_resolve = resolve2;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== void 0) {
              startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          get readable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          }
          get writable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          }
        }
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
            return false;
          }
          return x2 instanceof TransformStream;
        }
        function TransformStreamError(stream, e) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
          TransformStreamErrorWritableAndUnblockWrite(stream, e);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise((resolve2) => {
            stream._backpressureChangePromise_resolve = resolve2;
          });
          stream._backpressure = backpressure;
        }
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          }
          enqueue(chunk = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }
          error(reason = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          }
          terminate() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          }
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
            return false;
          }
          return x2 instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
          const controller = Object.create(TransformStreamDefaultController.prototype);
          let transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          let flushAlgorithm = () => promiseResolvedWith(void 0);
          if (transformer.transform !== void 0) {
            transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
          }
          if (transformer.flush !== void 0) {
            flushAlgorithm = () => transformer.flush(controller);
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e);
            throw stream._readable._storedError;
          }
          const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e) {
          TransformStreamError(controller._controlledTransformStream, e);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          const transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, (r) => {
            TransformStreamError(controller._controlledTransformStream, r);
            throw r;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          const error3 = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error3);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          const controller = stream._transformStreamController;
          if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
              const writable3 = stream._writable;
              const state = writable3._state;
              if (state === "erroring") {
                throw writable3._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          const readable2 = stream._readable;
          const controller = stream._transformStreamController;
          const flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, () => {
            if (readable2._state === "errored") {
              throw readable2._storedError;
            }
            ReadableStreamDefaultControllerClose(readable2._readableStreamController);
          }, (r) => {
            TransformStreamError(stream, r);
            throw readable2._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name6) {
          return new TypeError(`TransformStreamDefaultController.prototype.${name6} can only be used on a TransformStreamDefaultController`);
        }
        function streamBrandCheckException(name6) {
          return new TypeError(`TransformStream.prototype.${name6} can only be used on a TransformStream`);
        }
        exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports2.CountQueuingStrategy = CountQueuingStrategy;
        exports2.ReadableByteStreamController = ReadableByteStreamController;
        exports2.ReadableStream = ReadableStream2;
        exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports2.TransformStream = TransformStream;
        exports2.TransformStreamDefaultController = TransformStreamDefaultController;
        exports2.WritableStream = WritableStream;
        exports2.WritableStreamDefaultController = WritableStreamDefaultController;
        exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    })(ponyfill_es2018, ponyfill_es2018.exports);
    POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("node:process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("node:stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error3) {
          process2.emitWarning = emitWarning;
          throw error3;
        }
      } catch (error3) {
        Object.assign(globalThis, ponyfill_es2018.exports);
      }
    }
    try {
      const { Blob: Blob3 } = require("buffer");
      if (Blob3 && !Blob3.prototype.stream) {
        Blob3.prototype.stream = function name6(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error3) {
    }
    POOL_SIZE = 65536;
    _Blob = class Blob {
      #parts = [];
      #type = "";
      #size = 0;
      constructor(blobParts = [], options2 = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options2 !== "object" && typeof options2 !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options2 === null)
          options2 = {};
        const encoder = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob) {
            part = element;
          } else {
            part = encoder.encode(element);
          }
          this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          this.#parts.push(part);
        }
        const type = options2.type === void 0 ? "" : String(options2.type);
        this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
      }
      get size() {
        return this.#size;
      }
      get type() {
        return this.#type;
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it2 = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it2.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it2.return();
          }
        });
      }
      slice(start2 = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start2 < 0 ? Math.max(size + start2, 0) : Math.min(start2, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob2 = _Blob;
    Blob$1 = Blob2;
    FetchBaseError = class extends Error {
      constructor(message2, type) {
        super(message2);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message2, type, systemError) {
        super(message2, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
    };
    carriage = "\r\n";
    dashes = "-".repeat(2);
    carriageLength = Buffer.byteLength(carriage);
    getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
    getBoundary = () => (0, import_crypto.randomBytes)(8).toString("hex");
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_util.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_stream.default)
          ;
        else if (isFormData(body)) {
          boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
          body = import_stream.default.Readable.from(formDataIterator(body, boundary));
        } else {
          body = Buffer.from(String(body));
        }
        this[INTERNALS$2] = {
          body,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_stream.default) {
          body.on("error", (error_) => {
            const error3 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$2].error = error3;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async blob() {
        const ct2 = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct2
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance2, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance2;
      if (instance2.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
        p1 = new import_stream.PassThrough({ highWaterMark });
        p2 = new import_stream.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance2[INTERNALS$2].body = p1;
        body = p2;
      }
      return body;
    };
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      }
      if (isFormData(body)) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body instanceof import_stream.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request;
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      if (isFormData(body)) {
        return getFormDataLength(request[INTERNALS$2].boundary);
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        import_stream.default.Readable.from(body.stream()).pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_http.default.validateHeaderName === "function" ? import_http.default.validateHeaderName : (name6) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name6)) {
        const error3 = new TypeError(`Header name must be a valid HTTP token [${name6}]`);
        Object.defineProperty(error3, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error3;
      }
    };
    validateHeaderValue = typeof import_http.default.validateHeaderValue === "function" ? import_http.default.validateHeaderValue : (name6, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error3 = new TypeError(`Invalid character in header content ["${name6}"]`);
        Object.defineProperty(error3, "code", { value: "ERR_INVALID_CHAR" });
        throw error3;
      }
    };
    Headers = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers) {
          const raw = init2.raw();
          for (const [name6, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name6, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !import_util.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || import_util.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name6, value]) => {
          validateHeaderName(name6);
          validateHeaderValue(name6, String(value));
          return [String(name6).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p2, receiver) {
            switch (p2) {
              case "append":
              case "set":
                return (name6, value) => {
                  validateHeaderName(name6);
                  validateHeaderValue(name6, String(value));
                  return URLSearchParams.prototype[p2].call(target, String(name6).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name6) => {
                  validateHeaderName(name6);
                  return URLSearchParams.prototype[p2].call(target, String(name6).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p2, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name6) {
        const values = this.getAll(name6);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name6)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name6 of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name6), name6, this]);
        }
      }
      *values() {
        for (const name6 of this.keys()) {
          yield this.get(name6);
        }
      }
      *entries() {
        for (const name6 of this.keys()) {
          yield [name6, this.get(name6)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response = class extends Body {
      constructor(body = null, options2 = {}) {
        super(body, options2);
        const status = options2.status != null ? options2.status : 200;
        const headers2 = new Headers(options2.headers);
        if (body !== null && !headers2.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers2.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          type: "default",
          url: options2.url,
          status,
          statusText: options2.statusText || "",
          headers: headers2,
          counter: options2.counter,
          highWaterMark: options2.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size
        });
      }
      static redirect(url2, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response(null, {
          headers: {
            location: new URL(url2).toString()
          },
          status
        });
      }
      static error() {
        const response = new Response(null, { status: 0, statusText: "" });
        response[INTERNALS$1].type = "error";
        return response;
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers2 = new Headers(init2.headers || input.headers || {});
        if (inputBody !== null && !headers2.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers2.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers: headers2,
          parsedURL,
          signal
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_url.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      clone() {
        return new Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers2 = new Headers(request[INTERNALS].headers);
      if (!headers2.has("Accept")) {
        headers2.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers2.set("Content-Length", contentLengthValue);
      }
      if (!headers2.has("User-Agent")) {
        headers2.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers2.has("Accept-Encoding")) {
        headers2.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers2.has("Connection") && !agent) {
        headers2.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const requestOptions = {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        query: parsedURL.query,
        href: parsedURL.href,
        method: request.method,
        headers: headers2[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return requestOptions;
    };
    AbortError = class extends FetchBaseError {
      constructor(message2, type = "aborted") {
        super(message2, type);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
  }
});

// node_modules/@sveltejs/adapter-vercel/files/shims.js
var init_shims = __esm({
  "node_modules/@sveltejs/adapter-vercel/files/shims.js"() {
    init_install_fetch();
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    init_shims();
    "use strict";
    exports.parse = parse;
    exports.serialize = serialize;
    var decode2 = decodeURIComponent;
    var encode = encodeURIComponent;
    var pairSplitRegExp = /; */;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options2) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options2 || {};
      var pairs = str.split(pairSplitRegExp);
      var dec = opt.decode || decode2;
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        var eq_idx = pair.indexOf("=");
        if (eq_idx < 0) {
          continue;
        }
        var key = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();
        if (val[0] == '"') {
          val = val.slice(1, -1);
        }
        if (obj[key] == void 0) {
          obj[key] = tryDecode(val, dec);
        }
      }
      return obj;
    }
    function serialize(name6, val, options2) {
      var opt = options2 || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name6)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name6 + "=" + value;
      if (opt.maxAge != null) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode3) {
      try {
        return decode3(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// node_modules/@lukeed/uuid/dist/index.mjs
function v4() {
  var i = 0, num, out = "";
  if (!BUFFER || IDX + 16 > 256) {
    BUFFER = Array(i = 256);
    while (i--)
      BUFFER[i] = 256 * Math.random() | 0;
    i = IDX = 0;
  }
  for (; i < 16; i++) {
    num = BUFFER[IDX + i];
    if (i == 6)
      out += HEX[num & 15 | 64];
    else if (i == 8)
      out += HEX[num & 63 | 128];
    else
      out += HEX[num];
    if (i & 1 && i > 1 && i < 11)
      out += "-";
  }
  IDX++;
  return out;
}
var IDX, HEX, BUFFER;
var init_dist = __esm({
  "node_modules/@lukeed/uuid/dist/index.mjs"() {
    init_shims();
    IDX = 256;
    HEX = [];
    while (IDX--)
      HEX[IDX] = (IDX + 256).toString(16).substring(1);
  }
});

// .svelte-kit/output/server/chunks/api.json-d90de77a.js
var api_json_d90de77a_exports = {};
__export(api_json_d90de77a_exports, {
  get: () => get
});
async function get() {
  return {
    body: {
      hello: "world"
    }
  };
}
var init_api_json_d90de77a = __esm({
  ".svelte-kit/output/server/chunks/api.json-d90de77a.js"() {
    init_shims();
  }
});

// .svelte-kit/output/server/chunks/DailyRoom.json-5588df4b.js
var DailyRoom_json_5588df4b_exports = {};
__export(DailyRoom_json_5588df4b_exports, {
  get: () => get2
});
function get2() {
  return {
    body: "Hello from Daily.json.js"
  };
}
var init_DailyRoom_json_5588df4b = __esm({
  ".svelte-kit/output/server/chunks/DailyRoom.json-5588df4b.js"() {
    init_shims();
  }
});

// .svelte-kit/output/server/chunks/store-85fd0788.js
function deepCopy(value) {
  return deepExtend(void 0, value);
}
function deepExtend(target, source) {
  if (!(source instanceof Object)) {
    return source;
  }
  switch (source.constructor) {
    case Date:
      const dateValue = source;
      return new Date(dateValue.getTime());
    case Object:
      if (target === void 0) {
        target = {};
      }
      break;
    case Array:
      target = [];
      break;
    default:
      return source;
  }
  for (const prop in source) {
    if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {
      continue;
    }
    target[prop] = deepExtend(target[prop], source[prop]);
  }
  return target;
}
function isValidKey(key) {
  return key !== "__proto__";
}
function getUA() {
  if (typeof navigator !== "undefined" && typeof navigator["userAgent"] === "string") {
    return navigator["userAgent"];
  } else {
    return "";
  }
}
function isMobileCordova() {
  return typeof window !== "undefined" && !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
}
function isBrowserExtension() {
  const runtime = typeof chrome === "object" ? chrome.runtime : typeof browser === "object" ? browser.runtime : void 0;
  return typeof runtime === "object" && runtime.id !== void 0;
}
function isReactNative() {
  return typeof navigator === "object" && navigator["product"] === "ReactNative";
}
function isElectron() {
  return getUA().indexOf("Electron/") >= 0;
}
function isIE() {
  const ua2 = getUA();
  return ua2.indexOf("MSIE ") >= 0 || ua2.indexOf("Trident/") >= 0;
}
function isUWP() {
  return getUA().indexOf("MSAppHost/") >= 0;
}
function isNodeSdk() {
  return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
}
function replaceTemplate(template2, data) {
  return template2.replace(PATTERN, (_, key) => {
    const value = data[key];
    return value != null ? String(value) : `<${key}?>`;
  });
}
function jsonEval(str) {
  return JSON.parse(str);
}
function stringify(data) {
  return JSON.stringify(data);
}
function contains(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function safeGet(obj, key) {
  if (Object.prototype.hasOwnProperty.call(obj, key)) {
    return obj[key];
  } else {
    return void 0;
  }
}
function isEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
function map(obj, fn2, contextObj) {
  const res = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      res[key] = fn2.call(contextObj, obj[key], key, obj);
    }
  }
  return res;
}
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  for (const k2 of aKeys) {
    if (!bKeys.includes(k2)) {
      return false;
    }
    const aProp = a[k2];
    const bProp = b[k2];
    if (isObject(aProp) && isObject(bProp)) {
      if (!deepEqual(aProp, bProp)) {
        return false;
      }
    } else if (aProp !== bProp) {
      return false;
    }
  }
  for (const k2 of bKeys) {
    if (!aKeys.includes(k2)) {
      return false;
    }
  }
  return true;
}
function isObject(thing) {
  return thing !== null && typeof thing === "object";
}
function querystring(querystringParams) {
  const params = [];
  for (const [key, value] of Object.entries(querystringParams)) {
    if (Array.isArray(value)) {
      value.forEach((arrayVal) => {
        params.push(encodeURIComponent(key) + "=" + encodeURIComponent(arrayVal));
      });
    } else {
      params.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
    }
  }
  return params.length ? "&" + params.join("&") : "";
}
function createSubscribe(executor, onNoObservers) {
  const proxy2 = new ObserverProxy(executor, onNoObservers);
  return proxy2.subscribe.bind(proxy2);
}
function implementsAnyMethods(obj, methods2) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  for (const method of methods2) {
    if (method in obj && typeof obj[method] === "function") {
      return true;
    }
  }
  return false;
}
function noop2() {
}
function errorPrefix(fnName, argName) {
  return `${fnName} failed: ${argName} argument `;
}
function getModularInstance(service) {
  if (service && service._delegate) {
    return service._delegate;
  } else {
    return service;
  }
}
function isVersionServiceProvider(provider) {
  const component = provider.getComponent();
  return (component === null || component === void 0 ? void 0 : component.type) === "VERSION";
}
function _addComponent(app, component) {
  try {
    app.container.addComponent(component);
  } catch (e) {
    logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);
  }
}
function _registerComponent(component) {
  const componentName = component.name;
  if (_components.has(componentName)) {
    logger.debug(`There were multiple attempts to register component ${componentName}.`);
    return false;
  }
  _components.set(componentName, component);
  for (const app of _apps.values()) {
    _addComponent(app, component);
  }
  return true;
}
function _getProvider(app, name22) {
  return app.container.getProvider(name22);
}
function getApp(name22 = DEFAULT_ENTRY_NAME) {
  const app = _apps.get(name22);
  if (!app) {
    throw ERROR_FACTORY.create("no-app", { appName: name22 });
  }
  return app;
}
function registerVersion(libraryKeyOrName, version22, variant) {
  var _a2;
  let library = (_a2 = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a2 !== void 0 ? _a2 : libraryKeyOrName;
  if (variant) {
    library += `-${variant}`;
  }
  const libraryMismatch = library.match(/\s|\//);
  const versionMismatch = version22.match(/\s|\//);
  if (libraryMismatch || versionMismatch) {
    const warning = [
      `Unable to register library "${library}" with version "${version22}":`
    ];
    if (libraryMismatch) {
      warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
    }
    if (libraryMismatch && versionMismatch) {
      warning.push("and");
    }
    if (versionMismatch) {
      warning.push(`version name "${version22}" contains illegal characters (whitespace or "/")`);
    }
    logger.warn(warning.join(" "));
    return;
  }
  _registerComponent(new Component(`${library}-version`, () => ({ library, version: version22 }), "VERSION"));
}
function registerCoreComponents(variant) {
  _registerComponent(new Component("platform-logger", (container) => new PlatformLoggerServiceImpl(container), "PRIVATE"));
  registerVersion(name$o, version$1, variant);
  registerVersion(name$o, version$1, "esm2017");
  registerVersion("fire-js", "");
}
function aa() {
}
function ba$1(a) {
  var b = typeof a;
  b = b != "object" ? b : a ? Array.isArray(a) ? "array" : b : "null";
  return b == "array" || b == "object" && typeof a.length == "number";
}
function p(a) {
  var b = typeof a;
  return b == "object" && a != null || b == "function";
}
function da$1(a) {
  return Object.prototype.hasOwnProperty.call(a, ea) && a[ea] || (a[ea] = ++fa$1);
}
function ha$1(a, b, c) {
  return a.call.apply(a.bind, arguments);
}
function ia$1(a, b, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d2 = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d2);
      return a.apply(b, e);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
}
function q$1(a, b, c) {
  Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? q$1 = ha$1 : q$1 = ia$1;
  return q$1.apply(null, arguments);
}
function ja(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d2 = c.slice();
    d2.push.apply(d2, arguments);
    return a.apply(this, d2);
  };
}
function t(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.Z = b.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Vb = function(d2, e, f) {
    for (var h = Array(arguments.length - 2), n = 2; n < arguments.length; n++)
      h[n - 2] = arguments[n];
    return b.prototype[e].apply(d2, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
function oa(a) {
  a: {
    var b = pa$1;
    const c = a.length, d2 = typeof a === "string" ? a.split("") : a;
    for (let e = 0; e < c; e++)
      if (e in d2 && b.call(void 0, d2[e], e, a)) {
        b = e;
        break a;
      }
    b = -1;
  }
  return 0 > b ? null : typeof a === "string" ? a.charAt(b) : a[b];
}
function qa(a) {
  return Array.prototype.concat.apply([], arguments);
}
function ra(a) {
  const b = a.length;
  if (0 < b) {
    const c = Array(b);
    for (let d2 = 0; d2 < b; d2++)
      c[d2] = a[d2];
    return c;
  }
  return [];
}
function sa(a) {
  return /^[\s\xa0]*$/.test(a);
}
function w(a, b) {
  return a.indexOf(b) != -1;
}
function ua$1(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
function xa(a, b, c) {
  for (const d2 in a)
    b.call(c, a[d2], d2, a);
}
function ya(a) {
  const b = {};
  for (const c in a)
    b[c] = a[c];
  return b;
}
function Aa$1(a, b) {
  let c, d2;
  for (let e = 1; e < arguments.length; e++) {
    d2 = arguments[e];
    for (c in d2)
      a[c] = d2[c];
    for (let f = 0; f < za.length; f++)
      c = za[f], Object.prototype.hasOwnProperty.call(d2, c) && (a[c] = d2[c]);
  }
}
function Ca$1(a) {
  Ca$1[" "](a);
  return a;
}
function Fa$1(a) {
  var b = Ga;
  return Object.prototype.hasOwnProperty.call(b, 9) ? b[9] : b[9] = a(9);
}
function Ma$1() {
  var a = l.document;
  return a ? a.documentMode : void 0;
}
function Ra$1() {
  return Fa$1(function() {
    let a = 0;
    const b = ta(String(Na)).split("."), c = ta("9").split("."), d2 = Math.max(b.length, c.length);
    for (let h = 0; a == 0 && h < d2; h++) {
      var e = b[h] || "", f = c[h] || "";
      do {
        e = /(\d*)(\D*)(.*)/.exec(e) || ["", "", "", ""];
        f = /(\d*)(\D*)(.*)/.exec(f) || ["", "", "", ""];
        if (e[0].length == 0 && f[0].length == 0)
          break;
        a = ua$1(e[1].length == 0 ? 0 : parseInt(e[1], 10), f[1].length == 0 ? 0 : parseInt(f[1], 10)) || ua$1(e[2].length == 0, f[2].length == 0) || ua$1(e[2], f[2]);
        e = e[3];
        f = f[3];
      } while (a == 0);
    }
    return 0 <= a;
  });
}
function z(a, b) {
  this.type = a;
  this.g = this.target = b;
  this.defaultPrevented = false;
}
function A(a, b) {
  z.call(this, a ? a.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a) {
    var c = this.type = a.type, d2 = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.g = b;
    if (b = a.relatedTarget) {
      if (Ka) {
        a: {
          try {
            Ca$1(b.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b = null);
      }
    } else
      c == "mouseover" ? b = a.fromElement : c == "mouseout" && (b = a.toElement);
    this.relatedTarget = b;
    d2 ? (this.clientX = d2.clientX !== void 0 ? d2.clientX : d2.pageX, this.clientY = d2.clientY !== void 0 ? d2.clientY : d2.pageY, this.screenX = d2.screenX || 0, this.screenY = d2.screenY || 0) : (this.clientX = a.clientX !== void 0 ? a.clientX : a.pageX, this.clientY = a.clientY !== void 0 ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = typeof a.pointerType === "string" ? a.pointerType : Wa[a.pointerType] || "";
    this.state = a.state;
    this.i = a;
    a.defaultPrevented && A.Z.h.call(this);
  }
}
function Ya(a, b, c, d2, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b;
  this.type = c;
  this.capture = !!d2;
  this.ia = e;
  this.key = ++Xa$1;
  this.ca = this.fa = false;
}
function Za$1(a) {
  a.ca = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ia = null;
}
function $a(a) {
  this.src = a;
  this.g = {};
  this.h = 0;
}
function bb(a, b) {
  var c = b.type;
  if (c in a.g) {
    var d2 = a.g[c], e = ma$1(d2, b), f;
    (f = 0 <= e) && Array.prototype.splice.call(d2, e, 1);
    f && (Za$1(b), a.g[c].length == 0 && (delete a.g[c], a.h--));
  }
}
function ab(a, b, c, d2) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.ca && f.listener == b && f.capture == !!c && f.ia == d2)
      return e;
  }
  return -1;
}
function fb(a, b, c, d2, e) {
  if (d2 && d2.once)
    return gb(a, b, c, d2, e);
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      fb(a, b[f], c, d2, e);
    return null;
  }
  c = hb(c);
  return a && a[B$1] ? a.N(b, c, p(d2) ? !!d2.capture : !!d2, e) : ib(a, b, c, false, d2, e);
}
function ib(a, b, c, d2, e, f) {
  if (!b)
    throw Error("Invalid event type");
  var h = p(e) ? !!e.capture : !!e, n = jb(a);
  n || (a[cb] = n = new $a(a));
  c = n.add(b, c, d2, h, f);
  if (c.proxy)
    return c;
  d2 = kb();
  c.proxy = d2;
  d2.src = a;
  d2.listener = c;
  if (a.addEventListener)
    Va || (e = h), e === void 0 && (e = false), a.addEventListener(b.toString(), d2, e);
  else if (a.attachEvent)
    a.attachEvent(lb(b.toString()), d2);
  else if (a.addListener && a.removeListener)
    a.addListener(d2);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function kb() {
  function a(c) {
    return b.call(a.src, a.listener, c);
  }
  var b = mb;
  return a;
}
function gb(a, b, c, d2, e) {
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      gb(a, b[f], c, d2, e);
    return null;
  }
  c = hb(c);
  return a && a[B$1] ? a.O(b, c, p(d2) ? !!d2.capture : !!d2, e) : ib(a, b, c, true, d2, e);
}
function nb(a, b, c, d2, e) {
  if (Array.isArray(b))
    for (var f = 0; f < b.length; f++)
      nb(a, b[f], c, d2, e);
  else
    (d2 = p(d2) ? !!d2.capture : !!d2, c = hb(c), a && a[B$1]) ? (a = a.i, b = String(b).toString(), b in a.g && (f = a.g[b], c = ab(f, c, d2, e), -1 < c && (Za$1(f[c]), Array.prototype.splice.call(f, c, 1), f.length == 0 && (delete a.g[b], a.h--)))) : a && (a = jb(a)) && (b = a.g[b.toString()], a = -1, b && (a = ab(b, c, d2, e)), (c = -1 < a ? b[a] : null) && ob(c));
}
function ob(a) {
  if (typeof a !== "number" && a && !a.ca) {
    var b = a.src;
    if (b && b[B$1])
      bb(b.i, a);
    else {
      var c = a.type, d2 = a.proxy;
      b.removeEventListener ? b.removeEventListener(c, d2, a.capture) : b.detachEvent ? b.detachEvent(lb(c), d2) : b.addListener && b.removeListener && b.removeListener(d2);
      (c = jb(b)) ? (bb(c, a), c.h == 0 && (c.src = null, b[cb] = null)) : Za$1(a);
    }
  }
}
function lb(a) {
  return a in db ? db[a] : db[a] = "on" + a;
}
function mb(a, b) {
  if (a.ca)
    a = true;
  else {
    b = new A(b, this);
    var c = a.listener, d2 = a.ia || a.src;
    a.fa && ob(a);
    a = c.call(d2, b);
  }
  return a;
}
function jb(a) {
  a = a[cb];
  return a instanceof $a ? a : null;
}
function hb(a) {
  if (typeof a === "function")
    return a;
  a[pb] || (a[pb] = function(b) {
    return a.handleEvent(b);
  });
  return a[pb];
}
function C$1() {
  v.call(this);
  this.i = new $a(this);
  this.P = this;
  this.I = null;
}
function D$1(a, b) {
  var c, d2 = a.I;
  if (d2)
    for (c = []; d2; d2 = d2.I)
      c.push(d2);
  a = a.P;
  d2 = b.type || b;
  if (typeof b === "string")
    b = new z(b, a);
  else if (b instanceof z)
    b.target = b.target || a;
  else {
    var e = b;
    b = new z(d2, a);
    Aa$1(b, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var h = b.g = c[f];
      e = qb(h, d2, true, b) && e;
    }
  h = b.g = a;
  e = qb(h, d2, true, b) && e;
  e = qb(h, d2, false, b) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      h = b.g = c[f], e = qb(h, d2, false, b) && e;
}
function qb(a, b, c, d2) {
  b = a.i.g[String(b)];
  if (!b)
    return true;
  b = b.concat();
  for (var e = true, f = 0; f < b.length; ++f) {
    var h = b[f];
    if (h && !h.ca && h.capture == c) {
      var n = h.listener, u = h.ia || h.src;
      h.fa && bb(a.i, h);
      e = n.call(u, d2) !== false && e;
    }
  }
  return e && !d2.defaultPrevented;
}
function sb() {
  var a = tb;
  let b = null;
  a.g && (b = a.g, a.g = a.g.next, a.g || (a.h = null), b.next = null);
  return b;
}
function yb(a) {
  l.setTimeout(() => {
    throw a;
  }, 0);
}
function zb(a, b) {
  Ab || Bb();
  Cb || (Ab(), Cb = true);
  tb.add(a, b);
}
function Bb() {
  var a = l.Promise.resolve(void 0);
  Ab = function() {
    a.then(Db);
  };
}
function Db() {
  for (var a; a = sb(); ) {
    try {
      a.h.call(a.g);
    } catch (c) {
      yb(c);
    }
    var b = vb;
    b.j(a);
    100 > b.h && (b.h++, a.next = b.g, b.g = a);
  }
  Cb = false;
}
function Eb(a, b) {
  C$1.call(this);
  this.h = a || 1;
  this.g = b || l;
  this.j = q$1(this.kb, this);
  this.l = Date.now();
}
function Fb(a) {
  a.da = false;
  a.S && (a.g.clearTimeout(a.S), a.S = null);
}
function Gb(a, b, c) {
  if (typeof a === "function")
    c && (a = q$1(a, c));
  else if (a && typeof a.handleEvent == "function")
    a = q$1(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
}
function Hb(a) {
  a.g = Gb(() => {
    a.g = null;
    a.i && (a.i = false, Hb(a));
  }, a.j);
  const b = a.h;
  a.h = null;
  a.m.apply(null, b);
}
function E(a) {
  v.call(this);
  this.h = a;
  this.g = {};
}
function Kb(a, b, c, d2) {
  Array.isArray(c) || (c && (Jb[0] = c.toString()), c = Jb);
  for (var e = 0; e < c.length; e++) {
    var f = fb(b, c[e], d2 || a.handleEvent, false, a.h || a);
    if (!f)
      break;
    a.g[f.key] = f;
  }
}
function Lb(a) {
  xa(a.g, function(b, c) {
    this.g.hasOwnProperty(c) && ob(b);
  }, a);
  a.g = {};
}
function Mb() {
  this.g = true;
}
function Nb(a, b, c, d2, e, f) {
  a.info(function() {
    if (a.g)
      if (f) {
        var h = "";
        for (var n = f.split("&"), u = 0; u < n.length; u++) {
          var m = n[u].split("=");
          if (1 < m.length) {
            var r = m[0];
            m = m[1];
            var G2 = r.split("_");
            h = 2 <= G2.length && G2[1] == "type" ? h + (r + "=" + m + "&") : h + (r + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d2 + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + h;
  });
}
function Ob(a, b, c, d2, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d2 + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + h;
  });
}
function F$1(a, b, c, d2) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b + "): " + Pb(a, c) + (d2 ? " " + d2 : "");
  });
}
function Qb(a, b) {
  a.info(function() {
    return "TIMEOUT: " + b;
  });
}
function Pb(a, b) {
  if (!a.g)
    return b;
  if (!b)
    return null;
  try {
    var c = JSON.parse(b);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d2 = c[a];
          if (!(2 > d2.length)) {
            var e = d2[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if (f != "noop" && f != "stop" && f != "close")
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return rb(c);
  } catch (n) {
    return b;
  }
}
function Sb() {
  return Rb = Rb || new C$1();
}
function Tb(a) {
  z.call(this, H$1.Ma, a);
}
function I(a) {
  const b = Sb();
  D$1(b, new Tb(b, a));
}
function Ub(a, b) {
  z.call(this, H$1.STAT_EVENT, a);
  this.stat = b;
}
function J$1(a) {
  const b = Sb();
  D$1(b, new Ub(b, a));
}
function Vb(a, b) {
  z.call(this, H$1.Na, a);
  this.size = b;
}
function K$1(a, b) {
  if (typeof a !== "function")
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a();
  }, b);
}
function Yb() {
}
function Zb(a) {
  return a.h || (a.h = a.i());
}
function $b() {
}
function ac$1() {
  z.call(this, "d");
}
function bc() {
  z.call(this, "c");
}
function dc$1() {
}
function M$1(a, b, c, d2) {
  this.l = a;
  this.j = b;
  this.m = c;
  this.X = d2 || 1;
  this.V = new E(this);
  this.P = ec$1;
  a = Ja$1 ? 125 : void 0;
  this.W = new Eb(a);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.Y = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.N = -1;
  this.I = false;
  this.O = 0;
  this.L = null;
  this.aa = this.J = this.$ = this.U = false;
  this.h = new fc$1();
}
function fc$1() {
  this.i = null;
  this.g = "";
  this.h = false;
}
function ic$1(a, b, c) {
  a.K = 1;
  a.v = jc$1(N$1(b));
  a.s = c;
  a.U = true;
  kc$1(a, null);
}
function kc$1(a, b) {
  a.F = Date.now();
  lc(a);
  a.A = N$1(a.v);
  var c = a.A, d2 = a.X;
  Array.isArray(d2) || (d2 = [String(d2)]);
  mc$1(c.h, "t", d2);
  a.C = 0;
  c = a.l.H;
  a.h = new fc$1();
  a.g = nc$1(a.l, c ? b : null, !a.s);
  0 < a.O && (a.L = new Ib(q$1(a.Ia, a, a.g), a.O));
  Kb(a.V, a.g, "readystatechange", a.gb);
  b = a.H ? ya(a.H) : {};
  a.s ? (a.u || (a.u = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.g.ea(a.A, a.u, a.s, b)) : (a.u = "GET", a.g.ea(a.A, a.u, null, b));
  I(1);
  Nb(a.j, a.u, a.A, a.m, a.X, a.s);
}
function qc(a) {
  return a.g ? a.u == "GET" && a.K != 2 && a.l.Ba : false;
}
function tc$1(a, b, c) {
  let d2 = true, e;
  for (; !a.I && a.C < c.length; )
    if (e = vc(a, c), e == hc$1) {
      b == 4 && (a.o = 4, J$1(14), d2 = false);
      F$1(a.j, a.m, null, "[Incomplete Response]");
      break;
    } else if (e == gc$1) {
      a.o = 4;
      J$1(15);
      F$1(a.j, a.m, c, "[Invalid Chunk]");
      d2 = false;
      break;
    } else
      F$1(a.j, a.m, e, null), sc$1(a, e);
  qc(a) && e != hc$1 && e != gc$1 && (a.h.g = "", a.C = 0);
  b != 4 || c.length != 0 || a.h.h || (a.o = 1, J$1(16), d2 = false);
  a.i = a.i && d2;
  d2 ? 0 < c.length && !a.aa && (a.aa = true, b = a.l, b.g == a && b.$ && !b.L && (b.h.info("Great, no buffering proxy detected. Bytes received: " + c.length), wc$1(b), b.L = true, J$1(11))) : (F$1(a.j, a.m, c, "[Invalid Chunked Response]"), P(a), rc$1(a));
}
function vc(a, b) {
  var c = a.C, d2 = b.indexOf("\n", c);
  if (d2 == -1)
    return hc$1;
  c = Number(b.substring(c, d2));
  if (isNaN(c))
    return gc$1;
  d2 += 1;
  if (d2 + c > b.length)
    return hc$1;
  b = b.substr(d2, c);
  a.C = d2 + c;
  return b;
}
function lc(a) {
  a.Y = Date.now() + a.P;
  xc(a, a.P);
}
function xc(a, b) {
  if (a.B != null)
    throw Error("WatchDog timer not null");
  a.B = K$1(q$1(a.eb, a), b);
}
function pc$1(a) {
  a.B && (l.clearTimeout(a.B), a.B = null);
}
function rc$1(a) {
  a.l.G == 0 || a.I || uc$1(a.l, a);
}
function P(a) {
  pc$1(a);
  var b = a.L;
  b && typeof b.na == "function" && b.na();
  a.L = null;
  Fb(a.W);
  Lb(a.V);
  a.g && (b = a.g, a.g = null, b.abort(), b.na());
}
function sc$1(a, b) {
  try {
    var c = a.l;
    if (c.G != 0 && (c.g == a || yc$1(c.i, a))) {
      if (c.I = a.N, !a.J && yc$1(c.i, a) && c.G == 3) {
        try {
          var d2 = c.Ca.g.parse(b);
        } catch (m) {
          d2 = null;
        }
        if (Array.isArray(d2) && d2.length == 3) {
          var e = d2;
          if (e[0] == 0)
            a: {
              if (!c.u) {
                if (c.g)
                  if (c.g.F + 3e3 < a.F)
                    zc(c), Ac(c);
                  else
                    break a;
                Bc(c);
                J$1(18);
              }
            }
          else
            c.ta = e[1], 0 < c.ta - c.U && 37500 > e[2] && c.N && c.A == 0 && !c.v && (c.v = K$1(q$1(c.ab, c), 6e3));
          if (1 >= Cc$1(c.i) && c.ka) {
            try {
              c.ka();
            } catch (m) {
            }
            c.ka = void 0;
          }
        } else
          Q$1(c, 11);
      } else if ((a.J || c.g == a) && zc(c), !sa(b))
        for (e = c.Ca.g.parse(b), b = 0; b < e.length; b++) {
          let m = e[b];
          c.U = m[0];
          m = m[1];
          if (c.G == 2)
            if (m[0] == "c") {
              c.J = m[1];
              c.la = m[2];
              const r = m[3];
              r != null && (c.ma = r, c.h.info("VER=" + c.ma));
              const G2 = m[4];
              G2 != null && (c.za = G2, c.h.info("SVER=" + c.za));
              const Da2 = m[5];
              Da2 != null && typeof Da2 === "number" && 0 < Da2 && (d2 = 1.5 * Da2, c.K = d2, c.h.info("backChannelRequestTimeoutMs_=" + d2));
              d2 = c;
              const ca = a.g;
              if (ca) {
                const Ea = ca.g ? ca.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Ea) {
                  var f = d2.i;
                  !f.g && (w(Ea, "spdy") || w(Ea, "quic") || w(Ea, "h2")) && (f.j = f.l, f.g = new Set(), f.h && (Dc(f, f.h), f.h = null));
                }
                if (d2.D) {
                  const xb = ca.g ? ca.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  xb && (d2.sa = xb, R(d2.F, d2.D, xb));
                }
              }
              c.G = 3;
              c.j && c.j.xa();
              c.$ && (c.O = Date.now() - a.F, c.h.info("Handshake RTT: " + c.O + "ms"));
              d2 = c;
              var h = a;
              d2.oa = Ec$1(d2, d2.H ? d2.la : null, d2.W);
              if (h.J) {
                Fc$1(d2.i, h);
                var n = h, u = d2.K;
                u && n.setTimeout(u);
                n.B && (pc$1(n), lc(n));
                d2.g = h;
              } else
                Gc$1(d2);
              0 < c.l.length && Hc(c);
            } else
              m[0] != "stop" && m[0] != "close" || Q$1(c, 7);
          else
            c.G == 3 && (m[0] == "stop" || m[0] == "close" ? m[0] == "stop" ? Q$1(c, 7) : Ic(c) : m[0] != "noop" && c.j && c.j.wa(m), c.A = 0);
        }
    }
    I(4);
  } catch (m) {
  }
}
function Jc(a) {
  if (a.R && typeof a.R == "function")
    return a.R();
  if (typeof a === "string")
    return a.split("");
  if (ba$1(a)) {
    for (var b = [], c = a.length, d2 = 0; d2 < c; d2++)
      b.push(a[d2]);
    return b;
  }
  b = [];
  c = 0;
  for (d2 in a)
    b[c++] = a[d2];
  return b;
}
function Kc$1(a, b) {
  if (a.forEach && typeof a.forEach == "function")
    a.forEach(b, void 0);
  else if (ba$1(a) || typeof a === "string")
    na$1(a, b, void 0);
  else {
    if (a.T && typeof a.T == "function")
      var c = a.T();
    else if (a.R && typeof a.R == "function")
      c = void 0;
    else if (ba$1(a) || typeof a === "string") {
      c = [];
      for (var d2 = a.length, e = 0; e < d2; e++)
        c.push(e);
    } else
      for (e in c = [], d2 = 0, a)
        c[d2++] = e;
    d2 = Jc(a);
    e = d2.length;
    for (var f = 0; f < e; f++)
      b.call(void 0, d2[f], c && c[f], a);
  }
}
function S$1(a, b) {
  this.h = {};
  this.g = [];
  this.i = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d2 = 0; d2 < c; d2 += 2)
      this.set(arguments[d2], arguments[d2 + 1]);
  } else if (a)
    if (a instanceof S$1)
      for (c = a.T(), d2 = 0; d2 < c.length; d2++)
        this.set(c[d2], a.get(c[d2]));
    else
      for (d2 in a)
        this.set(d2, a[d2]);
}
function Lc$1(a) {
  if (a.i != a.g.length) {
    for (var b = 0, c = 0; b < a.g.length; ) {
      var d2 = a.g[b];
      T(a.h, d2) && (a.g[c++] = d2);
      b++;
    }
    a.g.length = c;
  }
  if (a.i != a.g.length) {
    var e = {};
    for (c = b = 0; b < a.g.length; )
      d2 = a.g[b], T(e, d2) || (a.g[c++] = d2, e[d2] = 1), b++;
    a.g.length = c;
  }
}
function T(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
function Nc$1(a, b) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d2 = a[c].indexOf("="), e = null;
      if (0 <= d2) {
        var f = a[c].substring(0, d2);
        e = a[c].substring(d2 + 1);
      } else
        f = a[c];
      b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function U(a, b) {
  this.i = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.g = false;
  if (a instanceof U) {
    this.g = b !== void 0 ? b : a.g;
    Oc(this, a.j);
    this.s = a.s;
    Pc(this, a.i);
    Qc$1(this, a.m);
    this.l = a.l;
    b = a.h;
    var c = new Rc();
    c.i = b.i;
    b.g && (c.g = new S$1(b.g), c.h = b.h);
    Sc(this, c);
    this.o = a.o;
  } else
    a && (c = String(a).match(Mc)) ? (this.g = !!b, Oc(this, c[1] || "", true), this.s = Tc$1(c[2] || ""), Pc(this, c[3] || "", true), Qc$1(this, c[4]), this.l = Tc$1(c[5] || "", true), Sc(this, c[6] || "", true), this.o = Tc$1(c[7] || "")) : (this.g = !!b, this.h = new Rc(null, this.g));
}
function N$1(a) {
  return new U(a);
}
function Oc(a, b, c) {
  a.j = c ? Tc$1(b, true) : b;
  a.j && (a.j = a.j.replace(/:$/, ""));
}
function Pc(a, b, c) {
  a.i = c ? Tc$1(b, true) : b;
}
function Qc$1(a, b) {
  if (b) {
    b = Number(b);
    if (isNaN(b) || 0 > b)
      throw Error("Bad port number " + b);
    a.m = b;
  } else
    a.m = null;
}
function Sc(a, b, c) {
  b instanceof Rc ? (a.h = b, Zc(a.h, a.g)) : (c || (b = Uc(b, $c)), a.h = new Rc(b, a.g));
}
function R(a, b, c) {
  a.h.set(b, c);
}
function jc$1(a) {
  R(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a;
}
function ad(a) {
  return a instanceof U ? N$1(a) : new U(a, void 0);
}
function bd(a, b, c, d2) {
  var e = new U(null, void 0);
  a && Oc(e, a);
  b && Pc(e, b);
  c && Qc$1(e, c);
  d2 && (e.l = d2);
  return e;
}
function Tc$1(a, b) {
  return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Uc(a, b, c) {
  return typeof a === "string" ? (a = encodeURI(a).replace(b, cd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function cd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
function Rc(a, b) {
  this.h = this.g = null;
  this.i = a || null;
  this.j = !!b;
}
function V(a) {
  a.g || (a.g = new S$1(), a.h = 0, a.i && Nc$1(a.i, function(b, c) {
    a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
  }));
}
function dd(a, b) {
  V(a);
  b = W$1(a, b);
  T(a.g.h, b) && (a.i = null, a.h -= a.g.get(b).length, a = a.g, T(a.h, b) && (delete a.h[b], a.i--, a.g.length > 2 * a.i && Lc$1(a)));
}
function ed(a, b) {
  V(a);
  b = W$1(a, b);
  return T(a.g.h, b);
}
function mc$1(a, b, c) {
  dd(a, b);
  0 < c.length && (a.i = null, a.g.set(W$1(a, b), ra(c)), a.h += c.length);
}
function W$1(a, b) {
  b = String(b);
  a.j && (b = b.toLowerCase());
  return b;
}
function Zc(a, b) {
  b && !a.j && (V(a), a.i = null, a.g.forEach(function(c, d2) {
    var e = d2.toLowerCase();
    d2 != e && (dd(this, d2), mc$1(this, e, c));
  }, a));
  a.j = b;
}
function gd(a) {
  this.l = a || hd;
  l.PerformanceNavigationTiming ? (a = l.performance.getEntriesByType("navigation"), a = 0 < a.length && (a[0].nextHopProtocol == "hq" || a[0].nextHopProtocol == "h2")) : a = !!(l.g && l.g.Ea && l.g.Ea() && l.g.Ea().Zb);
  this.j = a ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = new Set());
  this.h = null;
  this.i = [];
}
function id(a) {
  return a.h ? true : a.g ? a.g.size >= a.j : false;
}
function Cc$1(a) {
  return a.h ? 1 : a.g ? a.g.size : 0;
}
function yc$1(a, b) {
  return a.h ? a.h == b : a.g ? a.g.has(b) : false;
}
function Dc(a, b) {
  a.g ? a.g.add(b) : a.h = b;
}
function Fc$1(a, b) {
  a.h && a.h == b ? a.h = null : a.g && a.g.has(b) && a.g.delete(b);
}
function jd(a) {
  if (a.h != null)
    return a.i.concat(a.h.D);
  if (a.g != null && a.g.size !== 0) {
    let b = a.i;
    for (const c of a.g.values())
      b = b.concat(c.D);
    return b;
  }
  return ra(a.i);
}
function kd() {
}
function ld() {
  this.g = new kd();
}
function md(a, b, c) {
  const d2 = c || "";
  try {
    Kc$1(a, function(e, f) {
      let h = e;
      p(e) && (h = rb(e));
      b.push(d2 + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b.push(d2 + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function nd(a, b) {
  const c = new Mb();
  if (l.Image) {
    const d2 = new Image();
    d2.onload = ja(od, c, d2, "TestLoadImage: loaded", true, b);
    d2.onerror = ja(od, c, d2, "TestLoadImage: error", false, b);
    d2.onabort = ja(od, c, d2, "TestLoadImage: abort", false, b);
    d2.ontimeout = ja(od, c, d2, "TestLoadImage: timeout", false, b);
    l.setTimeout(function() {
      if (d2.ontimeout)
        d2.ontimeout();
    }, 1e4);
    d2.src = a;
  } else
    b(false);
}
function od(a, b, c, d2, e) {
  try {
    b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d2);
  } catch (f) {
  }
}
function pd(a) {
  this.l = a.$b || null;
  this.j = a.ib || false;
}
function qd(a, b) {
  C$1.call(this);
  this.D = a;
  this.u = b;
  this.m = void 0;
  this.readyState = rd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
function ud(a) {
  a.j.read().then(a.Sa.bind(a)).catch(a.ha.bind(a));
}
function td(a) {
  a.readyState = 4;
  a.l = null;
  a.j = null;
  a.A = null;
  sd(a);
}
function sd(a) {
  a.onreadystatechange && a.onreadystatechange.call(a);
}
function X$1(a) {
  C$1.call(this);
  this.headers = new S$1();
  this.u = a || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = wd;
  this.K = this.L = false;
}
function Bd(a) {
  return y && Ra$1() && typeof a.timeout === "number" && a.ontimeout !== void 0;
}
function pa$1(a) {
  return a.toLowerCase() == "content-type";
}
function zd(a, b) {
  a.h = false;
  a.g && (a.l = true, a.g.abort(), a.l = false);
  a.j = b;
  a.m = 5;
  Cd(a);
  Dd(a);
}
function Cd(a) {
  a.D || (a.D = true, D$1(a, "complete"), D$1(a, "error"));
}
function Ed(a) {
  if (a.h && typeof goog != "undefined" && (!a.C[1] || O$1(a) != 4 || a.ba() != 2)) {
    if (a.v && O$1(a) == 4)
      Gb(a.Fa, 0, a);
    else if (D$1(a, "readystatechange"), O$1(a) == 4) {
      a.h = false;
      try {
        const n = a.ba();
        a:
          switch (n) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b = true;
              break a;
            default:
              b = false;
          }
        var c;
        if (!(c = b)) {
          var d2;
          if (d2 = n === 0) {
            var e = String(a.H).match(Mc)[1] || null;
            if (!e && l.self && l.self.location) {
              var f = l.self.location.protocol;
              e = f.substr(0, f.length - 1);
            }
            d2 = !xd.test(e ? e.toLowerCase() : "");
          }
          c = d2;
        }
        if (c)
          D$1(a, "complete"), D$1(a, "success");
        else {
          a.m = 6;
          try {
            var h = 2 < O$1(a) ? a.g.statusText : "";
          } catch (u) {
            h = "";
          }
          a.j = h + " [" + a.ba() + "]";
          Cd(a);
        }
      } finally {
        Dd(a);
      }
    }
  }
}
function Dd(a, b) {
  if (a.g) {
    Ad(a);
    const c = a.g, d2 = a.C[0] ? aa : null;
    a.g = null;
    a.C = null;
    b || D$1(a, "ready");
    try {
      c.onreadystatechange = d2;
    } catch (e) {
    }
  }
}
function Ad(a) {
  a.g && a.K && (a.g.ontimeout = null);
  a.A && (l.clearTimeout(a.A), a.A = null);
}
function O$1(a) {
  return a.g ? a.g.readyState : 0;
}
function oc$1(a) {
  try {
    if (!a.g)
      return null;
    if ("response" in a.g)
      return a.g.response;
    switch (a.J) {
      case wd:
      case "text":
        return a.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a.g)
          return a.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b) {
    return null;
  }
}
function Fd(a) {
  let b = "";
  xa(a, function(c, d2) {
    b += d2;
    b += ":";
    b += c;
    b += "\r\n";
  });
  return b;
}
function Gd(a, b, c) {
  a: {
    for (d2 in c) {
      var d2 = false;
      break a;
    }
    d2 = true;
  }
  d2 || (c = Fd(c), typeof a === "string" ? c != null && encodeURIComponent(String(c)) : R(a, b, c));
}
function Hd(a, b, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b : b;
}
function Id(a) {
  this.za = 0;
  this.l = [];
  this.h = new Mb();
  this.la = this.oa = this.F = this.W = this.g = this.sa = this.D = this.aa = this.o = this.P = this.s = null;
  this.Za = this.V = 0;
  this.Xa = Hd("failFast", false, a);
  this.N = this.v = this.u = this.m = this.j = null;
  this.X = true;
  this.I = this.ta = this.U = -1;
  this.Y = this.A = this.C = 0;
  this.Pa = Hd("baseRetryDelayMs", 5e3, a);
  this.$a = Hd("retryDelaySeedMs", 1e4, a);
  this.Ya = Hd("forwardChannelMaxRetries", 2, a);
  this.ra = Hd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.qa = a && a.xmlHttpFactory || void 0;
  this.Ba = a && a.Yb || false;
  this.K = void 0;
  this.H = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.i = new gd(a && a.concurrentRequestLimit);
  this.Ca = new ld();
  this.ja = a && a.fastHandshake || false;
  this.Ra = a && a.Wb || false;
  a && a.Aa && this.h.Aa();
  a && a.forceLongPolling && (this.X = false);
  this.$ = !this.ja && this.X && a && a.detectBufferingProxy || false;
  this.ka = void 0;
  this.O = 0;
  this.L = false;
  this.B = null;
  this.Wa = !a || a.Xb !== false;
}
function Ic(a) {
  Jd(a);
  if (a.G == 3) {
    var b = a.V++, c = N$1(a.F);
    R(c, "SID", a.J);
    R(c, "RID", b);
    R(c, "TYPE", "terminate");
    Kd(a, c);
    b = new M$1(a, a.h, b, void 0);
    b.K = 2;
    b.v = jc$1(N$1(c));
    c = false;
    l.navigator && l.navigator.sendBeacon && (c = l.navigator.sendBeacon(b.v.toString(), ""));
    !c && l.Image && (new Image().src = b.v, c = true);
    c || (b.g = nc$1(b.l, null), b.g.ea(b.v));
    b.F = Date.now();
    lc(b);
  }
  Ld(a);
}
function Ac(a) {
  a.g && (wc$1(a), a.g.cancel(), a.g = null);
}
function Jd(a) {
  Ac(a);
  a.u && (l.clearTimeout(a.u), a.u = null);
  zc(a);
  a.i.cancel();
  a.m && (typeof a.m === "number" && l.clearTimeout(a.m), a.m = null);
}
function Md(a, b) {
  a.l.push(new fd(a.Za++, b));
  a.G == 3 && Hc(a);
}
function Hc(a) {
  id(a.i) || a.m || (a.m = true, zb(a.Ha, a), a.C = 0);
}
function Nd(a, b) {
  if (Cc$1(a.i) >= a.i.j - (a.m ? 1 : 0))
    return false;
  if (a.m)
    return a.l = b.D.concat(a.l), true;
  if (a.G == 1 || a.G == 2 || a.C >= (a.Xa ? 0 : a.Ya))
    return false;
  a.m = K$1(q$1(a.Ha, a, b), Od(a, a.C));
  a.C++;
  return true;
}
function Qd(a, b) {
  var c;
  b ? c = b.m : c = a.V++;
  const d2 = N$1(a.F);
  R(d2, "SID", a.J);
  R(d2, "RID", c);
  R(d2, "AID", a.U);
  Kd(a, d2);
  a.o && a.s && Gd(d2, a.o, a.s);
  c = new M$1(a, a.h, c, a.C + 1);
  a.o === null && (c.H = a.s);
  b && (a.l = b.D.concat(a.l));
  b = Pd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ra) + Math.round(0.5 * a.ra * Math.random()));
  Dc(a.i, c);
  ic$1(c, d2, b);
}
function Kd(a, b) {
  a.j && Kc$1({}, function(c, d2) {
    R(b, d2, c);
  });
}
function Pd(a, b, c) {
  c = Math.min(a.l.length, c);
  var d2 = a.j ? q$1(a.j.Oa, a.j, a) : null;
  a: {
    var e = a.l;
    let f = -1;
    for (; ; ) {
      const h = ["count=" + c];
      f == -1 ? 0 < c ? (f = e[0].h, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      let n = true;
      for (let u = 0; u < c; u++) {
        let m = e[u].h;
        const r = e[u].g;
        m -= f;
        if (0 > m)
          f = Math.max(0, e[u].h - 100), n = false;
        else
          try {
            md(r, h, "req" + m + "_");
          } catch (G2) {
            d2 && d2(r);
          }
      }
      if (n) {
        d2 = h.join("&");
        break a;
      }
    }
  }
  a = a.l.splice(0, c);
  b.D = a;
  return d2;
}
function Gc$1(a) {
  a.g || a.u || (a.Y = 1, zb(a.Ga, a), a.A = 0);
}
function Bc(a) {
  if (a.g || a.u || 3 <= a.A)
    return false;
  a.Y++;
  a.u = K$1(q$1(a.Ga, a), Od(a, a.A));
  a.A++;
  return true;
}
function wc$1(a) {
  a.B != null && (l.clearTimeout(a.B), a.B = null);
}
function Rd(a) {
  a.g = new M$1(a, a.h, "rpc", a.Y);
  a.o === null && (a.g.H = a.s);
  a.g.O = 0;
  var b = N$1(a.oa);
  R(b, "RID", "rpc");
  R(b, "SID", a.J);
  R(b, "CI", a.N ? "0" : "1");
  R(b, "AID", a.U);
  Kd(a, b);
  R(b, "TYPE", "xmlhttp");
  a.o && a.s && Gd(b, a.o, a.s);
  a.K && a.g.setTimeout(a.K);
  var c = a.g;
  a = a.la;
  c.K = 1;
  c.v = jc$1(N$1(b));
  c.s = null;
  c.U = true;
  kc$1(c, a);
}
function zc(a) {
  a.v != null && (l.clearTimeout(a.v), a.v = null);
}
function uc$1(a, b) {
  var c = null;
  if (a.g == b) {
    zc(a);
    wc$1(a);
    a.g = null;
    var d2 = 2;
  } else if (yc$1(a.i, b))
    c = b.D, Fc$1(a.i, b), d2 = 1;
  else
    return;
  a.I = b.N;
  if (a.G != 0) {
    if (b.i)
      if (d2 == 1) {
        c = b.s ? b.s.length : 0;
        b = Date.now() - b.F;
        var e = a.C;
        d2 = Sb();
        D$1(d2, new Vb(d2, c, b, e));
        Hc(a);
      } else
        Gc$1(a);
    else if (e = b.o, e == 3 || e == 0 && 0 < a.I || !(d2 == 1 && Nd(a, b) || d2 == 2 && Bc(a)))
      switch (c && 0 < c.length && (b = a.i, b.i = b.i.concat(c)), e) {
        case 1:
          Q$1(a, 5);
          break;
        case 4:
          Q$1(a, 10);
          break;
        case 3:
          Q$1(a, 6);
          break;
        default:
          Q$1(a, 2);
      }
  }
}
function Od(a, b) {
  let c = a.Pa + Math.floor(Math.random() * a.$a);
  a.j || (c *= 2);
  return c * b;
}
function Q$1(a, b) {
  a.h.info("Error code " + b);
  if (b == 2) {
    var c = null;
    a.j && (c = null);
    var d2 = q$1(a.jb, a);
    c || (c = new U("//www.google.com/images/cleardot.gif"), l.location && l.location.protocol == "http" || Oc(c, "https"), jc$1(c));
    nd(c.toString(), d2);
  } else
    J$1(2);
  a.G = 0;
  a.j && a.j.va(b);
  Ld(a);
  Jd(a);
}
function Ld(a) {
  a.G = 0;
  a.I = -1;
  if (a.j) {
    if (jd(a.i).length != 0 || a.l.length != 0)
      a.i.i.length = 0, ra(a.l), a.l.length = 0;
    a.j.ua();
  }
}
function Ec$1(a, b, c) {
  let d2 = ad(c);
  if (d2.i != "")
    b && Pc(d2, b + "." + d2.i), Qc$1(d2, d2.m);
  else {
    const e = l.location;
    d2 = bd(e.protocol, b ? b + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.aa && xa(a.aa, function(e, f) {
    R(d2, f, e);
  });
  b = a.D;
  c = a.sa;
  b && c && R(d2, b, c);
  R(d2, "VER", a.ma);
  Kd(a, d2);
  return d2;
}
function nc$1(a, b, c) {
  if (b && !a.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b = c && a.Ba && !a.qa ? new X$1(new pd({ ib: true })) : new X$1(a.qa);
  b.L = a.H;
  return b;
}
function Sd() {
}
function Td() {
  if (y && !(10 <= Number(Ua)))
    throw Error("Environmental error: no available transport.");
}
function Y$1(a, b) {
  C$1.call(this);
  this.g = new Id(b);
  this.l = a;
  this.h = b && b.messageUrlParams || null;
  a = b && b.messageHeaders || null;
  b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.g.s = a;
  a = b && b.initMessageHeaders || null;
  b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
  b && b.ya && (a ? a["X-WebChannel-Client-Profile"] = b.ya : a = { "X-WebChannel-Client-Profile": b.ya });
  this.g.P = a;
  (a = b && b.httpHeadersOverwriteParam) && !sa(a) && (this.g.o = a);
  this.A = b && b.supportsCrossDomainXhr || false;
  this.v = b && b.sendRawJson || false;
  (b = b && b.httpSessionIdParam) && !sa(b) && (this.g.D = b, a = this.h, a !== null && b in a && (a = this.h, b in a && delete a[b]));
  this.j = new Z$1(this);
}
function Ud(a) {
  ac$1.call(this);
  var b = a.__sm__;
  if (b) {
    a: {
      for (const c in b) {
        a = c;
        break a;
      }
      a = void 0;
    }
    if (this.i = a)
      a = this.i, b = b !== null && a in b ? b[a] : void 0;
    this.data = b;
  } else
    this.data = a;
}
function Vd() {
  bc.call(this);
  this.status = 1;
}
function Z$1(a) {
  this.g = a;
}
function x() {
  return N.logLevel;
}
function $(t2, ...e) {
  if (N.logLevel <= LogLevel.DEBUG) {
    const n = e.map(M);
    N.debug(`Firestore (${C}): ${t2}`, ...n);
  }
}
function O(t2, ...e) {
  if (N.logLevel <= LogLevel.ERROR) {
    const n = e.map(M);
    N.error(`Firestore (${C}): ${t2}`, ...n);
  }
}
function F(t2, ...e) {
  if (N.logLevel <= LogLevel.WARN) {
    const n = e.map(M);
    N.warn(`Firestore (${C}): ${t2}`, ...n);
  }
}
function M(t2) {
  if (typeof t2 == "string")
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  var e;
}
function L(t2 = "Unexpected state") {
  const e = `FIRESTORE (${C}) INTERNAL ASSERTION FAILED: ` + t2;
  throw O(e), new Error(e);
}
function B(t2, e) {
  t2 || L();
}
function q(t2, e) {
  return t2;
}
function Z(t2) {
  const e = typeof self != "undefined" && (self.crypto || self.msCrypto), n = new Uint8Array(t2);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
function et(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function nt(t2, e, n) {
  return t2.length === e.length && t2.every((t3, s2) => n(t3, e[s2]));
}
function ot(t2) {
  let e = 0;
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e++;
  return e;
}
function ct(t2, e) {
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e(n, t2[n]);
}
function at(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
function gt(t2) {
  if (B(!!t2), typeof t2 == "string") {
    let e = 0;
    const n = mt.exec(t2);
    if (B(!!n), n[1]) {
      let t3 = n[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s2 = new Date(t2);
    return {
      seconds: Math.floor(s2.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: yt(t2.seconds),
    nanos: yt(t2.nanos)
  };
}
function yt(t2) {
  return typeof t2 == "number" ? t2 : typeof t2 == "string" ? Number(t2) : 0;
}
function pt(t2) {
  return typeof t2 == "string" ? _t.fromBase64String(t2) : _t.fromUint8Array(t2);
}
function Tt(t2) {
  var e, n;
  return ((n = (((e = t2 == null ? void 0 : t2.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp";
}
function Et(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return Tt(e) ? Et(e) : e;
}
function It(t2) {
  const e = gt(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new it(e.seconds, e.nanos);
}
function At(t2) {
  return t2 == null;
}
function Rt(t2) {
  return t2 === 0 && 1 / t2 == -1 / 0;
}
function bt(t2) {
  return typeof t2 == "number" && Number.isInteger(t2) && !Rt(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
function vt(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? Tt(t2) ? 4 : 10 : L();
}
function Vt(t2, e) {
  const n = vt(t2);
  if (n !== vt(e))
    return false;
  switch (n) {
    case 0:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return It(t2).isEqual(It(e));
    case 3:
      return function(t3, e2) {
        if (typeof t3.timestampValue == "string" && typeof e2.timestampValue == "string" && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n2 = gt(t3.timestampValue), s2 = gt(e2.timestampValue);
        return n2.seconds === s2.seconds && n2.nanos === s2.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return pt(t3.bytesValue).isEqual(pt(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return yt(t3.geoPointValue.latitude) === yt(e2.geoPointValue.latitude) && yt(t3.geoPointValue.longitude) === yt(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return yt(t3.integerValue) === yt(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n2 = yt(t3.doubleValue), s2 = yt(e2.doubleValue);
          return n2 === s2 ? Rt(n2) === Rt(s2) : isNaN(n2) && isNaN(s2);
        }
        return false;
      }(t2, e);
    case 9:
      return nt(t2.arrayValue.values || [], e.arrayValue.values || [], Vt);
    case 10:
      return function(t3, e2) {
        const n2 = t3.mapValue.fields || {}, s2 = e2.mapValue.fields || {};
        if (ot(n2) !== ot(s2))
          return false;
        for (const t4 in n2)
          if (n2.hasOwnProperty(t4) && (s2[t4] === void 0 || !Vt(n2[t4], s2[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return L();
  }
}
function St(t2, e) {
  return (t2.values || []).find((t3) => Vt(t3, e)) !== void 0;
}
function Dt(t2, e) {
  const n = vt(t2), s2 = vt(e);
  if (n !== s2)
    return et(n, s2);
  switch (n) {
    case 0:
      return 0;
    case 1:
      return et(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n2 = yt(t3.integerValue || t3.doubleValue), s22 = yt(e2.integerValue || e2.doubleValue);
        return n2 < s22 ? -1 : n2 > s22 ? 1 : n2 === s22 ? 0 : isNaN(n2) ? isNaN(s22) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return Ct(t2.timestampValue, e.timestampValue);
    case 4:
      return Ct(It(t2), It(e));
    case 5:
      return et(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n2 = pt(t3), s22 = pt(e2);
        return n2.compareTo(s22);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n2 = t3.split("/"), s22 = e2.split("/");
        for (let t4 = 0; t4 < n2.length && t4 < s22.length; t4++) {
          const e3 = et(n2[t4], s22[t4]);
          if (e3 !== 0)
            return e3;
        }
        return et(n2.length, s22.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n2 = et(yt(t3.latitude), yt(e2.latitude));
        if (n2 !== 0)
          return n2;
        return et(yt(t3.longitude), yt(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n2 = t3.values || [], s22 = e2.values || [];
        for (let t4 = 0; t4 < n2.length && t4 < s22.length; ++t4) {
          const e3 = Dt(n2[t4], s22[t4]);
          if (e3)
            return e3;
        }
        return et(n2.length, s22.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        const n2 = t3.fields || {}, s22 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s22.sort(), r.sort();
        for (let t4 = 0; t4 < s22.length && t4 < r.length; ++t4) {
          const e3 = et(s22[t4], r[t4]);
          if (e3 !== 0)
            return e3;
          const o = Dt(n2[s22[t4]], i[r[t4]]);
          if (o !== 0)
            return o;
        }
        return et(s22.length, r.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw L();
  }
}
function Ct(t2, e) {
  if (typeof t2 == "string" && typeof e == "string" && t2.length === e.length)
    return et(t2, e);
  const n = gt(t2), s2 = gt(e), i = et(n.seconds, s2.seconds);
  return i !== 0 ? i : et(n.nanos, s2.nanos);
}
function Nt(t2) {
  return xt(t2);
}
function xt(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = gt(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? pt(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n = t2.referenceValue, Pt.fromName(n).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n2 = true;
    for (const s2 of t3.values || [])
      n2 ? n2 = false : e2 += ",", e2 += xt(s2);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n2 = "{", s2 = true;
    for (const i of e2)
      s2 ? s2 = false : n2 += ",", n2 += `${i}:${xt(t3.fields[i])}`;
    return n2 + "}";
  }(t2.mapValue) : L();
  var e, n;
}
function $t(t2) {
  return !!t2 && "integerValue" in t2;
}
function Ot(t2) {
  return !!t2 && "arrayValue" in t2;
}
function Ft(t2) {
  return !!t2 && "nullValue" in t2;
}
function Mt(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function Lt(t2) {
  return !!t2 && "mapValue" in t2;
}
function Bt(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && typeof t2.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return ct(t2.mapValue.fields, (t3, n) => e.mapValue.fields[t3] = Bt(n)), e;
  }
  if (t2.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t2.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = Bt(t2.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t2);
}
function qt(t2) {
  const e = [];
  return ct(t2.fields, (t3, n) => {
    const s2 = new ft([t3]);
    if (Lt(n)) {
      const t4 = qt(n.mapValue).fields;
      if (t4.length === 0)
        e.push(s2);
      else
        for (const n2 of t4)
          e.push(s2.child(n2));
    } else
      e.push(s2);
  }), new dt(e);
}
function Qt(t2, e = null, n = [], s2 = [], i = null, r = null, o = null) {
  return new jt(t2, e, n, s2, i, r, o);
}
function Wt(t2) {
  const e = q(t2);
  if (e.A === null) {
    let t3 = e.path.canonicalString();
    e.collectionGroup !== null && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => Yt(t4)).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), At(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += ce(e.startAt)), e.endAt && (t3 += "|ub:", t3 += ce(e.endAt)), e.A = t3;
  }
  return e.A;
}
function Gt(t2) {
  let e = t2.path.canonicalString();
  return t2.collectionGroup !== null && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += `, filters: [${t2.filters.map((t3) => {
    return `${(e2 = t3).field.canonicalString()} ${e2.op} ${Nt(e2.value)}`;
    var e2;
  }).join(", ")}]`), At(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e += ", startAt: " + ce(t2.startAt)), t2.endAt && (e += ", endAt: " + ce(t2.endAt)), `Target(${e})`;
}
function zt(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n2 = 0; n2 < t2.orderBy.length; n2++)
    if (!ue(t2.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t2.filters.length; i++)
    if (n = t2.filters[i], s2 = e.filters[i], n.op !== s2.op || !n.field.isEqual(s2.field) || !Vt(n.value, s2.value))
      return false;
  var n, s2;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!le(t2.startAt, e.startAt) && le(t2.endAt, e.endAt)));
}
function Ht(t2) {
  return Pt.isDocumentKey(t2.path) && t2.collectionGroup === null && t2.filters.length === 0;
}
function Yt(t2) {
  return t2.field.canonicalString() + t2.op.toString() + Nt(t2.value);
}
function ee(t2, e) {
  var n;
  return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((t3) => Pt.fromName(t3.referenceValue));
}
function ce(t2) {
  return `${t2.before ? "b" : "a"}:${t2.position.map((t3) => Nt(t3)).join(",")}`;
}
function ue(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
function he(t2, e, n) {
  let s2 = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r = e[i], o = t2.position[i];
    if (r.field.isKeyField())
      s2 = Pt.comparator(Pt.fromName(o.referenceValue), n.key);
    else {
      s2 = Dt(o, n.data.field(r.field));
    }
    if (r.dir === "desc" && (s2 *= -1), s2 !== 0)
      break;
  }
  return t2.before ? s2 <= 0 : s2 < 0;
}
function le(t2, e) {
  if (t2 === null)
    return e === null;
  if (e === null)
    return false;
  if (t2.before !== e.before || t2.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t2.position.length; n++) {
    if (!Vt(t2.position[n], e.position[n]))
      return false;
  }
  return true;
}
function de(t2, e, n, s2, i, r, o, c) {
  return new fe(t2, e, n, s2, i, r, o, c);
}
function we(t2) {
  return new fe(t2);
}
function _e(t2) {
  return !At(t2.limit) && t2.limitType === "F";
}
function me(t2) {
  return !At(t2.limit) && t2.limitType === "L";
}
function ge(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function ye(t2) {
  for (const e of t2.filters)
    if (e.v())
      return e.field;
  return null;
}
function pe(t2) {
  return t2.collectionGroup !== null;
}
function Te(t2) {
  const e = q(t2);
  if (e.V === null) {
    e.V = [];
    const t3 = ye(e), n = ge(e);
    if (t3 !== null && n === null)
      t3.isKeyField() || e.V.push(new ae(t3)), e.V.push(new ae(ft.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n2 of e.explicitOrderBy)
        e.V.push(n2), n2.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.V.push(new ae(ft.keyField(), t5));
      }
    }
  }
  return e.V;
}
function Ee(t2) {
  const e = q(t2);
  if (!e.S)
    if (e.limitType === "F")
      e.S = Qt(e.path, e.collectionGroup, Te(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n2 of Te(e)) {
        const e2 = n2.dir === "desc" ? "asc" : "desc";
        t3.push(new ae(n2.field, e2));
      }
      const n = e.endAt ? new oe(e.endAt.position, !e.endAt.before) : null, s2 = e.startAt ? new oe(e.startAt.position, !e.startAt.before) : null;
      e.S = Qt(e.path, e.collectionGroup, t3, e.filters, e.limit, n, s2);
    }
  return e.S;
}
function Ie(t2, e, n) {
  return new fe(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
}
function Ae(t2, e) {
  return zt(Ee(t2), Ee(e)) && t2.limitType === e.limitType;
}
function Re(t2) {
  return `${Wt(Ee(t2))}|lt:${t2.limitType}`;
}
function be(t2) {
  return `Query(target=${Gt(Ee(t2))}; limitType=${t2.limitType})`;
}
function Pe(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n = e2.key.path;
    return t3.collectionGroup !== null ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n) : Pt.isDocumentKey(t3.path) ? t3.path.isEqual(n) : t3.path.isImmediateParentOf(n);
  }(t2, e) && function(t3, e2) {
    for (const n of t3.explicitOrderBy)
      if (!n.field.isKeyField() && e2.data.field(n.field) === null)
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n of t3.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !he(t3.startAt, Te(t3), e2))
      return false;
    if (t3.endAt && he(t3.endAt, Te(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function ve(t2) {
  return (e, n) => {
    let s2 = false;
    for (const i of Te(t2)) {
      const t3 = Ve(i, e, n);
      if (t3 !== 0)
        return t3;
      s2 = s2 || i.field.isKeyField();
    }
    return 0;
  };
}
function Ve(t2, e, n) {
  const s2 = t2.field.isKeyField() ? Pt.comparator(e.key, n.key) : function(t3, e2, n2) {
    const s22 = e2.data.field(t3), i = n2.data.field(t3);
    return s22 !== null && i !== null ? Dt(s22, i) : L();
  }(t2.field, e, n);
  switch (t2.dir) {
    case "asc":
      return s2;
    case "desc":
      return -1 * s2;
    default:
      return L();
  }
}
function Se(t2, e) {
  if (t2.D) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: Rt(e) ? "-0" : e
  };
}
function De(t2) {
  return {
    integerValue: "" + t2
  };
}
function Ce(t2, e) {
  return bt(e) ? De(e) : Se(t2, e);
}
function xe(t2, e, n) {
  return t2 instanceof Oe ? function(t3, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t2 instanceof Fe ? Me(t2, e) : t2 instanceof Le ? Be(t2, e) : function(t3, e2) {
    const n2 = $e(t3, e2), s2 = qe(n2) + qe(t3.C);
    return $t(n2) && $t(t3.C) ? De(s2) : Se(t3.N, s2);
  }(t2, e);
}
function ke(t2, e, n) {
  return t2 instanceof Fe ? Me(t2, e) : t2 instanceof Le ? Be(t2, e) : n;
}
function $e(t2, e) {
  return t2 instanceof Ue ? $t(n = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
function Me(t2, e) {
  const n = Ke(e);
  for (const e2 of t2.elements)
    n.some((t3) => Vt(t3, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
function Be(t2, e) {
  let n = Ke(e);
  for (const e2 of t2.elements)
    n = n.filter((t3) => !Vt(t3, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
function qe(t2) {
  return yt(t2.integerValue || t2.doubleValue);
}
function Ke(t2) {
  return Ot(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
function Qe(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof Fe && e2 instanceof Fe || t3 instanceof Le && e2 instanceof Le ? nt(t3.elements, e2.elements, Vt) : t3 instanceof Ue && e2 instanceof Ue ? Vt(t3.C, e2.C) : t3 instanceof Oe && e2 instanceof Oe;
  }(t2.transform, e.transform);
}
function ze(t2, e) {
  return t2.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : t2.exists === void 0 || t2.exists === e.isFoundDocument();
}
function Je(t2, e, n) {
  t2 instanceof en ? function(t3, e2, n2) {
    const s2 = t3.value.clone(), i = rn(t3.fieldTransforms, e2, n2.transformResults);
    s2.setAll(i), e2.convertToFoundDocument(n2.version, s2).setHasCommittedMutations();
  }(t2, e, n) : t2 instanceof nn ? function(t3, e2, n2) {
    if (!ze(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s2 = rn(t3.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(sn(t3)), i.setAll(s2), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t2, e, n) : function(t3, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function Ye(t2, e, n) {
  t2 instanceof en ? function(t3, e2, n2) {
    if (!ze(t3.precondition, e2))
      return;
    const s2 = t3.value.clone(), i = on(t3.fieldTransforms, n2, e2);
    s2.setAll(i), e2.convertToFoundDocument(tn(e2), s2).setHasLocalMutations();
  }(t2, e, n) : t2 instanceof nn ? function(t3, e2, n2) {
    if (!ze(t3.precondition, e2))
      return;
    const s2 = on(t3.fieldTransforms, n2, e2), i = e2.data;
    i.setAll(sn(t3)), i.setAll(s2), e2.convertToFoundDocument(tn(e2), i).setHasLocalMutations();
  }(t2, e, n) : function(t3, e2) {
    ze(t3.precondition, e2) && e2.convertToNoDocument(rt.min());
  }(t2, e);
}
function Xe(t2, e) {
  let n = null;
  for (const s2 of t2.fieldTransforms) {
    const t3 = e.data.field(s2.field), i = $e(s2.transform, t3 || null);
    i != null && (n == null && (n = Ut.empty()), n.set(s2.field, i));
  }
  return n || null;
}
function Ze(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return t3 === void 0 && e2 === void 0 || !(!t3 || !e2) && nt(t3, e2, (t4, e3) => Qe(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (t2.type === 0 ? t2.value.isEqual(e.value) : t2.type !== 1 || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
function tn(t2) {
  return t2.isFoundDocument() ? t2.version : rt.min();
}
function sn(t2) {
  const e = new Map();
  return t2.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s2 = t2.data.field(n);
      e.set(n, s2);
    }
  }), e;
}
function rn(t2, e, n) {
  const s2 = new Map();
  B(t2.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t2[i], o = r.transform, c = e.data.field(r.field);
    s2.set(r.field, ke(o, c, n[i]));
  }
  return s2;
}
function on(t2, e, n) {
  const s2 = new Map();
  for (const i of t2) {
    const t3 = i.transform, r = n.data.field(i.field);
    s2.set(i.field, xe(t3, r, e));
  }
  return s2;
}
function fn(t2) {
  switch (t2) {
    default:
      return L();
    case K.CANCELLED:
    case K.UNKNOWN:
    case K.DEADLINE_EXCEEDED:
    case K.RESOURCE_EXHAUSTED:
    case K.INTERNAL:
    case K.UNAVAILABLE:
    case K.UNAUTHENTICATED:
      return false;
    case K.INVALID_ARGUMENT:
    case K.NOT_FOUND:
    case K.ALREADY_EXISTS:
    case K.PERMISSION_DENIED:
    case K.FAILED_PRECONDITION:
    case K.ABORTED:
    case K.OUT_OF_RANGE:
    case K.UNIMPLEMENTED:
    case K.DATA_LOSS:
      return true;
  }
}
function dn(t2) {
  if (t2 === void 0)
    return O("GRPC error has no .code"), K.UNKNOWN;
  switch (t2) {
    case hn.OK:
      return K.OK;
    case hn.CANCELLED:
      return K.CANCELLED;
    case hn.UNKNOWN:
      return K.UNKNOWN;
    case hn.DEADLINE_EXCEEDED:
      return K.DEADLINE_EXCEEDED;
    case hn.RESOURCE_EXHAUSTED:
      return K.RESOURCE_EXHAUSTED;
    case hn.INTERNAL:
      return K.INTERNAL;
    case hn.UNAVAILABLE:
      return K.UNAVAILABLE;
    case hn.UNAUTHENTICATED:
      return K.UNAUTHENTICATED;
    case hn.INVALID_ARGUMENT:
      return K.INVALID_ARGUMENT;
    case hn.NOT_FOUND:
      return K.NOT_FOUND;
    case hn.ALREADY_EXISTS:
      return K.ALREADY_EXISTS;
    case hn.PERMISSION_DENIED:
      return K.PERMISSION_DENIED;
    case hn.FAILED_PRECONDITION:
      return K.FAILED_PRECONDITION;
    case hn.ABORTED:
      return K.ABORTED;
    case hn.OUT_OF_RANGE:
      return K.OUT_OF_RANGE;
    case hn.UNIMPLEMENTED:
      return K.UNIMPLEMENTED;
    case hn.DATA_LOSS:
      return K.DATA_LOSS;
    default:
      return L();
  }
}
function Tn() {
  return pn;
}
function In() {
  return En;
}
function Rn() {
  return An;
}
function Pn(...t2) {
  let e = bn;
  for (const n of t2)
    e = e.add(n);
  return e;
}
function Vn() {
  return vn;
}
function On() {
  return new wn(Pt.comparator);
}
function Fn() {
  return new wn(Pt.comparator);
}
function Un(t2, e) {
  if (t2.D) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function qn(t2, e) {
  return t2.D ? e.toBase64() : e.toUint8Array();
}
function Kn(t2, e) {
  return Un(t2, e.toTimestamp());
}
function jn(t2) {
  return B(!!t2), rt.fromTimestamp(function(t3) {
    const e = gt(t3);
    return new it(e.seconds, e.nanos);
  }(t2));
}
function Qn(t2, e) {
  return function(t3) {
    return new ht(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function Wn(t2) {
  const e = ht.fromString(t2);
  return B(Ts(e)), e;
}
function Gn(t2, e) {
  return Qn(t2.databaseId, e.path);
}
function zn(t2, e) {
  const n = Wn(e);
  if (n.get(1) !== t2.databaseId.projectId)
    throw new j(K.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t2.databaseId.projectId);
  if (n.get(3) !== t2.databaseId.database)
    throw new j(K.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t2.databaseId.database);
  return new Pt(Xn(n));
}
function Hn(t2, e) {
  return Qn(t2.databaseId, e);
}
function Jn(t2) {
  const e = Wn(t2);
  return e.length === 4 ? ht.emptyPath() : Xn(e);
}
function Yn(t2) {
  return new ht(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function Xn(t2) {
  return B(t2.length > 4 && t2.get(4) === "documents"), t2.popFirst(5);
}
function Zn(t2, e, n) {
  return {
    name: Gn(t2, e),
    fields: n.value.mapValue.fields
  };
}
function ns(t2, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s2 = function(t3) {
      return t3 === "NO_CHANGE" ? 0 : t3 === "ADD" ? 1 : t3 === "REMOVE" ? 2 : t3 === "CURRENT" ? 3 : t3 === "RESET" ? 4 : L();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t3, e2) {
      return t3.D ? (B(e2 === void 0 || typeof e2 == "string"), _t.fromBase64String(e2 || "")) : (B(e2 === void 0 || e2 instanceof Uint8Array), _t.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, c = o && function(t3) {
      const e2 = t3.code === void 0 ? K.UNKNOWN : dn(t3.code);
      return new j(e2, t3.message || "");
    }(o);
    n = new xn(s2, i, r, c || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s2 = e.documentChange;
    s2.document, s2.document.name, s2.document.updateTime;
    const i = zn(t2, s2.document.name), r = jn(s2.document.updateTime), o = new Ut({
      mapValue: {
        fields: s2.document.fields
      }
    }), c = Kt.newFoundDocument(i, r, o), a = s2.targetIds || [], u = s2.removedTargetIds || [];
    n = new Cn(a, u, c.key, c);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s2 = e.documentDelete;
    s2.document;
    const i = zn(t2, s2.document), r = s2.readTime ? jn(s2.readTime) : rt.min(), o = Kt.newNoDocument(i, r), c = s2.removedTargetIds || [];
    n = new Cn([], c, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s2 = e.documentRemove;
    s2.document;
    const i = zn(t2, s2.document), r = s2.removedTargetIds || [];
    n = new Cn([], r, i, null);
  } else {
    if (!("filter" in e))
      return L();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s2 = t3.count || 0, i = new un(s2), r = t3.targetId;
      n = new Nn(r, i);
    }
  }
  return n;
}
function ss(t2, e) {
  let n;
  if (e instanceof en)
    n = {
      update: Zn(t2, e.key, e.value)
    };
  else if (e instanceof cn)
    n = {
      delete: Gn(t2, e.key)
    };
  else if (e instanceof nn)
    n = {
      update: Zn(t2, e.key, e.data),
      updateMask: ps(e.fieldMask)
    };
  else {
    if (!(e instanceof an))
      return L();
    n = {
      verify: Gn(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n2 = e2.transform;
    if (n2 instanceof Oe)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof Fe)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof Le)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof Ue)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2.C
      };
    throw L();
  }(0, t3))), e.precondition.isNone || (n.currentDocument = function(t3, e2) {
    return e2.updateTime !== void 0 ? {
      updateTime: Kn(t3, e2.updateTime)
    } : e2.exists !== void 0 ? {
      exists: e2.exists
    } : L();
  }(t2, e.precondition)), n;
}
function rs(t2, e) {
  return t2 && t2.length > 0 ? (B(e !== void 0), t2.map((t3) => function(t4, e2) {
    let n = t4.updateTime ? jn(t4.updateTime) : jn(e2);
    return n.isEqual(rt.min()) && (n = jn(e2)), new We(n, t4.transformResults || []);
  }(t3, e))) : [];
}
function os(t2, e) {
  return {
    documents: [Hn(t2, e.path)]
  };
}
function cs(t2, e) {
  const n = {
    structuredQuery: {}
  }, s2 = e.path;
  e.collectionGroup !== null ? (n.parent = Hn(t2, s2), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = Hn(t2, s2.popLast()), n.structuredQuery.from = [{
    collectionId: s2.lastSegment()
  }]);
  const i = function(t3) {
    if (t3.length === 0)
      return;
    const e2 = t3.map((t4) => function(t5) {
      if (t5.op === "==") {
        if (Mt(t5.value))
          return {
            unaryFilter: {
              field: _s(t5.field),
              op: "IS_NAN"
            }
          };
        if (Ft(t5.value))
          return {
            unaryFilter: {
              field: _s(t5.field),
              op: "IS_NULL"
            }
          };
      } else if (t5.op === "!=") {
        if (Mt(t5.value))
          return {
            unaryFilter: {
              field: _s(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Ft(t5.value))
          return {
            unaryFilter: {
              field: _s(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: _s(t5.field),
          op: ws(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (e2.length === 1)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t3) {
    if (t3.length === 0)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: _s(t5.field),
        direction: ds(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t3, e2) {
    return t3.D || At(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  return o !== null && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = ls(e.startAt)), e.endAt && (n.structuredQuery.endAt = ls(e.endAt)), n;
}
function as(t2) {
  let e = Jn(t2.parent);
  const n = t2.structuredQuery, s2 = n.from ? n.from.length : 0;
  let i = null;
  if (s2 > 0) {
    B(s2 === 1);
    const t3 = n.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r = [];
  n.where && (r = hs(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t3) => function(t4) {
    return new ae(ms(t4.field), function(t5) {
      switch (t5) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return;
      }
    }(t4.direction));
  }(t3)));
  let c = null;
  n.limit && (c = function(t3) {
    let e2;
    return e2 = typeof t3 == "object" ? t3.value : t3, At(e2) ? null : e2;
  }(n.limit));
  let a = null;
  n.startAt && (a = fs(n.startAt));
  let u = null;
  return n.endAt && (u = fs(n.endAt)), de(e, i, o, r, c, "F", a, u);
}
function us(t2, e) {
  const n = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return L();
    }
  }(0, e.purpose);
  return n == null ? null : {
    "goog-listen-tags": n
  };
}
function hs(t2) {
  return t2 ? t2.unaryFilter !== void 0 ? [ys(t2)] : t2.fieldFilter !== void 0 ? [gs(t2)] : t2.compositeFilter !== void 0 ? t2.compositeFilter.filters.map((t3) => hs(t3)).reduce((t3, e) => t3.concat(e)) : L() : [];
}
function ls(t2) {
  return {
    before: t2.before,
    values: t2.position
  };
}
function fs(t2) {
  const e = !!t2.before, n = t2.values || [];
  return new oe(n, e);
}
function ds(t2) {
  return Mn[t2];
}
function ws(t2) {
  return Ln[t2];
}
function _s(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function ms(t2) {
  return ft.fromServerFormat(t2.fieldPath);
}
function gs(t2) {
  return Jt.create(ms(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      default:
        return L();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function ys(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e = ms(t2.unaryFilter.field);
      return Jt.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n = ms(t2.unaryFilter.field);
      return Jt.create(n, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s2 = ms(t2.unaryFilter.field);
      return Jt.create(s2, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = ms(t2.unaryFilter.field);
      return Jt.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    default:
      return L();
  }
}
function ps(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function Ts(t2) {
  return t2.length >= 4 && t2.get(0) === "projects" && t2.get(2) === "databases";
}
function Hs(t2) {
  return t2.name === "IndexedDbTransactionError";
}
function _i(t2) {
  const e = as({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return t2.limitType === "LAST" ? Ie(e, e.limit, "L") : e;
}
async function Fi(t2) {
  if (t2.code !== K.FAILED_PRECONDITION || t2.message !== qs)
    throw t2;
  $("LocalStore", "Unexpectedly lost primary lease");
}
function ur(t2, e, n, s2) {
  return new ar(t2, e, n, s2);
}
async function hr(t2, e) {
  const n = q(t2);
  let s2 = n.In, i = n.Qn;
  const r = await n.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let r2;
    return n.In.getAllMutationBatches(t3).next((o) => (r2 = o, s2 = n.persistence.getMutationQueue(e), i = new rr(n.jn, s2, n.persistence.getIndexManager()), s2.getAllMutationBatches(t3))).next((e2) => {
      const n2 = [], s22 = [];
      let o = Pn();
      for (const t4 of r2) {
        n2.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        s22.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return i.Pn(t3, o).next((t4) => ({
        Wn: t4,
        removedBatchIds: n2,
        addedBatchIds: s22
      }));
    });
  });
  return n.In = s2, n.Qn = i, n.Bn.$n(n.Qn), r;
}
function lr(t2, e) {
  const n = q(t2);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s2 = e.batch.keys(), i = n.jn.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n2, s22) {
      const i2 = n2.batch, r = i2.keys();
      let o = js.resolve();
      return r.forEach((t5) => {
        o = o.next(() => s22.getEntry(e2, t5)).next((e3) => {
          const r2 = n2.docVersions.get(t5);
          B(r2 !== null), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && s22.addEntry(e3, n2.commitVersion));
        });
      }), o.next(() => t4.In.removeMutationBatch(e2, i2));
    }(n, t3, e, i).next(() => i.apply(t3)).next(() => n.In.performConsistencyCheck(t3)).next(() => n.Qn.Pn(t3, s2));
  });
}
function fr(t2) {
  const e = q(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.ze.getLastRemoteSnapshotVersion(t3));
}
function dr(t2, e) {
  const n = q(t2), s2 = e.snapshotVersion;
  let i = n.Un;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r = n.jn.newChangeBuffer({
      trackRemovals: true
    });
    i = n.Un;
    const o = [];
    e.targetChanges.forEach((e2, r2) => {
      const c2 = i.get(r2);
      if (!c2)
        return;
      o.push(n.ze.removeMatchingKeys(t3, e2.removedDocuments, r2).next(() => n.ze.addMatchingKeys(t3, e2.addedDocuments, r2)));
      const a = e2.resumeToken;
      if (a.approximateByteSize() > 0) {
        const u = c2.withResumeToken(a, s2).withSequenceNumber(t3.currentSequenceNumber);
        i = i.insert(r2, u), function(t4, e3, n2) {
          if (B(e3.resumeToken.approximateByteSize() > 0), t4.resumeToken.approximateByteSize() === 0)
            return true;
          if (e3.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
            return true;
          return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
        }(c2, u, e2) && o.push(n.ze.updateTargetData(t3, u));
      }
    });
    let c = Tn();
    if (e.documentUpdates.forEach((s22, i2) => {
      e.resolvedLimboDocuments.has(s22) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t3, s22));
    }), o.push(wr(t3, r, e.documentUpdates, s2, void 0).next((t4) => {
      c = t4;
    })), !s2.isEqual(rt.min())) {
      const e2 = n.ze.getLastRemoteSnapshotVersion(t3).next((e3) => n.ze.setTargetsMetadata(t3, t3.currentSequenceNumber, s2));
      o.push(e2);
    }
    return js.waitFor(o).next(() => r.apply(t3)).next(() => n.Qn.vn(t3, c)).next(() => c);
  }).then((t3) => (n.Un = i, t3));
}
function wr(t2, e, n, s2, i) {
  let r = Pn();
  return n.forEach((t3) => r = r.add(t3)), e.getEntries(t2, r).next((t3) => {
    let r2 = Tn();
    return n.forEach((n2, o) => {
      const c = t3.get(n2), a = (i == null ? void 0 : i.get(n2)) || s2;
      o.isNoDocument() && o.version.isEqual(rt.min()) ? (e.removeEntry(n2, a), r2 = r2.insert(n2, o)) : !c.isValidDocument() || o.version.compareTo(c.version) > 0 || o.version.compareTo(c.version) === 0 && c.hasPendingWrites ? (e.addEntry(o, a), r2 = r2.insert(n2, o)) : $("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", c.version, " Watch version:", o.version);
    }), r2;
  });
}
function _r(t2, e) {
  const n = q(t2);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (e === void 0 && (e = -1), n.In.getNextMutationBatchAfterBatchId(t3, e)));
}
function mr(t2, e) {
  const n = q(t2);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s2;
    return n.ze.getTargetData(t3, e).next((i) => i ? (s2 = i, js.resolve(s2)) : n.ze.allocateTargetId(t3).next((i2) => (s2 = new ii(e, i2, 0, t3.currentSequenceNumber), n.ze.addTargetData(t3, s2).next(() => s2))));
  }).then((t3) => {
    const s2 = n.Un.get(t3.targetId);
    return (s2 === null || t3.snapshotVersion.compareTo(s2.snapshotVersion) > 0) && (n.Un = n.Un.insert(t3.targetId, t3), n.qn.set(e, t3.targetId)), t3;
  });
}
async function gr(t2, e, n) {
  const s2 = q(t2), i = s2.Un.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s2.persistence.runTransaction("Release target", r, (t3) => s2.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!Hs(t3))
      throw t3;
    $("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s2.Un = s2.Un.remove(e), s2.qn.delete(i.target);
}
function yr(t2, e, n) {
  const s2 = q(t2);
  let i = rt.min(), r = Pn();
  return s2.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n2) {
    const s22 = q(t4), i2 = s22.qn.get(n2);
    return i2 !== void 0 ? js.resolve(s22.Un.get(i2)) : s22.ze.getTargetData(e2, n2);
  }(s2, t3, Ee(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s2.ze.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r = t4;
      });
  }).next(() => s2.Bn.getDocumentsMatchingQuery(t3, e, n ? i : rt.min(), n ? r : Pn())).next((t4) => ({
    documents: t4,
    Gn: r
  })));
}
function Jr() {
  return typeof document != "undefined" ? document : null;
}
function Yr(t2) {
  return new Bn(t2, true);
}
async function ro(t2) {
  if (wo(t2))
    for (const e of t2.Gr)
      await e(true);
}
async function oo(t2) {
  for (const e of t2.Gr)
    await e(false);
}
function co(t2, e) {
  const n = q(t2);
  n.Qr.has(e.targetId) || (n.Qr.set(e.targetId, e), fo(n) ? lo(n) : Co(n).hr() && uo(n, e));
}
function ao(t2, e) {
  const n = q(t2), s2 = Co(n);
  n.Qr.delete(e), s2.hr() && ho(n, e), n.Qr.size === 0 && (s2.hr() ? s2.wr() : wo(n) && n.Hr.set("Unknown"));
}
function uo(t2, e) {
  t2.Jr.Y(e.targetId), Co(t2).br(e);
}
function ho(t2, e) {
  t2.Jr.Y(e), Co(t2).Pr(e);
}
function lo(t2) {
  t2.Jr = new $n({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    Tt: (e) => t2.Qr.get(e) || null
  }), Co(t2).start(), t2.Hr.Lr();
}
function fo(t2) {
  return wo(t2) && !Co(t2).ur() && t2.Qr.size > 0;
}
function wo(t2) {
  return q(t2).Wr.size === 0;
}
function _o(t2) {
  t2.Jr = void 0;
}
async function mo(t2) {
  t2.Qr.forEach((e, n) => {
    uo(t2, e);
  });
}
async function go(t2, e) {
  _o(t2), fo(t2) ? (t2.Hr.qr(e), lo(t2)) : t2.Hr.set("Unknown");
}
async function yo(t2, e, n) {
  if (t2.Hr.set("Online"), e instanceof xn && e.state === 2 && e.cause)
    try {
      await async function(t3, e2) {
        const n2 = e2.cause;
        for (const s2 of e2.targetIds)
          t3.Qr.has(s2) && (await t3.remoteSyncer.rejectListen(s2, n2), t3.Qr.delete(s2), t3.Jr.removeTarget(s2));
      }(t2, e);
    } catch (n2) {
      $("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await po(t2, n2);
    }
  else if (e instanceof Cn ? t2.Jr.rt(e) : e instanceof Nn ? t2.Jr.ft(e) : t2.Jr.at(e), !n.isEqual(rt.min()))
    try {
      const e2 = await fr(t2.localStore);
      n.compareTo(e2) >= 0 && await function(t3, e3) {
        const n2 = t3.Jr._t(e3);
        return n2.targetChanges.forEach((n3, s2) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t3.Qr.get(s2);
            i && t3.Qr.set(s2, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t3.Qr.get(e4);
          if (!n3)
            return;
          t3.Qr.set(e4, n3.withResumeToken(_t.EMPTY_BYTE_STRING, n3.snapshotVersion)), ho(t3, e4);
          const s2 = new ii(n3.target, e4, 1, n3.sequenceNumber);
          uo(t3, s2);
        }), t3.remoteSyncer.applyRemoteEvent(n2);
      }(t2, n);
    } catch (e2) {
      $("RemoteStore", "Failed to raise snapshot:", e2), await po(t2, e2);
    }
}
async function po(t2, e, n) {
  if (!Hs(e))
    throw e;
  t2.Wr.add(1), await oo(t2), t2.Hr.set("Offline"), n || (n = () => fr(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    $("RemoteStore", "Retrying IndexedDB access"), await n(), t2.Wr.delete(1), await ro(t2);
  });
}
function To(t2, e) {
  return e().catch((n) => po(t2, n, e));
}
async function Eo(t2) {
  const e = q(t2), n = No(e);
  let s2 = e.jr.length > 0 ? e.jr[e.jr.length - 1].batchId : -1;
  for (; Io(e); )
    try {
      const t3 = await _r(e.localStore, s2);
      if (t3 === null) {
        e.jr.length === 0 && n.wr();
        break;
      }
      s2 = t3.batchId, Ao(e, t3);
    } catch (t3) {
      await po(e, t3);
    }
  Ro(e) && bo(e);
}
function Io(t2) {
  return wo(t2) && t2.jr.length < 10;
}
function Ao(t2, e) {
  t2.jr.push(e);
  const n = No(t2);
  n.hr() && n.Vr && n.Sr(e.mutations);
}
function Ro(t2) {
  return wo(t2) && !No(t2).ur() && t2.jr.length > 0;
}
function bo(t2) {
  No(t2).start();
}
async function Po(t2) {
  No(t2).Nr();
}
async function vo(t2) {
  const e = No(t2);
  for (const n of t2.jr)
    e.Sr(n.mutations);
}
async function Vo(t2, e, n) {
  const s2 = t2.jr.shift(), i = si.from(s2, e, n);
  await To(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await Eo(t2);
}
async function So(t2, e) {
  e && No(t2).Vr && await async function(t3, e2) {
    if (n = e2.code, fn(n) && n !== K.ABORTED) {
      const n2 = t3.jr.shift();
      No(t3).dr(), await To(t3, () => t3.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await Eo(t3);
    }
    var n;
  }(t2, e), Ro(t2) && bo(t2);
}
async function Do(t2, e) {
  const n = q(t2);
  e ? (n.Wr.delete(2), await ro(n)) : e || (n.Wr.add(2), await oo(n), n.Hr.set("Unknown"));
}
function Co(t2) {
  return t2.Yr || (t2.Yr = function(t3, e, n) {
    const s2 = q(t3);
    return s2.$r(), new to(e, s2.sr, s2.credentials, s2.N, n);
  }(t2.datastore, t2.asyncQueue, {
    Si: mo.bind(null, t2),
    Ci: go.bind(null, t2),
    Rr: yo.bind(null, t2)
  }), t2.Gr.push(async (e) => {
    e ? (t2.Yr.dr(), fo(t2) ? lo(t2) : t2.Hr.set("Unknown")) : (await t2.Yr.stop(), _o(t2));
  })), t2.Yr;
}
function No(t2) {
  return t2.Xr || (t2.Xr = function(t3, e, n) {
    const s2 = q(t3);
    return s2.$r(), new eo(e, s2.sr, s2.credentials, s2.N, n);
  }(t2.datastore, t2.asyncQueue, {
    Si: Po.bind(null, t2),
    Ci: So.bind(null, t2),
    Cr: vo.bind(null, t2),
    Dr: Vo.bind(null, t2)
  }), t2.Gr.push(async (e) => {
    e ? (t2.Xr.dr(), await Eo(t2)) : (await t2.Xr.stop(), t2.jr.length > 0 && ($("RemoteStore", `Stopping write stream with ${t2.jr.length} pending writes`), t2.jr = []));
  })), t2.Xr;
}
function ko(t2, e) {
  if (O("AsyncQueue", `${e}: ${t2}`), Hs(t2))
    return new j(K.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
async function Bo(t2, e) {
  const n = q(t2), s2 = e.query;
  let i = false, r = n.queries.get(s2);
  if (r || (i = true, r = new Mo()), i)
    try {
      r.no = await n.onListen(s2);
    } catch (t3) {
      const n2 = ko(t3, `Initialization of query '${be(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s2, r), r.listeners.push(e), e.io(n.onlineState), r.no) {
    e.ro(r.no) && jo(n);
  }
}
async function Uo(t2, e) {
  const n = q(t2), s2 = e.query;
  let i = false;
  const r = n.queries.get(s2);
  if (r) {
    const t3 = r.listeners.indexOf(e);
    t3 >= 0 && (r.listeners.splice(t3, 1), i = r.listeners.length === 0);
  }
  if (i)
    return n.queries.delete(s2), n.onUnlisten(s2);
}
function qo(t2, e) {
  const n = q(t2);
  let s2 = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.ro(t3) && (s2 = true);
      i.no = t3;
    }
  }
  s2 && jo(n);
}
function Ko(t2, e, n) {
  const s2 = q(t2), i = s2.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n);
  s2.queries.delete(e);
}
function jo(t2) {
  t2.so.forEach((t3) => {
    t3.next();
  });
}
async function nc(t2, e) {
  const n = Cc(t2);
  let s2, i;
  const r = n.Oo.get(e);
  if (r)
    s2 = r.targetId, n.sharedClientState.addLocalQueryTarget(s2), i = r.view.xo();
  else {
    const t3 = await mr(n.localStore, Ee(e)), r2 = n.sharedClientState.addLocalQueryTarget(t3.targetId);
    s2 = t3.targetId, i = await sc(n, e, s2, r2 === "current"), n.isPrimaryClient && co(n.remoteStore, t3);
  }
  return i;
}
async function sc(t2, e, n, s2) {
  t2.Wo = (e2, n2, s22) => async function(t3, e3, n3, s3) {
    let i2 = e3.view.bo(n3);
    i2.Ln && (i2 = await yr(t3.localStore, e3.query, false).then(({ documents: t4 }) => e3.view.bo(t4, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(i2, t3.isPrimaryClient, r2);
    return mc(t3, e3.targetId, o2.Do), o2.snapshot;
  }(t2, e2, n2, s22);
  const i = await yr(t2.localStore, e, true), r = new Xo(e, i.Gn), o = r.bo(i.documents), c = Dn.createSynthesizedTargetChangeForCurrentChange(n, s2 && t2.onlineState !== "Offline"), a = r.applyChanges(o, t2.isPrimaryClient, c);
  mc(t2, n, a.Do);
  const u = new Zo(e, n, r);
  return t2.Oo.set(e, u), t2.Fo.has(n) ? t2.Fo.get(n).push(e) : t2.Fo.set(n, [e]), a.snapshot;
}
async function ic(t2, e) {
  const n = q(t2), s2 = n.Oo.get(e), i = n.Fo.get(s2.targetId);
  if (i.length > 1)
    return n.Fo.set(s2.targetId, i.filter((t3) => !Ae(t3, e))), void n.Oo.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s2.targetId);
    n.sharedClientState.isActiveQueryTarget(s2.targetId) || await gr(n.localStore, s2.targetId, false).then(() => {
      n.sharedClientState.clearQueryState(s2.targetId), ao(n.remoteStore, s2.targetId), wc(n, s2.targetId);
    }).catch(Fi);
  } else
    wc(n, s2.targetId), await gr(n.localStore, s2.targetId, true);
}
async function rc(t2, e, n) {
  const s2 = Nc(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = q(t4), s22 = it.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), Pn());
      let r;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => n2.Qn.Pn(t5, i).next((i2) => {
        r = i2;
        const o = [];
        for (const t6 of e2) {
          const e3 = Xe(t6, r.get(t6.key));
          e3 != null && o.push(new nn(t6.key, e3, qt(e3.value.mapValue), Ge.exists(true)));
        }
        return n2.In.addMutationBatch(t5, s22, o, e2);
      })).then((t5) => (t5.applyToLocalDocumentSet(r), {
        batchId: t5.batchId,
        changes: r
      }));
    }(s2.localStore, e);
    s2.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n2) {
      let s22 = t4.qo[t4.currentUser.toKey()];
      s22 || (s22 = new wn(et));
      s22 = s22.insert(e2, n2), t4.qo[t4.currentUser.toKey()] = s22;
    }(s2, t3.batchId, n), await pc(s2, t3.changes), await Eo(s2.remoteStore);
  } catch (t3) {
    const e2 = ko(t3, "Failed to persist write");
    n.reject(e2);
  }
}
async function oc(t2, e) {
  const n = q(t2);
  try {
    const t3 = await dr(n.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s2 = n.Bo.get(e2);
      s2 && (B(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s2.ko = true : t4.modifiedDocuments.size > 0 ? B(s2.ko) : t4.removedDocuments.size > 0 && (B(s2.ko), s2.ko = false));
    }), await pc(n, t3, e);
  } catch (t3) {
    await Fi(t3);
  }
}
function cc(t2, e, n) {
  const s2 = q(t2);
  if (s2.isPrimaryClient && n === 0 || !s2.isPrimaryClient && n === 1) {
    const t3 = [];
    s2.Oo.forEach((n2, s22) => {
      const i = s22.view.io(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n2 = q(t4);
      n2.onlineState = e2;
      let s22 = false;
      n2.queries.forEach((t5, n3) => {
        for (const t6 of n3.listeners)
          t6.io(e2) && (s22 = true);
      }), s22 && jo(n2);
    }(s2.eventManager, e), t3.length && s2.$o.Rr(t3), s2.onlineState = e, s2.isPrimaryClient && s2.sharedClientState.setOnlineState(e);
  }
}
async function ac(t2, e, n) {
  const s2 = q(t2);
  s2.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s2.Bo.get(e), r = i && i.key;
  if (r) {
    let t3 = new wn(Pt.comparator);
    t3 = t3.insert(r, Kt.newNoDocument(r, rt.min()));
    const n2 = Pn().add(r), i2 = new Sn(rt.min(), new Map(), new gn(et), t3, n2);
    await oc(s2, i2), s2.Lo = s2.Lo.remove(r), s2.Bo.delete(e), yc(s2);
  } else
    await gr(s2.localStore, e, false).then(() => wc(s2, e, n)).catch(Fi);
}
async function uc(t2, e) {
  const n = q(t2), s2 = e.batch.batchId;
  try {
    const t3 = await lr(n.localStore, e);
    dc(n, s2, null), fc(n, s2), n.sharedClientState.updateMutationState(s2, "acknowledged"), await pc(n, t3);
  } catch (t3) {
    await Fi(t3);
  }
}
async function hc(t2, e, n) {
  const s2 = q(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = q(t4);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s22;
        return n2.In.lookupMutationBatch(t5, e2).next((e3) => (B(e3 !== null), s22 = e3.keys(), n2.In.removeMutationBatch(t5, e3))).next(() => n2.In.performConsistencyCheck(t5)).next(() => n2.Qn.Pn(t5, s22));
      });
    }(s2.localStore, e);
    dc(s2, e, n), fc(s2, e), s2.sharedClientState.updateMutationState(e, "rejected", n), await pc(s2, t3);
  } catch (n2) {
    await Fi(n2);
  }
}
function fc(t2, e) {
  (t2.Ko.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.Ko.delete(e);
}
function dc(t2, e, n) {
  const s2 = q(t2);
  let i = s2.qo[s2.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n ? t3.reject(n) : t3.resolve(), i = i.remove(e)), s2.qo[s2.currentUser.toKey()] = i;
  }
}
function wc(t2, e, n = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s2 of t2.Fo.get(e))
    t2.Oo.delete(s2), n && t2.$o.Go(s2, n);
  if (t2.Fo.delete(e), t2.isPrimaryClient) {
    t2.Uo.cs(e).forEach((e2) => {
      t2.Uo.containsKey(e2) || _c(t2, e2);
    });
  }
}
function _c(t2, e) {
  t2.Mo.delete(e.path.canonicalString());
  const n = t2.Lo.get(e);
  n !== null && (ao(t2.remoteStore, n), t2.Lo = t2.Lo.remove(e), t2.Bo.delete(n), yc(t2));
}
function mc(t2, e, n) {
  for (const s2 of n)
    if (s2 instanceof Jo)
      t2.Uo.addReference(s2.key, e), gc(t2, s2);
    else if (s2 instanceof Yo) {
      $("SyncEngine", "Document no longer in limbo: " + s2.key), t2.Uo.removeReference(s2.key, e);
      t2.Uo.containsKey(s2.key) || _c(t2, s2.key);
    } else
      L();
}
function gc(t2, e) {
  const n = e.key, s2 = n.path.canonicalString();
  t2.Lo.get(n) || t2.Mo.has(s2) || ($("SyncEngine", "New document in limbo: " + n), t2.Mo.add(s2), yc(t2));
}
function yc(t2) {
  for (; t2.Mo.size > 0 && t2.Lo.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.Mo.values().next().value;
    t2.Mo.delete(e);
    const n = new Pt(ht.fromString(e)), s2 = t2.jo.next();
    t2.Bo.set(s2, new tc(n)), t2.Lo = t2.Lo.insert(n, s2), co(t2.remoteStore, new ii(Ee(we(n.path)), s2, 2, X.T));
  }
}
async function pc(t2, e, n) {
  const s2 = q(t2), i = [], r = [], o = [];
  s2.Oo.isEmpty() || (s2.Oo.forEach((t3, c) => {
    o.push(s2.Wo(c, e, n).then((t4) => {
      if (t4) {
        s2.isPrimaryClient && s2.sharedClientState.updateQueryState(c.targetId, t4.fromCache ? "not-current" : "current"), i.push(t4);
        const e2 = or.kn(c.targetId, t4);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s2.$o.Rr(i), await async function(t3, e2) {
    const n2 = q(t3);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => js.forEach(e2, (e3) => js.forEach(e3.Nn, (s22) => n2.persistence.referenceDelegate.addReference(t4, e3.targetId, s22)).next(() => js.forEach(e3.xn, (s22) => n2.persistence.referenceDelegate.removeReference(t4, e3.targetId, s22)))));
    } catch (t4) {
      if (!Hs(t4))
        throw t4;
      $("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n2.Un.get(e3), s22 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s22);
        n2.Un = n2.Un.insert(e3, i2);
      }
    }
  }(s2.localStore, r));
}
async function Tc(t2, e) {
  const n = q(t2);
  if (!n.currentUser.isEqual(e)) {
    $("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await hr(n.localStore, e);
    n.currentUser = e, function(t4, e2) {
      t4.Ko.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new j(K.CANCELLED, e2));
        });
      }), t4.Ko.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await pc(n, t3.Wn);
  }
}
function Ec(t2, e) {
  const n = q(t2), s2 = n.Bo.get(e);
  if (s2 && s2.ko)
    return Pn().add(s2.key);
  {
    let t3 = Pn();
    const s22 = n.Fo.get(e);
    if (!s22)
      return t3;
    for (const e2 of s22) {
      const s3 = n.Oo.get(e2);
      t3 = t3.unionWith(s3.view.Ro);
    }
    return t3;
  }
}
function Cc(t2) {
  const e = q(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = oc.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = Ec.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = ac.bind(null, e), e.$o.Rr = qo.bind(null, e.eventManager), e.$o.Go = Ko.bind(null, e.eventManager), e;
}
function Nc(t2) {
  const e = q(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = uc.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = hc.bind(null, e), e;
}
async function jc(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), $("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t2.getConfiguration();
  await e.initialize(n);
  let s2 = n.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s2.isEqual(t3) || (await hr(e.localStore, t3), s2 = t3);
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e;
}
async function Qc(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n = await Wc(t2);
  $("FirestoreClient", "Initializing OnlineComponentProvider");
  const s2 = await t2.getConfiguration();
  await e.initialize(n, s2), t2.setCredentialChangeListener((t3) => async function(t4, e2) {
    const n2 = q(t4);
    n2.asyncQueue.verifyOperationInProgress(), $("RemoteStore", "RemoteStore received new credentials");
    const s22 = wo(n2);
    n2.Wr.add(3), await oo(n2), s22 && n2.Hr.set("Unknown"), await n2.remoteSyncer.handleCredentialChange(e2), n2.Wr.delete(3), await ro(n2);
  }(e.remoteStore, t3)), t2.onlineComponents = e;
}
async function Wc(t2) {
  return t2.offlineComponents || ($("FirestoreClient", "Using default OfflineComponentProvider"), await jc(t2, new kc())), t2.offlineComponents;
}
async function Gc(t2) {
  return t2.onlineComponents || ($("FirestoreClient", "Using default OnlineComponentProvider"), await Qc(t2, new Fc())), t2.onlineComponents;
}
function Yc(t2) {
  return Gc(t2).then((t3) => t3.syncEngine);
}
async function Xc(t2) {
  const e = await Gc(t2), n = e.eventManager;
  return n.onListen = nc.bind(null, e.syncEngine), n.onUnlisten = ic.bind(null, e.syncEngine), n;
}
function na(t2, e, n = {}) {
  const s2 = new Q();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s22, i) {
    const r = new Lc({
      next: (r2) => {
        e2.enqueueAndForget(() => Uo(t3, o));
        const c = r2.docs.has(n2);
        !c && r2.fromCache ? i.reject(new j(K.UNAVAILABLE, "Failed to get document because the client is offline.")) : c && r2.fromCache && s22 && s22.source === "server" ? i.reject(new j(K.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t4) => i.reject(t4)
    }), o = new Qo(we(n2.path), r, {
      includeMetadataChanges: true,
      fo: true
    });
    return Bo(t3, o);
  }(await Xc(t2), t2.asyncQueue, e, n, s2)), s2.promise;
}
function ia(t2, e, n = {}) {
  const s2 = new Q();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s22, i) {
    const r = new Lc({
      next: (n3) => {
        e2.enqueueAndForget(() => Uo(t3, o)), n3.fromCache && s22.source === "server" ? i.reject(new j(K.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t4) => i.reject(t4)
    }), o = new Qo(n2, r, {
      includeMetadataChanges: true,
      fo: true
    });
    return Bo(t3, o);
  }(await Xc(t2), t2.asyncQueue, e, n, s2)), s2.promise;
}
function fa(t2, e, n) {
  if (!n)
    throw new j(K.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function da(t2, e, n, s2) {
  if (e === true && s2 === true)
    throw new j(K.INVALID_ARGUMENT, `${t2} and ${n} cannot be used together.`);
}
function wa(t2) {
  if (!Pt.isDocumentKey(t2))
    throw new j(K.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function _a(t2) {
  if (Pt.isDocumentKey(t2))
    throw new j(K.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function ma(t2) {
  if (t2 === void 0)
    return "undefined";
  if (t2 === null)
    return "null";
  if (typeof t2 == "string")
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if (typeof t2 == "number" || typeof t2 == "boolean")
    return "" + t2;
  if (typeof t2 == "object") {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor)
          return t3.constructor.name;
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof t2 == "function" ? "a function" : L();
}
function ga(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new j(K.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = ma(t2);
      throw new j(K.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t2;
}
function ba(t2, e, ...n) {
  if (t2 = getModularInstance(t2), fa("collection", "path", e), t2 instanceof Ta) {
    const s2 = ht.fromString(e, ...n);
    return _a(s2), new Ra(t2, null, s2);
  }
  {
    if (!(t2 instanceof Ia || t2 instanceof Ra))
      throw new j(K.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s2 = t2._path.child(ht.fromString(e, ...n));
    return _a(s2), new Ra(t2.firestore, null, s2);
  }
}
function va(t2, e, ...n) {
  if (t2 = getModularInstance(t2), arguments.length === 1 && (e = tt.I()), fa("doc", "path", e), t2 instanceof Ta) {
    const s2 = ht.fromString(e, ...n);
    return wa(s2), new Ia(t2, null, new Pt(s2));
  }
  {
    if (!(t2 instanceof Ia || t2 instanceof Ra))
      throw new j(K.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s2 = t2._path.child(ht.fromString(e, ...n));
    return wa(s2), new Ia(t2.firestore, t2 instanceof Ra ? t2.converter : null, new Pt(s2));
  }
}
function Ca(t2) {
  return function(t3, e) {
    if (typeof t3 != "object" || t3 === null)
      return false;
    const n = t3;
    for (const t4 of e)
      if (t4 in n && typeof n[t4] == "function")
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
function Oa(e = getApp()) {
  return _getProvider(e, "firestore").getImmediate();
}
function Fa(t2) {
  return t2._firestoreClient || Ma(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function Ma(t2) {
  var e;
  const n = t2._freezeSettings(), s2 = function(t3, e2, n2, s22) {
    return new ua(t3, e2, n2, s22.host, s22.ssl, s22.experimentalForceLongPolling, s22.experimentalAutoDetectLongPolling, s22.useFetchStreams);
  }(t2._databaseId, ((e = t2._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t2._persistenceKey, n);
  t2._firestoreClient = new Kc(t2._credentials, t2._queue, s2);
}
function iu(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw L();
  }
}
function cu(t2) {
  const e = t2._freezeSettings(), n = Yr(t2._databaseId);
  return new ou(t2._databaseId, !!e.ignoreUndefinedProperties, n);
}
function au(t2, e, n, s2, i, r = {}) {
  const o = t2.jc(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  Eu("Data must be an object, but it was:", o, s2);
  const c = pu(s2, o);
  let a, u;
  if (r.merge)
    a = new dt(o.fieldMask), u = o.fieldTransforms;
  else if (r.mergeFields) {
    const t3 = [];
    for (const s22 of r.mergeFields) {
      const i2 = Iu(e, s22, n);
      if (!o.contains(i2))
        throw new j(K.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      Pu(t3, i2) || t3.push(i2);
    }
    a = new dt(t3), u = o.fieldTransforms.filter((t4) => a.covers(t4.field));
  } else
    a = null, u = o.fieldTransforms;
  return new nu(new Ut(c), a, u);
}
function hu(t2, e, n) {
  return new ru({
    kc: 3,
    Kc: e.settings.Kc,
    methodName: t2._methodName,
    Fc: n
  }, e.databaseId, e.N, e.ignoreUndefinedProperties);
}
function _u(t2, e, n, s2) {
  const i = t2.jc(1, e, n);
  Eu("Data must be an object, but it was:", i, s2);
  const r = [], o = Ut.empty();
  ct(s2, (t3, s22) => {
    const c2 = Ru(e, t3, n);
    s22 = getModularInstance(s22);
    const a = i.Lc(c2);
    if (s22 instanceof uu)
      r.push(c2);
    else {
      const t4 = yu(s22, a);
      t4 != null && (r.push(c2), o.set(c2, t4));
    }
  });
  const c = new dt(r);
  return new su(o, c, i.fieldTransforms);
}
function mu(t2, e, n, s2, i, r) {
  const o = t2.jc(1, e, n), c = [Iu(e, s2, n)], a = [i];
  if (r.length % 2 != 0)
    throw new j(K.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r.length; t3 += 2)
    c.push(Iu(e, r[t3])), a.push(r[t3 + 1]);
  const u = [], h = Ut.empty();
  for (let t3 = c.length - 1; t3 >= 0; --t3)
    if (!Pu(u, c[t3])) {
      const e2 = c[t3];
      let n2 = a[t3];
      n2 = getModularInstance(n2);
      const s22 = o.Lc(e2);
      if (n2 instanceof uu)
        u.push(e2);
      else {
        const t4 = yu(n2, s22);
        t4 != null && (u.push(e2), h.set(e2, t4));
      }
    }
  const l2 = new dt(u);
  return new su(h, l2, o.fieldTransforms);
}
function yu(t2, e) {
  if (Tu(t2 = getModularInstance(t2)))
    return Eu("Unsupported field value:", e, t2), pu(t2, e);
  if (t2 instanceof Za)
    return function(t3, e2) {
      if (!iu(e2.kc))
        throw e2.Uc(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.Uc(`${t3._methodName}() is not currently supported inside arrays`);
      const n = t3._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t2, e), null;
  if (t2 === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.Fc && e.kc !== 4)
      throw e.Uc("Nested arrays are not supported");
    return function(t3, e2) {
      const n = [];
      let s2 = 0;
      for (const i of t3) {
        let t4 = yu(i, e2.Bc(s2));
        t4 == null && (t4 = {
          nullValue: "NULL_VALUE"
        }), n.push(t4), s2++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if ((t3 = getModularInstance(t3)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t3 == "number")
      return Ce(e2.N, t3);
    if (typeof t3 == "boolean")
      return {
        booleanValue: t3
      };
    if (typeof t3 == "string")
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n = it.fromDate(t3);
      return {
        timestampValue: Un(e2.N, n)
      };
    }
    if (t3 instanceof it) {
      const n = new it(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: Un(e2.N, n)
      };
    }
    if (t3 instanceof tu)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof Xa)
      return {
        bytesValue: qn(e2.N, t3._byteString)
      };
    if (t3 instanceof Ia) {
      const n = e2.databaseId, s2 = t3.firestore._databaseId;
      if (!s2.isEqual(n))
        throw e2.Uc(`Document reference is for database ${s2.projectId}/${s2.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: Qn(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.Uc(`Unsupported field value: ${ma(t3)}`);
  }(t2, e);
}
function pu(t2, e) {
  const n = {};
  return at(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : ct(t2, (t3, s2) => {
    const i = yu(s2, e.Oc(t3));
    i != null && (n[t3] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function Tu(t2) {
  return !(typeof t2 != "object" || t2 === null || t2 instanceof Array || t2 instanceof Date || t2 instanceof it || t2 instanceof tu || t2 instanceof Xa || t2 instanceof Ia || t2 instanceof Za);
}
function Eu(t2, e, n) {
  if (!Tu(n) || !function(t3) {
    return typeof t3 == "object" && t3 !== null && (Object.getPrototypeOf(t3) === Object.prototype || Object.getPrototypeOf(t3) === null);
  }(n)) {
    const s2 = ma(n);
    throw s2 === "an object" ? e.Uc(t2 + " a custom object") : e.Uc(t2 + " " + s2);
  }
}
function Iu(t2, e, n) {
  if ((e = getModularInstance(e)) instanceof Ja)
    return e._internalPath;
  if (typeof e == "string")
    return Ru(t2, e);
  throw bu("Field path arguments must be of type string or FieldPath.", t2, false, void 0, n);
}
function Ru(t2, e, n) {
  if (e.search(Au) >= 0)
    throw bu(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t2, false, void 0, n);
  try {
    return new Ja(...e.split("."))._internalPath;
  } catch (s2) {
    throw bu(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t2, false, void 0, n);
  }
}
function bu(t2, e, n, s2, i) {
  const r = s2 && !s2.isEmpty(), o = i !== void 0;
  let c = `Function ${e}() called with invalid data`;
  n && (c += " (via `toFirestore()`)"), c += ". ";
  let a = "";
  return (r || o) && (a += " (found", r && (a += ` in field ${s2}`), o && (a += ` in document ${i}`), a += ")"), new j(K.INVALID_ARGUMENT, c + t2 + a);
}
function Pu(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
function Su(t2, e) {
  return typeof e == "string" ? Ru(t2, e) : e instanceof Ja ? e._internalPath : e._delegate._internalPath;
}
function ku(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return L();
  }
}
function Ou(t2) {
  if (me(t2) && t2.explicitOrderBy.length === 0)
    throw new j(K.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
function Mu(t2, ...e) {
  for (const n of e)
    t2 = n._apply(t2);
  return t2;
}
function qu(t2, e = "asc") {
  const n = e, s2 = Su("orderBy", t2);
  return new Uu(s2, n);
}
function eh(t2, e, n) {
  if (!n.isEqual(e))
    throw new j(K.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
function sh(t2, e, n) {
  let s2;
  return s2 = t2 ? n && (n.merge || n.mergeFields) ? t2.toFirestore(e, n) : t2.toFirestore(e) : e, s2;
}
function oh(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new j(K.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
function ch(t2) {
  t2 = ga(t2, Ia);
  const e = ga(t2.firestore, ka);
  return na(Fa(e), t2._key).then((n) => Eh(e, t2, n));
}
function lh(t2) {
  t2 = ga(t2, Aa);
  const e = ga(t2.firestore, ka), n = Fa(e), s2 = new ah(e);
  return Ou(t2._query), ia(n, t2._query).then((n2) => new xu(e, s2, t2, n2));
}
function wh(t2, e, n) {
  t2 = ga(t2, Ia);
  const s2 = ga(t2.firestore, ka), i = sh(t2.converter, e, n);
  return Th(s2, [au(cu(s2), "setDoc", t2._key, i, t2.converter !== null, n).toMutation(t2._key, Ge.none())]);
}
function _h(t2, e, n, ...s2) {
  t2 = ga(t2, Ia);
  const i = ga(t2.firestore, ka), r = cu(i);
  let o;
  o = typeof (e = getModularInstance(e)) == "string" || e instanceof Ja ? mu(r, "updateDoc", t2._key, e, n, s2) : _u(r, "updateDoc", t2._key, e);
  return Th(i, [o.toMutation(t2._key, Ge.exists(true))]);
}
function mh(t2) {
  return Th(ga(t2.firestore, ka), [new cn(t2._key, Ge.none())]);
}
function yh(t2, ...e) {
  var n, s2, i;
  t2 = getModularInstance(t2);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  typeof e[o] != "object" || Ca(e[o]) || (r = e[o], o++);
  const c = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (Ca(e[o])) {
    const t3 = e[o];
    e[o] = (n = t3.next) === null || n === void 0 ? void 0 : n.bind(t3), e[o + 1] = (s2 = t3.error) === null || s2 === void 0 ? void 0 : s2.bind(t3), e[o + 2] = (i = t3.complete) === null || i === void 0 ? void 0 : i.bind(t3);
  }
  let a, u, h;
  if (t2 instanceof Ia)
    u = ga(t2.firestore, ka), h = we(t2._key.path), a = {
      next: (n2) => {
        e[o] && e[o](Eh(u, t2, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = ga(t2, Aa);
    u = ga(n2.firestore, ka), h = n2._query;
    const s22 = new ah(u);
    a = {
      next: (t3) => {
        e[o] && e[o](new xu(u, s22, n2, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, Ou(t2._query);
  }
  return function(t3, e2, n2, s22) {
    const i2 = new Lc(s22), r2 = new Qo(e2, i2, n2);
    return t3.asyncQueue.enqueueAndForget(async () => Bo(await Xc(t3), r2)), () => {
      i2.ec(), t3.asyncQueue.enqueueAndForget(async () => Uo(await Xc(t3), r2));
    };
  }(Fa(u), h, c, a);
}
function Th(t2, e) {
  return function(t3, e2) {
    const n = new Q();
    return t3.asyncQueue.enqueueAndForget(async () => rc(await Yc(t3), e2, n)), n.promise;
  }(Fa(t2), e);
}
function Eh(t2, e, n) {
  const s2 = n.docs.get(e._key), i = new ah(t2);
  return new Cu(t2, i, e._key, s2, new Du(n.hasPendingWrites, n.fromCache), e.converter);
}
function bh() {
  return new lu("serverTimestamp");
}
function Ph(...t2) {
  return new fu("arrayUnion", t2);
}
function Vh(t2) {
  return new wu("increment", t2);
}
function Sh(t2) {
  return Fa(t2 = ga(t2, ka)), new rh(t2, (e) => Th(t2, e));
}
function __extends(d2, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d2, b);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s2, e) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
function __values(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function readable(value, start2) {
  return {
    subscribe: writable(value, start2).subscribe
  };
}
function writable(value, start2 = noop) {
  let stop2;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop2) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn2) {
    set(fn2(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop2 = start2(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop2();
        stop2 = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function getRandomID() {
  const chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let autoId = "";
  for (let i = 0; i < 20; i++) {
    autoId += chars2.charAt(Math.floor(Math.random() * chars2.length));
  }
  return autoId;
}
var CONSTANTS, assert, assertionError, stringToByteArray$1, byteArrayToString, base64, base64Encode, base64Decode, Deferred, ERROR_NAME, FirebaseError, ErrorFactory, PATTERN, decode, isValidFormat, isAdmin, Sha1, ObserverProxy, stringToByteArray, stringLength, Component, LogLevel, levelStringToEnum, defaultLogLevel, ConsoleMethod, defaultLogHandler, Logger, PlatformLoggerServiceImpl, name$o, version$1, logger, name$n, name$m, name$l, name$k, name$j, name$i, name$h, name$g, name$f, name$e, name$d, name$c, name$b, name$a, name$9, name$8, name$7, name$6, name$5, name$4, name$3, name$2, name$1, name, version, DEFAULT_ENTRY_NAME, PLATFORM_LOG_STRING, _apps, _components, ERRORS, ERROR_FACTORY, SDK_VERSION, commonjsGlobal2, k, goog, l, ea, fa$1, ka$1, la$1, ma$1, na$1, ta, x$1, va$1, wa$1, za, Ha, y, Ia$1, Ja$1, Ka, La, Na, Oa$1, Pa, Qa, Ga, Sa, Ta$1, Ua, Va, Wa, B$1, Xa$1, cb, db, pb, rb, ub, vb, wb, Ab, Cb, tb, Ib, Jb, H$1, Rb, Wb, Xb, L$1, cc$1, ec$1, gc$1, hc$1, Mc, Vc, Xc$1, Wc$1, $c, Yc$1, fd, hd, rd, vd, wd, xd, yd, createWebChannelTransport, getStatEventTarget, ErrorCode, EventType, Event2, Stat, FetchXmlHttpFactory, WebChannel, XhrIo, S, D, C, N, K, j, Q, W, G, H, J, Y, X, tt, it, rt, ut, ht, lt, ft, dt, _t, mt, Pt, Ut, Kt, jt, Jt, Xt, Zt, te, ne, se, ie, re, oe, ae, fe, Ne, Oe, Fe, Le, Ue, je, We, Ge, He, en, nn, cn, an, un, hn, ln, wn, _n, mn, gn, yn, pn, En, An, bn, vn, Sn, Dn, Cn, Nn, xn, kn, $n, Mn, Ln, Bn, qs, Ks, js, ni, si, ii, ri, pi, Ti, Ni, ji, Qi, rr, or, cr, ar, Rr, br, Pr, vr, Vr, Sr, Dr, Cr, Nr, xr, Ur, Kr, jr, Qr, Wr, Gr, zr, Xr, Zr, to, eo, no, so, io, xo, $o, Oo, Fo, Mo, Lo, Qo, Jo, Yo, Xo, Zo, tc, ec, kc, Fc, Lc, Kc, ua, ha, la, pa, Ta, Ia, Aa, Ra, Da, ka, Ja, Xa, Za, tu, eu, nu, su, ru, ou, uu, lu, fu, wu, Au, vu, Vu, Du, Cu, Nu, xu, Fu, Uu, nh, rh, ah, extendStatics, __assign, subscriber_queue, displayDate, canvasHeight, canvasWidth, hasFetchedUser, user, currentTool, onlyAllowApplePencil, dailyMicStream, roomToPeople, dailyRoomParticipants, browserTabID, isFirestoreDocCreated, willPreventPageLeave;
var init_store_85fd0788 = __esm({
  ".svelte-kit/output/server/chunks/store-85fd0788.js"() {
    init_shims();
    init_app_dafecf1b();
    CONSTANTS = {
      NODE_CLIENT: false,
      NODE_ADMIN: false,
      SDK_VERSION: "${JSCORE_VERSION}"
    };
    assert = function(assertion, message2) {
      if (!assertion) {
        throw assertionError(message2);
      }
    };
    assertionError = function(message2) {
      return new Error("Firebase Database (" + CONSTANTS.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + message2);
    };
    stringToByteArray$1 = function(str) {
      const out = [];
      let p2 = 0;
      for (let i = 0; i < str.length; i++) {
        let c = str.charCodeAt(i);
        if (c < 128) {
          out[p2++] = c;
        } else if (c < 2048) {
          out[p2++] = c >> 6 | 192;
          out[p2++] = c & 63 | 128;
        } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
          c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
          out[p2++] = c >> 18 | 240;
          out[p2++] = c >> 12 & 63 | 128;
          out[p2++] = c >> 6 & 63 | 128;
          out[p2++] = c & 63 | 128;
        } else {
          out[p2++] = c >> 12 | 224;
          out[p2++] = c >> 6 & 63 | 128;
          out[p2++] = c & 63 | 128;
        }
      }
      return out;
    };
    byteArrayToString = function(bytes) {
      const out = [];
      let pos = 0, c = 0;
      while (pos < bytes.length) {
        const c1 = bytes[pos++];
        if (c1 < 128) {
          out[c++] = String.fromCharCode(c1);
        } else if (c1 > 191 && c1 < 224) {
          const c2 = bytes[pos++];
          out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
        } else if (c1 > 239 && c1 < 365) {
          const c2 = bytes[pos++];
          const c3 = bytes[pos++];
          const c4 = bytes[pos++];
          const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
          out[c++] = String.fromCharCode(55296 + (u >> 10));
          out[c++] = String.fromCharCode(56320 + (u & 1023));
        } else {
          const c2 = bytes[pos++];
          const c3 = bytes[pos++];
          out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        }
      }
      return out.join("");
    };
    base64 = {
      byteToCharMap_: null,
      charToByteMap_: null,
      byteToCharMapWebSafe_: null,
      charToByteMapWebSafe_: null,
      ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
      get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + "+/=";
      },
      get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + "-_.";
      },
      HAS_NATIVE_SUPPORT: typeof atob === "function",
      encodeByteArray(input, webSafe) {
        if (!Array.isArray(input)) {
          throw Error("encodeByteArray takes an array as a parameter");
        }
        this.init_();
        const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
        const output = [];
        for (let i = 0; i < input.length; i += 3) {
          const byte1 = input[i];
          const haveByte2 = i + 1 < input.length;
          const byte2 = haveByte2 ? input[i + 1] : 0;
          const haveByte3 = i + 2 < input.length;
          const byte3 = haveByte3 ? input[i + 2] : 0;
          const outByte1 = byte1 >> 2;
          const outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
          let outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
          let outByte4 = byte3 & 63;
          if (!haveByte3) {
            outByte4 = 64;
            if (!haveByte2) {
              outByte3 = 64;
            }
          }
          output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join("");
      },
      encodeString(input, webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
          return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray$1(input), webSafe);
      },
      decodeString(input, webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
          return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
      },
      decodeStringToByteArray(input, webSafe) {
        this.init_();
        const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
        const output = [];
        for (let i = 0; i < input.length; ) {
          const byte1 = charToByteMap[input.charAt(i++)];
          const haveByte2 = i < input.length;
          const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
          ++i;
          const haveByte3 = i < input.length;
          const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
          ++i;
          const haveByte4 = i < input.length;
          const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
          ++i;
          if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
            throw Error();
          }
          const outByte1 = byte1 << 2 | byte2 >> 4;
          output.push(outByte1);
          if (byte3 !== 64) {
            const outByte2 = byte2 << 4 & 240 | byte3 >> 2;
            output.push(outByte2);
            if (byte4 !== 64) {
              const outByte3 = byte3 << 6 & 192 | byte4;
              output.push(outByte3);
            }
          }
        }
        return output;
      },
      init_() {
        if (!this.byteToCharMap_) {
          this.byteToCharMap_ = {};
          this.charToByteMap_ = {};
          this.byteToCharMapWebSafe_ = {};
          this.charToByteMapWebSafe_ = {};
          for (let i = 0; i < this.ENCODED_VALS.length; i++) {
            this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
            this.charToByteMap_[this.byteToCharMap_[i]] = i;
            this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
            this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
            if (i >= this.ENCODED_VALS_BASE.length) {
              this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
              this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
            }
          }
        }
      }
    };
    base64Encode = function(str) {
      const utf8Bytes = stringToByteArray$1(str);
      return base64.encodeByteArray(utf8Bytes, true);
    };
    base64Decode = function(str) {
      try {
        return base64.decodeString(str, true);
      } catch (e) {
        console.error("base64Decode failed: ", e);
      }
      return null;
    };
    Deferred = class {
      constructor() {
        this.reject = () => {
        };
        this.resolve = () => {
        };
        this.promise = new Promise((resolve2, reject2) => {
          this.resolve = resolve2;
          this.reject = reject2;
        });
      }
      wrapCallback(callback) {
        return (error3, value) => {
          if (error3) {
            this.reject(error3);
          } else {
            this.resolve(value);
          }
          if (typeof callback === "function") {
            this.promise.catch(() => {
            });
            if (callback.length === 1) {
              callback(error3);
            } else {
              callback(error3, value);
            }
          }
        };
      }
    };
    ERROR_NAME = "FirebaseError";
    FirebaseError = class extends Error {
      constructor(code, message2, customData) {
        super(message2);
        this.code = code;
        this.customData = customData;
        this.name = ERROR_NAME;
        Object.setPrototypeOf(this, FirebaseError.prototype);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, ErrorFactory.prototype.create);
        }
      }
    };
    ErrorFactory = class {
      constructor(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
      }
      create(code, ...data) {
        const customData = data[0] || {};
        const fullCode = `${this.service}/${code}`;
        const template2 = this.errors[code];
        const message2 = template2 ? replaceTemplate(template2, customData) : "Error";
        const fullMessage = `${this.serviceName}: ${message2} (${fullCode}).`;
        const error3 = new FirebaseError(fullCode, fullMessage, customData);
        return error3;
      }
    };
    PATTERN = /\{\$([^}]+)}/g;
    decode = function(token) {
      let header = {}, claims = {}, data = {}, signature = "";
      try {
        const parts = token.split(".");
        header = jsonEval(base64Decode(parts[0]) || "");
        claims = jsonEval(base64Decode(parts[1]) || "");
        signature = parts[2];
        data = claims["d"] || {};
        delete claims["d"];
      } catch (e) {
      }
      return {
        header,
        claims,
        data,
        signature
      };
    };
    isValidFormat = function(token) {
      const decoded = decode(token), claims = decoded.claims;
      return !!claims && typeof claims === "object" && claims.hasOwnProperty("iat");
    };
    isAdmin = function(token) {
      const claims = decode(token).claims;
      return typeof claims === "object" && claims["admin"] === true;
    };
    Sha1 = class {
      constructor() {
        this.chain_ = [];
        this.buf_ = [];
        this.W_ = [];
        this.pad_ = [];
        this.inbuf_ = 0;
        this.total_ = 0;
        this.blockSize = 512 / 8;
        this.pad_[0] = 128;
        for (let i = 1; i < this.blockSize; ++i) {
          this.pad_[i] = 0;
        }
        this.reset();
      }
      reset() {
        this.chain_[0] = 1732584193;
        this.chain_[1] = 4023233417;
        this.chain_[2] = 2562383102;
        this.chain_[3] = 271733878;
        this.chain_[4] = 3285377520;
        this.inbuf_ = 0;
        this.total_ = 0;
      }
      compress_(buf, offset) {
        if (!offset) {
          offset = 0;
        }
        const W2 = this.W_;
        if (typeof buf === "string") {
          for (let i = 0; i < 16; i++) {
            W2[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);
            offset += 4;
          }
        } else {
          for (let i = 0; i < 16; i++) {
            W2[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];
            offset += 4;
          }
        }
        for (let i = 16; i < 80; i++) {
          const t2 = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
          W2[i] = (t2 << 1 | t2 >>> 31) & 4294967295;
        }
        let a = this.chain_[0];
        let b = this.chain_[1];
        let c = this.chain_[2];
        let d2 = this.chain_[3];
        let e = this.chain_[4];
        let f, k2;
        for (let i = 0; i < 80; i++) {
          if (i < 40) {
            if (i < 20) {
              f = d2 ^ b & (c ^ d2);
              k2 = 1518500249;
            } else {
              f = b ^ c ^ d2;
              k2 = 1859775393;
            }
          } else {
            if (i < 60) {
              f = b & c | d2 & (b | c);
              k2 = 2400959708;
            } else {
              f = b ^ c ^ d2;
              k2 = 3395469782;
            }
          }
          const t2 = (a << 5 | a >>> 27) + f + e + k2 + W2[i] & 4294967295;
          e = d2;
          d2 = c;
          c = (b << 30 | b >>> 2) & 4294967295;
          b = a;
          a = t2;
        }
        this.chain_[0] = this.chain_[0] + a & 4294967295;
        this.chain_[1] = this.chain_[1] + b & 4294967295;
        this.chain_[2] = this.chain_[2] + c & 4294967295;
        this.chain_[3] = this.chain_[3] + d2 & 4294967295;
        this.chain_[4] = this.chain_[4] + e & 4294967295;
      }
      update(bytes, length) {
        if (bytes == null) {
          return;
        }
        if (length === void 0) {
          length = bytes.length;
        }
        const lengthMinusBlock = length - this.blockSize;
        let n = 0;
        const buf = this.buf_;
        let inbuf = this.inbuf_;
        while (n < length) {
          if (inbuf === 0) {
            while (n <= lengthMinusBlock) {
              this.compress_(bytes, n);
              n += this.blockSize;
            }
          }
          if (typeof bytes === "string") {
            while (n < length) {
              buf[inbuf] = bytes.charCodeAt(n);
              ++inbuf;
              ++n;
              if (inbuf === this.blockSize) {
                this.compress_(buf);
                inbuf = 0;
                break;
              }
            }
          } else {
            while (n < length) {
              buf[inbuf] = bytes[n];
              ++inbuf;
              ++n;
              if (inbuf === this.blockSize) {
                this.compress_(buf);
                inbuf = 0;
                break;
              }
            }
          }
        }
        this.inbuf_ = inbuf;
        this.total_ += length;
      }
      digest() {
        const digest = [];
        let totalBits = this.total_ * 8;
        if (this.inbuf_ < 56) {
          this.update(this.pad_, 56 - this.inbuf_);
        } else {
          this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        }
        for (let i = this.blockSize - 1; i >= 56; i--) {
          this.buf_[i] = totalBits & 255;
          totalBits /= 256;
        }
        this.compress_(this.buf_);
        let n = 0;
        for (let i = 0; i < 5; i++) {
          for (let j2 = 24; j2 >= 0; j2 -= 8) {
            digest[n] = this.chain_[i] >> j2 & 255;
            ++n;
          }
        }
        return digest;
      }
    };
    ObserverProxy = class {
      constructor(executor, onNoObservers) {
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        this.task.then(() => {
          executor(this);
        }).catch((e) => {
          this.error(e);
        });
      }
      next(value) {
        this.forEachObserver((observer) => {
          observer.next(value);
        });
      }
      error(error3) {
        this.forEachObserver((observer) => {
          observer.error(error3);
        });
        this.close(error3);
      }
      complete() {
        this.forEachObserver((observer) => {
          observer.complete();
        });
        this.close();
      }
      subscribe(nextOrObserver, error3, complete) {
        let observer;
        if (nextOrObserver === void 0 && error3 === void 0 && complete === void 0) {
          throw new Error("Missing Observer.");
        }
        if (implementsAnyMethods(nextOrObserver, [
          "next",
          "error",
          "complete"
        ])) {
          observer = nextOrObserver;
        } else {
          observer = {
            next: nextOrObserver,
            error: error3,
            complete
          };
        }
        if (observer.next === void 0) {
          observer.next = noop2;
        }
        if (observer.error === void 0) {
          observer.error = noop2;
        }
        if (observer.complete === void 0) {
          observer.complete = noop2;
        }
        const unsub = this.unsubscribeOne.bind(this, this.observers.length);
        if (this.finalized) {
          this.task.then(() => {
            try {
              if (this.finalError) {
                observer.error(this.finalError);
              } else {
                observer.complete();
              }
            } catch (e) {
            }
            return;
          });
        }
        this.observers.push(observer);
        return unsub;
      }
      unsubscribeOne(i) {
        if (this.observers === void 0 || this.observers[i] === void 0) {
          return;
        }
        delete this.observers[i];
        this.observerCount -= 1;
        if (this.observerCount === 0 && this.onNoObservers !== void 0) {
          this.onNoObservers(this);
        }
      }
      forEachObserver(fn2) {
        if (this.finalized) {
          return;
        }
        for (let i = 0; i < this.observers.length; i++) {
          this.sendOne(i, fn2);
        }
      }
      sendOne(i, fn2) {
        this.task.then(() => {
          if (this.observers !== void 0 && this.observers[i] !== void 0) {
            try {
              fn2(this.observers[i]);
            } catch (e) {
              if (typeof console !== "undefined" && console.error) {
                console.error(e);
              }
            }
          }
        });
      }
      close(err) {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        if (err !== void 0) {
          this.finalError = err;
        }
        this.task.then(() => {
          this.observers = void 0;
          this.onNoObservers = void 0;
        });
      }
    };
    stringToByteArray = function(str) {
      const out = [];
      let p2 = 0;
      for (let i = 0; i < str.length; i++) {
        let c = str.charCodeAt(i);
        if (c >= 55296 && c <= 56319) {
          const high = c - 55296;
          i++;
          assert(i < str.length, "Surrogate pair missing trail surrogate.");
          const low = str.charCodeAt(i) - 56320;
          c = 65536 + (high << 10) + low;
        }
        if (c < 128) {
          out[p2++] = c;
        } else if (c < 2048) {
          out[p2++] = c >> 6 | 192;
          out[p2++] = c & 63 | 128;
        } else if (c < 65536) {
          out[p2++] = c >> 12 | 224;
          out[p2++] = c >> 6 & 63 | 128;
          out[p2++] = c & 63 | 128;
        } else {
          out[p2++] = c >> 18 | 240;
          out[p2++] = c >> 12 & 63 | 128;
          out[p2++] = c >> 6 & 63 | 128;
          out[p2++] = c & 63 | 128;
        }
      }
      return out;
    };
    stringLength = function(str) {
      let p2 = 0;
      for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 128) {
          p2++;
        } else if (c < 2048) {
          p2 += 2;
        } else if (c >= 55296 && c <= 56319) {
          p2 += 4;
          i++;
        } else {
          p2 += 3;
        }
      }
      return p2;
    };
    CONSTANTS.NODE_CLIENT = true;
    Component = class {
      constructor(name22, instanceFactory, type) {
        this.name = name22;
        this.instanceFactory = instanceFactory;
        this.type = type;
        this.multipleInstances = false;
        this.serviceProps = {};
        this.instantiationMode = "LAZY";
        this.onInstanceCreated = null;
      }
      setInstantiationMode(mode) {
        this.instantiationMode = mode;
        return this;
      }
      setMultipleInstances(multipleInstances) {
        this.multipleInstances = multipleInstances;
        return this;
      }
      setServiceProps(props) {
        this.serviceProps = props;
        return this;
      }
      setInstanceCreatedCallback(callback) {
        this.onInstanceCreated = callback;
        return this;
      }
    };
    (function(LogLevel2) {
      LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
      LogLevel2[LogLevel2["VERBOSE"] = 1] = "VERBOSE";
      LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
      LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
      LogLevel2[LogLevel2["ERROR"] = 4] = "ERROR";
      LogLevel2[LogLevel2["SILENT"] = 5] = "SILENT";
    })(LogLevel || (LogLevel = {}));
    levelStringToEnum = {
      "debug": LogLevel.DEBUG,
      "verbose": LogLevel.VERBOSE,
      "info": LogLevel.INFO,
      "warn": LogLevel.WARN,
      "error": LogLevel.ERROR,
      "silent": LogLevel.SILENT
    };
    defaultLogLevel = LogLevel.INFO;
    ConsoleMethod = {
      [LogLevel.DEBUG]: "log",
      [LogLevel.VERBOSE]: "log",
      [LogLevel.INFO]: "info",
      [LogLevel.WARN]: "warn",
      [LogLevel.ERROR]: "error"
    };
    defaultLogHandler = (instance2, logType, ...args) => {
      if (logType < instance2.logLevel) {
        return;
      }
      const now = new Date().toISOString();
      const method = ConsoleMethod[logType];
      if (method) {
        console[method](`[${now}]  ${instance2.name}:`, ...args);
      } else {
        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
      }
    };
    Logger = class {
      constructor(name22) {
        this.name = name22;
        this._logLevel = defaultLogLevel;
        this._logHandler = defaultLogHandler;
        this._userLogHandler = null;
      }
      get logLevel() {
        return this._logLevel;
      }
      set logLevel(val) {
        if (!(val in LogLevel)) {
          throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
        }
        this._logLevel = val;
      }
      setLogLevel(val) {
        this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
      }
      get logHandler() {
        return this._logHandler;
      }
      set logHandler(val) {
        if (typeof val !== "function") {
          throw new TypeError("Value assigned to `logHandler` must be a function");
        }
        this._logHandler = val;
      }
      get userLogHandler() {
        return this._userLogHandler;
      }
      set userLogHandler(val) {
        this._userLogHandler = val;
      }
      debug(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
        this._logHandler(this, LogLevel.DEBUG, ...args);
      }
      log(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);
        this._logHandler(this, LogLevel.VERBOSE, ...args);
      }
      info(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
        this._logHandler(this, LogLevel.INFO, ...args);
      }
      warn(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
        this._logHandler(this, LogLevel.WARN, ...args);
      }
      error(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
        this._logHandler(this, LogLevel.ERROR, ...args);
      }
    };
    PlatformLoggerServiceImpl = class {
      constructor(container) {
        this.container = container;
      }
      getPlatformInfoString() {
        const providers = this.container.getProviders();
        return providers.map((provider) => {
          if (isVersionServiceProvider(provider)) {
            const service = provider.getImmediate();
            return `${service.library}/${service.version}`;
          } else {
            return null;
          }
        }).filter((logString) => logString).join(" ");
      }
    };
    name$o = "@firebase/app";
    version$1 = "0.7.9";
    logger = new Logger("@firebase/app");
    name$n = "@firebase/app-compat";
    name$m = "@firebase/analytics-compat";
    name$l = "@firebase/analytics";
    name$k = "@firebase/app-check-compat";
    name$j = "@firebase/app-check";
    name$i = "@firebase/auth";
    name$h = "@firebase/auth-compat";
    name$g = "@firebase/database";
    name$f = "@firebase/database-compat";
    name$e = "@firebase/functions";
    name$d = "@firebase/functions-compat";
    name$c = "@firebase/installations";
    name$b = "@firebase/installations-compat";
    name$a = "@firebase/messaging";
    name$9 = "@firebase/messaging-compat";
    name$8 = "@firebase/performance";
    name$7 = "@firebase/performance-compat";
    name$6 = "@firebase/remote-config";
    name$5 = "@firebase/remote-config-compat";
    name$4 = "@firebase/storage";
    name$3 = "@firebase/storage-compat";
    name$2 = "@firebase/firestore";
    name$1 = "@firebase/firestore-compat";
    name = "firebase";
    version = "9.5.0";
    DEFAULT_ENTRY_NAME = "[DEFAULT]";
    PLATFORM_LOG_STRING = {
      [name$o]: "fire-core",
      [name$n]: "fire-core-compat",
      [name$l]: "fire-analytics",
      [name$m]: "fire-analytics-compat",
      [name$j]: "fire-app-check",
      [name$k]: "fire-app-check-compat",
      [name$i]: "fire-auth",
      [name$h]: "fire-auth-compat",
      [name$g]: "fire-rtdb",
      [name$f]: "fire-rtdb-compat",
      [name$e]: "fire-fn",
      [name$d]: "fire-fn-compat",
      [name$c]: "fire-iid",
      [name$b]: "fire-iid-compat",
      [name$a]: "fire-fcm",
      [name$9]: "fire-fcm-compat",
      [name$8]: "fire-perf",
      [name$7]: "fire-perf-compat",
      [name$6]: "fire-rc",
      [name$5]: "fire-rc-compat",
      [name$4]: "fire-gcs",
      [name$3]: "fire-gcs-compat",
      [name$2]: "fire-fst",
      [name$1]: "fire-fst-compat",
      "fire-js": "fire-js",
      [name]: "fire-js-all"
    };
    _apps = new Map();
    _components = new Map();
    ERRORS = {
      ["no-app"]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
      ["bad-app-name"]: "Illegal App name: '{$appName}",
      ["duplicate-app"]: "Firebase App named '{$appName}' already exists with different options or config",
      ["app-deleted"]: "Firebase App named '{$appName}' already deleted",
      ["invalid-app-argument"]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
      ["invalid-log-argument"]: "First argument to `onLog` must be null or a function."
    };
    ERROR_FACTORY = new ErrorFactory("app", "Firebase", ERRORS);
    SDK_VERSION = version;
    registerCoreComponents("");
    commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    goog = goog || {};
    l = commonjsGlobal2 || self;
    ea = "closure_uid_" + (1e9 * Math.random() >>> 0);
    fa$1 = 0;
    ka$1 = 0;
    la$1 = {};
    v.prototype.s = false;
    v.prototype.na = function() {
      if (!this.s && (this.s = true, this.M(), ka$1 != 0)) {
        var a = da$1(this);
        delete la$1[a];
      }
    };
    v.prototype.M = function() {
      if (this.o)
        for (; this.o.length; )
          this.o.shift()();
    };
    ma$1 = Array.prototype.indexOf ? function(a, b) {
      return Array.prototype.indexOf.call(a, b, void 0);
    } : function(a, b) {
      if (typeof a === "string")
        return typeof b !== "string" || b.length != 1 ? -1 : a.indexOf(b, 0);
      for (let c = 0; c < a.length; c++)
        if (c in a && a[c] === b)
          return c;
      return -1;
    };
    na$1 = Array.prototype.forEach ? function(a, b, c) {
      Array.prototype.forEach.call(a, b, c);
    } : function(a, b, c) {
      const d2 = a.length, e = typeof a === "string" ? a.split("") : a;
      for (let f = 0; f < d2; f++)
        f in e && b.call(c, e[f], f, a);
    };
    ta = String.prototype.trim ? function(a) {
      return a.trim();
    } : function(a) {
      return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
    };
    a: {
      va$1 = l.navigator;
      if (va$1) {
        wa$1 = va$1.userAgent;
        if (wa$1) {
          x$1 = wa$1;
          break a;
        }
      }
      x$1 = "";
    }
    za = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
    Ca$1[" "] = aa;
    Ha = w(x$1, "Opera");
    y = w(x$1, "Trident") || w(x$1, "MSIE");
    Ia$1 = w(x$1, "Edge");
    Ja$1 = Ia$1 || y;
    Ka = w(x$1, "Gecko") && !(w(x$1.toLowerCase(), "webkit") && !w(x$1, "Edge")) && !(w(x$1, "Trident") || w(x$1, "MSIE")) && !w(x$1, "Edge");
    La = w(x$1.toLowerCase(), "webkit") && !w(x$1, "Edge");
    a: {
      Oa$1 = "", Pa = function() {
        var a = x$1;
        if (Ka)
          return /rv:([^\);]+)(\)|;)/.exec(a);
        if (Ia$1)
          return /Edge\/([\d\.]+)/.exec(a);
        if (y)
          return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
        if (La)
          return /WebKit\/(\S+)/.exec(a);
        if (Ha)
          return /(?:Version)[ \/]?(\S+)/.exec(a);
      }();
      Pa && (Oa$1 = Pa ? Pa[1] : "");
      if (y) {
        Qa = Ma$1();
        if (Qa != null && Qa > parseFloat(Oa$1)) {
          Na = String(Qa);
          break a;
        }
      }
      Na = Oa$1;
    }
    Ga = {};
    if (l.document && y) {
      Ta$1 = Ma$1();
      Sa = Ta$1 ? Ta$1 : parseInt(Na, 10) || void 0;
    } else
      Sa = void 0;
    Ua = Sa;
    Va = function() {
      if (!l.addEventListener || !Object.defineProperty)
        return false;
      var a = false, b = Object.defineProperty({}, "passive", { get: function() {
        a = true;
      } });
      try {
        l.addEventListener("test", aa, b), l.removeEventListener("test", aa, b);
      } catch (c) {
      }
      return a;
    }();
    z.prototype.h = function() {
      this.defaultPrevented = true;
    };
    t(A, z);
    Wa = { 2: "touch", 3: "pen", 4: "mouse" };
    A.prototype.h = function() {
      A.Z.h.call(this);
      var a = this.i;
      a.preventDefault ? a.preventDefault() : a.returnValue = false;
    };
    B$1 = "closure_listenable_" + (1e6 * Math.random() | 0);
    Xa$1 = 0;
    $a.prototype.add = function(a, b, c, d2, e) {
      var f = a.toString();
      a = this.g[f];
      a || (a = this.g[f] = [], this.h++);
      var h = ab(a, b, d2, e);
      -1 < h ? (b = a[h], c || (b.fa = false)) : (b = new Ya(b, this.src, f, !!d2, e), b.fa = c, a.push(b));
      return b;
    };
    cb = "closure_lm_" + (1e6 * Math.random() | 0);
    db = {};
    pb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
    t(C$1, v);
    C$1.prototype[B$1] = true;
    C$1.prototype.removeEventListener = function(a, b, c, d2) {
      nb(this, a, b, c, d2);
    };
    C$1.prototype.M = function() {
      C$1.Z.M.call(this);
      if (this.i) {
        var a = this.i, c;
        for (c in a.g) {
          for (var d2 = a.g[c], e = 0; e < d2.length; e++)
            Za$1(d2[e]);
          delete a.g[c];
          a.h--;
        }
      }
      this.I = null;
    };
    C$1.prototype.N = function(a, b, c, d2) {
      return this.i.add(String(a), b, false, c, d2);
    };
    C$1.prototype.O = function(a, b, c, d2) {
      return this.i.add(String(a), b, true, c, d2);
    };
    rb = l.JSON.stringify;
    ub = class {
      constructor() {
        this.h = this.g = null;
      }
      add(a, b) {
        const c = vb.get();
        c.set(a, b);
        this.h ? this.h.next = c : this.g = c;
        this.h = c;
      }
    };
    vb = new class {
      constructor(a, b) {
        this.i = a;
        this.j = b;
        this.h = 0;
        this.g = null;
      }
      get() {
        let a;
        0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
        return a;
      }
    }(() => new wb(), (a) => a.reset());
    wb = class {
      constructor() {
        this.next = this.g = this.h = null;
      }
      set(a, b) {
        this.h = a;
        this.g = b;
        this.next = null;
      }
      reset() {
        this.next = this.g = this.h = null;
      }
    };
    Cb = false;
    tb = new ub();
    t(Eb, C$1);
    k = Eb.prototype;
    k.da = false;
    k.S = null;
    k.kb = function() {
      if (this.da) {
        var a = Date.now() - this.l;
        0 < a && a < 0.8 * this.h ? this.S = this.g.setTimeout(this.j, this.h - a) : (this.S && (this.g.clearTimeout(this.S), this.S = null), D$1(this, "tick"), this.da && (Fb(this), this.start()));
      }
    };
    k.start = function() {
      this.da = true;
      this.S || (this.S = this.g.setTimeout(this.j, this.h), this.l = Date.now());
    };
    k.M = function() {
      Eb.Z.M.call(this);
      Fb(this);
      delete this.g;
    };
    Ib = class extends v {
      constructor(a, b) {
        super();
        this.m = a;
        this.j = b;
        this.h = null;
        this.i = false;
        this.g = null;
      }
      l(a) {
        this.h = arguments;
        this.g ? this.i = true : Hb(this);
      }
      M() {
        super.M();
        this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
      }
    };
    t(E, v);
    Jb = [];
    E.prototype.M = function() {
      E.Z.M.call(this);
      Lb(this);
    };
    E.prototype.handleEvent = function() {
      throw Error("EventHandler.handleEvent not implemented");
    };
    Mb.prototype.Aa = function() {
      this.g = false;
    };
    Mb.prototype.info = function() {
    };
    H$1 = {};
    Rb = null;
    H$1.Ma = "serverreachability";
    t(Tb, z);
    H$1.STAT_EVENT = "statevent";
    t(Ub, z);
    H$1.Na = "timingevent";
    t(Vb, z);
    Wb = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, Ja: 7, TIMEOUT: 8, Cb: 9 };
    Xb = { qb: "complete", Mb: "success", Ka: "error", Ja: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" };
    Yb.prototype.h = null;
    L$1 = { OPEN: "a", pb: "b", Ka: "c", Bb: "d" };
    t(ac$1, z);
    t(bc, z);
    t(dc$1, Yb);
    dc$1.prototype.g = function() {
      return new XMLHttpRequest();
    };
    dc$1.prototype.i = function() {
      return {};
    };
    cc$1 = new dc$1();
    ec$1 = 45e3;
    gc$1 = {};
    hc$1 = {};
    k = M$1.prototype;
    k.setTimeout = function(a) {
      this.P = a;
    };
    k.gb = function(a) {
      a = a.target;
      const b = this.L;
      b && O$1(a) == 3 ? b.l() : this.Ia(a);
    };
    k.Ia = function(a) {
      try {
        if (a == this.g)
          a: {
            const r = O$1(this.g);
            var b = this.g.Da();
            const G2 = this.g.ba();
            if (!(3 > r) && (r != 3 || Ja$1 || this.g && (this.h.h || this.g.ga() || oc$1(this.g)))) {
              this.I || r != 4 || b == 7 || (b == 8 || 0 >= G2 ? I(3) : I(2));
              pc$1(this);
              var c = this.g.ba();
              this.N = c;
              b:
                if (qc(this)) {
                  var d2 = oc$1(this.g);
                  a = "";
                  var e = d2.length, f = O$1(this.g) == 4;
                  if (!this.h.i) {
                    if (typeof TextDecoder === "undefined") {
                      P(this);
                      rc$1(this);
                      var h = "";
                      break b;
                    }
                    this.h.i = new l.TextDecoder();
                  }
                  for (b = 0; b < e; b++)
                    this.h.h = true, a += this.h.i.decode(d2[b], { stream: f && b == e - 1 });
                  d2.splice(0, e);
                  this.h.g += a;
                  this.C = 0;
                  h = this.h.g;
                } else
                  h = this.g.ga();
              this.i = c == 200;
              Ob(this.j, this.u, this.A, this.m, this.X, r, c);
              if (this.i) {
                if (this.$ && !this.J) {
                  b: {
                    if (this.g) {
                      var n, u = this.g;
                      if ((n = u.g ? u.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa(n)) {
                        var m = n;
                        break b;
                      }
                    }
                    m = null;
                  }
                  if (c = m)
                    F$1(this.j, this.m, c, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, sc$1(this, c);
                  else {
                    this.i = false;
                    this.o = 3;
                    J$1(12);
                    P(this);
                    rc$1(this);
                    break a;
                  }
                }
                this.U ? (tc$1(this, r, h), Ja$1 && this.i && r == 3 && (Kb(this.V, this.W, "tick", this.fb), this.W.start())) : (F$1(this.j, this.m, h, null), sc$1(this, h));
                r == 4 && P(this);
                this.i && !this.I && (r == 4 ? uc$1(this.l, this) : (this.i = false, lc(this)));
              } else
                c == 400 && 0 < h.indexOf("Unknown SID") ? (this.o = 3, J$1(12)) : (this.o = 0, J$1(13)), P(this), rc$1(this);
            }
          }
      } catch (r) {
      } finally {
      }
    };
    k.fb = function() {
      if (this.g) {
        var a = O$1(this.g), b = this.g.ga();
        this.C < b.length && (pc$1(this), tc$1(this, a, b), this.i && a != 4 && lc(this));
      }
    };
    k.cancel = function() {
      this.I = true;
      P(this);
    };
    k.eb = function() {
      this.B = null;
      const a = Date.now();
      0 <= a - this.Y ? (Qb(this.j, this.A), this.K != 2 && (I(3), J$1(17)), P(this), this.o = 2, rc$1(this)) : xc(this, this.Y - a);
    };
    k = S$1.prototype;
    k.R = function() {
      Lc$1(this);
      for (var a = [], b = 0; b < this.g.length; b++)
        a.push(this.h[this.g[b]]);
      return a;
    };
    k.T = function() {
      Lc$1(this);
      return this.g.concat();
    };
    k.get = function(a, b) {
      return T(this.h, a) ? this.h[a] : b;
    };
    k.set = function(a, b) {
      T(this.h, a) || (this.i++, this.g.push(a));
      this.h[a] = b;
    };
    k.forEach = function(a, b) {
      for (var c = this.T(), d2 = 0; d2 < c.length; d2++) {
        var e = c[d2], f = this.get(e);
        a.call(b, f, e, this);
      }
    };
    Mc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
    U.prototype.toString = function() {
      var a = [], b = this.j;
      b && a.push(Uc(b, Vc, true), ":");
      var c = this.i;
      if (c || b == "file")
        a.push("//"), (b = this.s) && a.push(Uc(b, Vc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.m, c != null && a.push(":", String(c));
      if (c = this.l)
        this.i && c.charAt(0) != "/" && a.push("/"), a.push(Uc(c, c.charAt(0) == "/" ? Wc$1 : Xc$1, true));
      (c = this.h.toString()) && a.push("?", c);
      (c = this.o) && a.push("#", Uc(c, Yc$1));
      return a.join("");
    };
    Vc = /[#\/\?@]/g;
    Xc$1 = /[#\?:]/g;
    Wc$1 = /[#\?]/g;
    $c = /[#\?@]/g;
    Yc$1 = /#/g;
    k = Rc.prototype;
    k.add = function(a, b) {
      V(this);
      this.i = null;
      a = W$1(this, a);
      var c = this.g.get(a);
      c || this.g.set(a, c = []);
      c.push(b);
      this.h += 1;
      return this;
    };
    k.forEach = function(a, b) {
      V(this);
      this.g.forEach(function(c, d2) {
        na$1(c, function(e) {
          a.call(b, e, d2, this);
        }, this);
      }, this);
    };
    k.T = function() {
      V(this);
      for (var a = this.g.R(), b = this.g.T(), c = [], d2 = 0; d2 < b.length; d2++)
        for (var e = a[d2], f = 0; f < e.length; f++)
          c.push(b[d2]);
      return c;
    };
    k.R = function(a) {
      V(this);
      var b = [];
      if (typeof a === "string")
        ed(this, a) && (b = qa(b, this.g.get(W$1(this, a))));
      else {
        a = this.g.R();
        for (var c = 0; c < a.length; c++)
          b = qa(b, a[c]);
      }
      return b;
    };
    k.set = function(a, b) {
      V(this);
      this.i = null;
      a = W$1(this, a);
      ed(this, a) && (this.h -= this.g.get(a).length);
      this.g.set(a, [b]);
      this.h += 1;
      return this;
    };
    k.get = function(a, b) {
      if (!a)
        return b;
      a = this.R(a);
      return 0 < a.length ? String(a[0]) : b;
    };
    k.toString = function() {
      if (this.i)
        return this.i;
      if (!this.g)
        return "";
      for (var a = [], b = this.g.T(), c = 0; c < b.length; c++) {
        var d2 = b[c], e = encodeURIComponent(String(d2));
        d2 = this.R(d2);
        for (var f = 0; f < d2.length; f++) {
          var h = e;
          d2[f] !== "" && (h += "=" + encodeURIComponent(String(d2[f])));
          a.push(h);
        }
      }
      return this.i = a.join("&");
    };
    fd = class {
      constructor(a, b) {
        this.h = a;
        this.g = b;
      }
    };
    hd = 10;
    gd.prototype.cancel = function() {
      this.i = jd(this);
      if (this.h)
        this.h.cancel(), this.h = null;
      else if (this.g && this.g.size !== 0) {
        for (const a of this.g.values())
          a.cancel();
        this.g.clear();
      }
    };
    kd.prototype.stringify = function(a) {
      return l.JSON.stringify(a, void 0);
    };
    kd.prototype.parse = function(a) {
      return l.JSON.parse(a, void 0);
    };
    t(pd, Yb);
    pd.prototype.g = function() {
      return new qd(this.l, this.j);
    };
    pd.prototype.i = function(a) {
      return function() {
        return a;
      };
    }({});
    t(qd, C$1);
    rd = 0;
    k = qd.prototype;
    k.open = function(a, b) {
      if (this.readyState != rd)
        throw this.abort(), Error("Error reopening a connection");
      this.C = a;
      this.B = b;
      this.readyState = 1;
      sd(this);
    };
    k.send = function(a) {
      if (this.readyState != 1)
        throw this.abort(), Error("need to call open() first. ");
      this.g = true;
      const b = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
      a && (b.body = a);
      (this.D || l).fetch(new Request(this.B, b)).then(this.Va.bind(this), this.ha.bind(this));
    };
    k.abort = function() {
      this.response = this.responseText = "";
      this.v = new Headers();
      this.status = 0;
      this.j && this.j.cancel("Request was aborted.");
      1 <= this.readyState && this.g && this.readyState != 4 && (this.g = false, td(this));
      this.readyState = rd;
    };
    k.Va = function(a) {
      if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, sd(this)), this.g && (this.readyState = 3, sd(this), this.g)))
        if (this.responseType === "arraybuffer")
          a.arrayBuffer().then(this.Ta.bind(this), this.ha.bind(this));
        else if (typeof l.ReadableStream !== "undefined" && "body" in a) {
          this.j = a.body.getReader();
          if (this.u) {
            if (this.responseType)
              throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
            this.response = [];
          } else
            this.response = this.responseText = "", this.A = new TextDecoder();
          ud(this);
        } else
          a.text().then(this.Ua.bind(this), this.ha.bind(this));
    };
    k.Sa = function(a) {
      if (this.g) {
        if (this.u && a.value)
          this.response.push(a.value);
        else if (!this.u) {
          var b = a.value ? a.value : new Uint8Array(0);
          if (b = this.A.decode(b, { stream: !a.done }))
            this.response = this.responseText += b;
        }
        a.done ? td(this) : sd(this);
        this.readyState == 3 && ud(this);
      }
    };
    k.Ua = function(a) {
      this.g && (this.response = this.responseText = a, td(this));
    };
    k.Ta = function(a) {
      this.g && (this.response = a, td(this));
    };
    k.ha = function() {
      this.g && td(this);
    };
    k.setRequestHeader = function(a, b) {
      this.v.append(a, b);
    };
    k.getResponseHeader = function(a) {
      return this.h ? this.h.get(a.toLowerCase()) || "" : "";
    };
    k.getAllResponseHeaders = function() {
      if (!this.h)
        return "";
      const a = [], b = this.h.entries();
      for (var c = b.next(); !c.done; )
        c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
      return a.join("\r\n");
    };
    Object.defineProperty(qd.prototype, "withCredentials", { get: function() {
      return this.m === "include";
    }, set: function(a) {
      this.m = a ? "include" : "same-origin";
    } });
    vd = l.JSON.parse;
    t(X$1, C$1);
    wd = "";
    xd = /^https?$/i;
    yd = ["POST", "PUT"];
    k = X$1.prototype;
    k.ea = function(a, b, c, d2) {
      if (this.g)
        throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a);
      b = b ? b.toUpperCase() : "GET";
      this.H = a;
      this.j = "";
      this.m = 0;
      this.D = false;
      this.h = true;
      this.g = this.u ? this.u.g() : cc$1.g();
      this.C = this.u ? Zb(this.u) : Zb(cc$1);
      this.g.onreadystatechange = q$1(this.Fa, this);
      try {
        this.F = true, this.g.open(b, String(a), true), this.F = false;
      } catch (f) {
        zd(this, f);
        return;
      }
      a = c || "";
      const e = new S$1(this.headers);
      d2 && Kc$1(d2, function(f, h) {
        e.set(h, f);
      });
      d2 = oa(e.T());
      c = l.FormData && a instanceof l.FormData;
      !(0 <= ma$1(yd, b)) || d2 || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
      e.forEach(function(f, h) {
        this.g.setRequestHeader(h, f);
      }, this);
      this.J && (this.g.responseType = this.J);
      "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
      try {
        Ad(this), 0 < this.B && ((this.K = Bd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q$1(this.pa, this)) : this.A = Gb(this.pa, this.B, this)), this.v = true, this.g.send(a), this.v = false;
      } catch (f) {
        zd(this, f);
      }
    };
    k.pa = function() {
      typeof goog != "undefined" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, D$1(this, "timeout"), this.abort(8));
    };
    k.abort = function(a) {
      this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a || 7, D$1(this, "complete"), D$1(this, "abort"), Dd(this));
    };
    k.M = function() {
      this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Dd(this, true));
      X$1.Z.M.call(this);
    };
    k.Fa = function() {
      this.s || (this.F || this.v || this.l ? Ed(this) : this.cb());
    };
    k.cb = function() {
      Ed(this);
    };
    k.ba = function() {
      try {
        return 2 < O$1(this) ? this.g.status : -1;
      } catch (a) {
        return -1;
      }
    };
    k.ga = function() {
      try {
        return this.g ? this.g.responseText : "";
      } catch (a) {
        return "";
      }
    };
    k.Qa = function(a) {
      if (this.g) {
        var b = this.g.responseText;
        a && b.indexOf(a) == 0 && (b = b.substring(a.length));
        return vd(b);
      }
    };
    k.Da = function() {
      return this.m;
    };
    k.La = function() {
      return typeof this.j === "string" ? this.j : String(this.j);
    };
    k = Id.prototype;
    k.ma = 8;
    k.G = 1;
    k.hb = function(a) {
      try {
        this.h.info("Origin Trials invoked: " + a);
      } catch (b) {
      }
    };
    k.Ha = function(a) {
      if (this.m)
        if (this.m = null, this.G == 1) {
          if (!a) {
            this.V = Math.floor(1e5 * Math.random());
            a = this.V++;
            const e = new M$1(this, this.h, a, void 0);
            let f = this.s;
            this.P && (f ? (f = ya(f), Aa$1(f, this.P)) : f = this.P);
            this.o === null && (e.H = f);
            if (this.ja)
              a: {
                var b = 0;
                for (var c = 0; c < this.l.length; c++) {
                  b: {
                    var d2 = this.l[c];
                    if ("__data__" in d2.g && (d2 = d2.g.__data__, typeof d2 === "string")) {
                      d2 = d2.length;
                      break b;
                    }
                    d2 = void 0;
                  }
                  if (d2 === void 0)
                    break;
                  b += d2;
                  if (4096 < b) {
                    b = c;
                    break a;
                  }
                  if (b === 4096 || c === this.l.length - 1) {
                    b = c + 1;
                    break a;
                  }
                }
                b = 1e3;
              }
            else
              b = 1e3;
            b = Pd(this, e, b);
            c = N$1(this.F);
            R(c, "RID", a);
            R(c, "CVER", 22);
            this.D && R(c, "X-HTTP-Session-Id", this.D);
            Kd(this, c);
            this.o && f && Gd(c, this.o, f);
            Dc(this.i, e);
            this.Ra && R(c, "TYPE", "init");
            this.ja ? (R(c, "$req", b), R(c, "SID", "null"), e.$ = true, ic$1(e, c, null)) : ic$1(e, c, b);
            this.G = 2;
          }
        } else
          this.G == 3 && (a ? Qd(this, a) : this.l.length == 0 || id(this.i) || Qd(this));
    };
    k.Ga = function() {
      this.u = null;
      Rd(this);
      if (this.$ && !(this.L || this.g == null || 0 >= this.O)) {
        var a = 2 * this.O;
        this.h.info("BP detection timer enabled: " + a);
        this.B = K$1(q$1(this.bb, this), a);
      }
    };
    k.bb = function() {
      this.B && (this.B = null, this.h.info("BP detection timeout reached."), this.h.info("Buffering proxy detected and switch to long-polling!"), this.N = false, this.L = true, J$1(10), Ac(this), Rd(this));
    };
    k.ab = function() {
      this.v != null && (this.v = null, Ac(this), Bc(this), J$1(19));
    };
    k.jb = function(a) {
      a ? (this.h.info("Successfully pinged google.com"), J$1(2)) : (this.h.info("Failed to ping google.com"), J$1(1));
    };
    k = Sd.prototype;
    k.xa = function() {
    };
    k.wa = function() {
    };
    k.va = function() {
    };
    k.ua = function() {
    };
    k.Oa = function() {
    };
    Td.prototype.g = function(a, b) {
      return new Y$1(a, b);
    };
    t(Y$1, C$1);
    Y$1.prototype.m = function() {
      this.g.j = this.j;
      this.A && (this.g.H = true);
      var a = this.g, b = this.l, c = this.h || void 0;
      a.Wa && (a.h.info("Origin Trials enabled."), zb(q$1(a.hb, a, b)));
      J$1(0);
      a.W = b;
      a.aa = c || {};
      a.N = a.X;
      a.F = Ec$1(a, null, a.W);
      Hc(a);
    };
    Y$1.prototype.close = function() {
      Ic(this.g);
    };
    Y$1.prototype.u = function(a) {
      if (typeof a === "string") {
        var b = {};
        b.__data__ = a;
        Md(this.g, b);
      } else
        this.v ? (b = {}, b.__data__ = rb(a), Md(this.g, b)) : Md(this.g, a);
    };
    Y$1.prototype.M = function() {
      this.g.j = null;
      delete this.j;
      Ic(this.g);
      delete this.g;
      Y$1.Z.M.call(this);
    };
    t(Ud, ac$1);
    t(Vd, bc);
    t(Z$1, Sd);
    Z$1.prototype.xa = function() {
      D$1(this.g, "a");
    };
    Z$1.prototype.wa = function(a) {
      D$1(this.g, new Ud(a));
    };
    Z$1.prototype.va = function(a) {
      D$1(this.g, new Vd(a));
    };
    Z$1.prototype.ua = function() {
      D$1(this.g, "b");
    };
    Td.prototype.createWebChannel = Td.prototype.g;
    Y$1.prototype.send = Y$1.prototype.u;
    Y$1.prototype.open = Y$1.prototype.m;
    Y$1.prototype.close = Y$1.prototype.close;
    Wb.NO_ERROR = 0;
    Wb.TIMEOUT = 8;
    Wb.HTTP_ERROR = 6;
    Xb.COMPLETE = "complete";
    $b.EventType = L$1;
    L$1.OPEN = "a";
    L$1.CLOSE = "b";
    L$1.ERROR = "c";
    L$1.MESSAGE = "d";
    C$1.prototype.listen = C$1.prototype.N;
    X$1.prototype.listenOnce = X$1.prototype.O;
    X$1.prototype.getLastError = X$1.prototype.La;
    X$1.prototype.getLastErrorCode = X$1.prototype.Da;
    X$1.prototype.getStatus = X$1.prototype.ba;
    X$1.prototype.getResponseJson = X$1.prototype.Qa;
    X$1.prototype.getResponseText = X$1.prototype.ga;
    X$1.prototype.send = X$1.prototype.ea;
    createWebChannelTransport = function() {
      return new Td();
    };
    getStatEventTarget = function() {
      return Sb();
    };
    ErrorCode = Wb;
    EventType = Xb;
    Event2 = H$1;
    Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 };
    FetchXmlHttpFactory = pd;
    WebChannel = $b;
    XhrIo = X$1;
    S = "@firebase/firestore";
    D = class {
      constructor(t2) {
        this.uid = t2;
      }
      isAuthenticated() {
        return this.uid != null;
      }
      toKey() {
        return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
      }
      isEqual(t2) {
        return t2.uid === this.uid;
      }
    };
    D.UNAUTHENTICATED = new D(null), D.GOOGLE_CREDENTIALS = new D("google-credentials-uid"), D.FIRST_PARTY = new D("first-party-uid"), D.MOCK_USER = new D("mock-user");
    C = "9.5.0";
    N = new Logger("@firebase/firestore");
    K = {
      OK: "ok",
      CANCELLED: "cancelled",
      UNKNOWN: "unknown",
      INVALID_ARGUMENT: "invalid-argument",
      DEADLINE_EXCEEDED: "deadline-exceeded",
      NOT_FOUND: "not-found",
      ALREADY_EXISTS: "already-exists",
      PERMISSION_DENIED: "permission-denied",
      UNAUTHENTICATED: "unauthenticated",
      RESOURCE_EXHAUSTED: "resource-exhausted",
      FAILED_PRECONDITION: "failed-precondition",
      ABORTED: "aborted",
      OUT_OF_RANGE: "out-of-range",
      UNIMPLEMENTED: "unimplemented",
      INTERNAL: "internal",
      UNAVAILABLE: "unavailable",
      DATA_LOSS: "data-loss"
    };
    j = class extends Error {
      constructor(t2, e) {
        super(e), this.code = t2, this.message = e, this.name = "FirebaseError", this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
      }
    };
    Q = class {
      constructor() {
        this.promise = new Promise((t2, e) => {
          this.resolve = t2, this.reject = e;
        });
      }
    };
    W = class {
      constructor(t2, e) {
        this.user = e, this.type = "OAuth", this.authHeaders = {}, this.authHeaders.Authorization = `Bearer ${t2}`;
      }
    };
    G = class {
      getToken() {
        return Promise.resolve(null);
      }
      invalidateToken() {
      }
      start(t2, e) {
        t2.enqueueRetryable(() => e(D.UNAUTHENTICATED));
      }
      shutdown() {
      }
    };
    H = class {
      constructor(t2) {
        this.t = t2, this.currentUser = D.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
      }
      start(t2, e) {
        let n = this.i;
        const s2 = (t3) => this.i !== n ? (n = this.i, e(t3)) : Promise.resolve();
        let i = new Q();
        this.o = () => {
          this.i++, this.currentUser = this.u(), i.resolve(), i = new Q(), t2.enqueueRetryable(() => s2(this.currentUser));
        };
        const r = () => {
          const e2 = i;
          t2.enqueueRetryable(async () => {
            await e2.promise, await s2(this.currentUser);
          });
        }, o = (t3) => {
          $("FirebaseCredentialsProvider", "Auth detected"), this.auth = t3, this.auth.addAuthTokenListener(this.o), r();
        };
        this.t.onInit((t3) => o(t3)), setTimeout(() => {
          if (!this.auth) {
            const t3 = this.t.getImmediate({
              optional: true
            });
            t3 ? o(t3) : ($("FirebaseCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new Q());
          }
        }, 0), r();
      }
      getToken() {
        const t2 = this.i, e = this.forceRefresh;
        return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.i !== t2 ? ($("FirebaseCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (B(typeof e2.accessToken == "string"), new W(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
      }
      invalidateToken() {
        this.forceRefresh = true;
      }
      shutdown() {
        this.auth && this.auth.removeAuthTokenListener(this.o);
      }
      u() {
        const t2 = this.auth && this.auth.getUid();
        return B(t2 === null || typeof t2 == "string"), new D(t2);
      }
    };
    J = class {
      constructor(t2, e, n) {
        this.h = t2, this.l = e, this.m = n, this.type = "FirstParty", this.user = D.FIRST_PARTY;
      }
      get authHeaders() {
        const t2 = {
          "X-Goog-AuthUser": this.l
        }, e = this.h.auth.getAuthHeaderValueForFirstParty([]);
        return e && (t2.Authorization = e), this.m && (t2["X-Goog-Iam-Authorization-Token"] = this.m), t2;
      }
    };
    Y = class {
      constructor(t2, e, n) {
        this.h = t2, this.l = e, this.m = n;
      }
      getToken() {
        return Promise.resolve(new J(this.h, this.l, this.m));
      }
      start(t2, e) {
        t2.enqueueRetryable(() => e(D.FIRST_PARTY));
      }
      shutdown() {
      }
      invalidateToken() {
      }
    };
    X = class {
      constructor(t2, e) {
        this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.g(t3), this.p = (t3) => e.writeSequenceNumber(t3));
      }
      g(t2) {
        return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
      }
      next() {
        const t2 = ++this.previousValue;
        return this.p && this.p(t2), t2;
      }
    };
    X.T = -1;
    tt = class {
      static I() {
        const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
        let n = "";
        for (; n.length < 20; ) {
          const s2 = Z(40);
          for (let i = 0; i < s2.length; ++i)
            n.length < 20 && s2[i] < e && (n += t2.charAt(s2[i] % t2.length));
        }
        return n;
      }
    };
    it = class {
      constructor(t2, e) {
        if (this.seconds = t2, this.nanoseconds = e, e < 0)
          throw new j(K.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
        if (e >= 1e9)
          throw new j(K.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
        if (t2 < -62135596800)
          throw new j(K.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
        if (t2 >= 253402300800)
          throw new j(K.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
      }
      static now() {
        return it.fromMillis(Date.now());
      }
      static fromDate(t2) {
        return it.fromMillis(t2.getTime());
      }
      static fromMillis(t2) {
        const e = Math.floor(t2 / 1e3), n = Math.floor(1e6 * (t2 - 1e3 * e));
        return new it(e, n);
      }
      toDate() {
        return new Date(this.toMillis());
      }
      toMillis() {
        return 1e3 * this.seconds + this.nanoseconds / 1e6;
      }
      _compareTo(t2) {
        return this.seconds === t2.seconds ? et(this.nanoseconds, t2.nanoseconds) : et(this.seconds, t2.seconds);
      }
      isEqual(t2) {
        return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
      }
      toString() {
        return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
      }
      toJSON() {
        return {
          seconds: this.seconds,
          nanoseconds: this.nanoseconds
        };
      }
      valueOf() {
        const t2 = this.seconds - -62135596800;
        return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
      }
    };
    rt = class {
      constructor(t2) {
        this.timestamp = t2;
      }
      static fromTimestamp(t2) {
        return new rt(t2);
      }
      static min() {
        return new rt(new it(0, 0));
      }
      compareTo(t2) {
        return this.timestamp._compareTo(t2.timestamp);
      }
      isEqual(t2) {
        return this.timestamp.isEqual(t2.timestamp);
      }
      toMicroseconds() {
        return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
      }
      toString() {
        return "SnapshotVersion(" + this.timestamp.toString() + ")";
      }
      toTimestamp() {
        return this.timestamp;
      }
    };
    ut = class {
      constructor(t2, e, n) {
        e === void 0 ? e = 0 : e > t2.length && L(), n === void 0 ? n = t2.length - e : n > t2.length - e && L(), this.segments = t2, this.offset = e, this.len = n;
      }
      get length() {
        return this.len;
      }
      isEqual(t2) {
        return ut.comparator(this, t2) === 0;
      }
      child(t2) {
        const e = this.segments.slice(this.offset, this.limit());
        return t2 instanceof ut ? t2.forEach((t3) => {
          e.push(t3);
        }) : e.push(t2), this.construct(e);
      }
      limit() {
        return this.offset + this.length;
      }
      popFirst(t2) {
        return t2 = t2 === void 0 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
      }
      popLast() {
        return this.construct(this.segments, this.offset, this.length - 1);
      }
      firstSegment() {
        return this.segments[this.offset];
      }
      lastSegment() {
        return this.get(this.length - 1);
      }
      get(t2) {
        return this.segments[this.offset + t2];
      }
      isEmpty() {
        return this.length === 0;
      }
      isPrefixOf(t2) {
        if (t2.length < this.length)
          return false;
        for (let e = 0; e < this.length; e++)
          if (this.get(e) !== t2.get(e))
            return false;
        return true;
      }
      isImmediateParentOf(t2) {
        if (this.length + 1 !== t2.length)
          return false;
        for (let e = 0; e < this.length; e++)
          if (this.get(e) !== t2.get(e))
            return false;
        return true;
      }
      forEach(t2) {
        for (let e = this.offset, n = this.limit(); e < n; e++)
          t2(this.segments[e]);
      }
      toArray() {
        return this.segments.slice(this.offset, this.limit());
      }
      static comparator(t2, e) {
        const n = Math.min(t2.length, e.length);
        for (let s2 = 0; s2 < n; s2++) {
          const n2 = t2.get(s2), i = e.get(s2);
          if (n2 < i)
            return -1;
          if (n2 > i)
            return 1;
        }
        return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
      }
    };
    ht = class extends ut {
      construct(t2, e, n) {
        return new ht(t2, e, n);
      }
      canonicalString() {
        return this.toArray().join("/");
      }
      toString() {
        return this.canonicalString();
      }
      static fromString(...t2) {
        const e = [];
        for (const n of t2) {
          if (n.indexOf("//") >= 0)
            throw new j(K.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
          e.push(...n.split("/").filter((t3) => t3.length > 0));
        }
        return new ht(e);
      }
      static emptyPath() {
        return new ht([]);
      }
    };
    lt = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
    ft = class extends ut {
      construct(t2, e, n) {
        return new ft(t2, e, n);
      }
      static isValidIdentifier(t2) {
        return lt.test(t2);
      }
      canonicalString() {
        return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), ft.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
      }
      toString() {
        return this.canonicalString();
      }
      isKeyField() {
        return this.length === 1 && this.get(0) === "__name__";
      }
      static keyField() {
        return new ft(["__name__"]);
      }
      static fromServerFormat(t2) {
        const e = [];
        let n = "", s2 = 0;
        const i = () => {
          if (n.length === 0)
            throw new j(K.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
          e.push(n), n = "";
        };
        let r = false;
        for (; s2 < t2.length; ) {
          const e2 = t2[s2];
          if (e2 === "\\") {
            if (s2 + 1 === t2.length)
              throw new j(K.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
            const e3 = t2[s2 + 1];
            if (e3 !== "\\" && e3 !== "." && e3 !== "`")
              throw new j(K.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
            n += e3, s2 += 2;
          } else
            e2 === "`" ? (r = !r, s2++) : e2 !== "." || r ? (n += e2, s2++) : (i(), s2++);
        }
        if (i(), r)
          throw new j(K.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
        return new ft(e);
      }
      static emptyPath() {
        return new ft([]);
      }
    };
    dt = class {
      constructor(t2) {
        this.fields = t2, t2.sort(ft.comparator);
      }
      covers(t2) {
        for (const e of this.fields)
          if (e.isPrefixOf(t2))
            return true;
        return false;
      }
      isEqual(t2) {
        return nt(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
      }
    };
    _t = class {
      constructor(t2) {
        this.binaryString = t2;
      }
      static fromBase64String(t2) {
        const e = atob(t2);
        return new _t(e);
      }
      static fromUint8Array(t2) {
        const e = function(t3) {
          let e2 = "";
          for (let n = 0; n < t3.length; ++n)
            e2 += String.fromCharCode(t3[n]);
          return e2;
        }(t2);
        return new _t(e);
      }
      toBase64() {
        return t2 = this.binaryString, btoa(t2);
        var t2;
      }
      toUint8Array() {
        return function(t2) {
          const e = new Uint8Array(t2.length);
          for (let n = 0; n < t2.length; n++)
            e[n] = t2.charCodeAt(n);
          return e;
        }(this.binaryString);
      }
      approximateByteSize() {
        return 2 * this.binaryString.length;
      }
      compareTo(t2) {
        return et(this.binaryString, t2.binaryString);
      }
      isEqual(t2) {
        return this.binaryString === t2.binaryString;
      }
    };
    _t.EMPTY_BYTE_STRING = new _t("");
    mt = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
    Pt = class {
      constructor(t2) {
        this.path = t2;
      }
      static fromPath(t2) {
        return new Pt(ht.fromString(t2));
      }
      static fromName(t2) {
        return new Pt(ht.fromString(t2).popFirst(5));
      }
      hasCollectionId(t2) {
        return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
      }
      isEqual(t2) {
        return t2 !== null && ht.comparator(this.path, t2.path) === 0;
      }
      toString() {
        return this.path.toString();
      }
      static comparator(t2, e) {
        return ht.comparator(t2.path, e.path);
      }
      static isDocumentKey(t2) {
        return t2.length % 2 == 0;
      }
      static fromSegments(t2) {
        return new Pt(new ht(t2.slice()));
      }
    };
    Ut = class {
      constructor(t2) {
        this.value = t2;
      }
      static empty() {
        return new Ut({
          mapValue: {}
        });
      }
      field(t2) {
        if (t2.isEmpty())
          return this.value;
        {
          let e = this.value;
          for (let n = 0; n < t2.length - 1; ++n)
            if (e = (e.mapValue.fields || {})[t2.get(n)], !Lt(e))
              return null;
          return e = (e.mapValue.fields || {})[t2.lastSegment()], e || null;
        }
      }
      set(t2, e) {
        this.getFieldsMap(t2.popLast())[t2.lastSegment()] = Bt(e);
      }
      setAll(t2) {
        let e = ft.emptyPath(), n = {}, s2 = [];
        t2.forEach((t3, i2) => {
          if (!e.isImmediateParentOf(i2)) {
            const t4 = this.getFieldsMap(e);
            this.applyChanges(t4, n, s2), n = {}, s2 = [], e = i2.popLast();
          }
          t3 ? n[i2.lastSegment()] = Bt(t3) : s2.push(i2.lastSegment());
        });
        const i = this.getFieldsMap(e);
        this.applyChanges(i, n, s2);
      }
      delete(t2) {
        const e = this.field(t2.popLast());
        Lt(e) && e.mapValue.fields && delete e.mapValue.fields[t2.lastSegment()];
      }
      isEqual(t2) {
        return Vt(this.value, t2.value);
      }
      getFieldsMap(t2) {
        let e = this.value;
        e.mapValue.fields || (e.mapValue = {
          fields: {}
        });
        for (let n = 0; n < t2.length; ++n) {
          let s2 = e.mapValue.fields[t2.get(n)];
          Lt(s2) && s2.mapValue.fields || (s2 = {
            mapValue: {
              fields: {}
            }
          }, e.mapValue.fields[t2.get(n)] = s2), e = s2;
        }
        return e.mapValue.fields;
      }
      applyChanges(t2, e, n) {
        ct(e, (e2, n2) => t2[e2] = n2);
        for (const e2 of n)
          delete t2[e2];
      }
      clone() {
        return new Ut(Bt(this.value));
      }
    };
    Kt = class {
      constructor(t2, e, n, s2, i) {
        this.key = t2, this.documentType = e, this.version = n, this.data = s2, this.documentState = i;
      }
      static newInvalidDocument(t2) {
        return new Kt(t2, 0, rt.min(), Ut.empty(), 0);
      }
      static newFoundDocument(t2, e, n) {
        return new Kt(t2, 1, e, n, 0);
      }
      static newNoDocument(t2, e) {
        return new Kt(t2, 2, e, Ut.empty(), 0);
      }
      static newUnknownDocument(t2, e) {
        return new Kt(t2, 3, e, Ut.empty(), 2);
      }
      convertToFoundDocument(t2, e) {
        return this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
      }
      convertToNoDocument(t2) {
        return this.version = t2, this.documentType = 2, this.data = Ut.empty(), this.documentState = 0, this;
      }
      convertToUnknownDocument(t2) {
        return this.version = t2, this.documentType = 3, this.data = Ut.empty(), this.documentState = 2, this;
      }
      setHasCommittedMutations() {
        return this.documentState = 2, this;
      }
      setHasLocalMutations() {
        return this.documentState = 1, this;
      }
      get hasLocalMutations() {
        return this.documentState === 1;
      }
      get hasCommittedMutations() {
        return this.documentState === 2;
      }
      get hasPendingWrites() {
        return this.hasLocalMutations || this.hasCommittedMutations;
      }
      isValidDocument() {
        return this.documentType !== 0;
      }
      isFoundDocument() {
        return this.documentType === 1;
      }
      isNoDocument() {
        return this.documentType === 2;
      }
      isUnknownDocument() {
        return this.documentType === 3;
      }
      isEqual(t2) {
        return t2 instanceof Kt && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
      }
      clone() {
        return new Kt(this.key, this.documentType, this.version, this.data.clone(), this.documentState);
      }
      toString() {
        return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
      }
    };
    jt = class {
      constructor(t2, e = null, n = [], s2 = [], i = null, r = null, o = null) {
        this.path = t2, this.collectionGroup = e, this.orderBy = n, this.filters = s2, this.limit = i, this.startAt = r, this.endAt = o, this.A = null;
      }
    };
    Jt = class extends class {
    } {
      constructor(t2, e, n) {
        super(), this.field = t2, this.op = e, this.value = n;
      }
      static create(t2, e, n) {
        return t2.isKeyField() ? e === "in" || e === "not-in" ? this.R(t2, e, n) : new Xt(t2, e, n) : e === "array-contains" ? new ne(t2, n) : e === "in" ? new se(t2, n) : e === "not-in" ? new ie(t2, n) : e === "array-contains-any" ? new re(t2, n) : new Jt(t2, e, n);
      }
      static R(t2, e, n) {
        return e === "in" ? new Zt(t2, n) : new te(t2, n);
      }
      matches(t2) {
        const e = t2.data.field(this.field);
        return this.op === "!=" ? e !== null && this.P(Dt(e, this.value)) : e !== null && vt(this.value) === vt(e) && this.P(Dt(e, this.value));
      }
      P(t2) {
        switch (this.op) {
          case "<":
            return t2 < 0;
          case "<=":
            return t2 <= 0;
          case "==":
            return t2 === 0;
          case "!=":
            return t2 !== 0;
          case ">":
            return t2 > 0;
          case ">=":
            return t2 >= 0;
          default:
            return L();
        }
      }
      v() {
        return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
      }
    };
    Xt = class extends Jt {
      constructor(t2, e, n) {
        super(t2, e, n), this.key = Pt.fromName(n.referenceValue);
      }
      matches(t2) {
        const e = Pt.comparator(t2.key, this.key);
        return this.P(e);
      }
    };
    Zt = class extends Jt {
      constructor(t2, e) {
        super(t2, "in", e), this.keys = ee("in", e);
      }
      matches(t2) {
        return this.keys.some((e) => e.isEqual(t2.key));
      }
    };
    te = class extends Jt {
      constructor(t2, e) {
        super(t2, "not-in", e), this.keys = ee("not-in", e);
      }
      matches(t2) {
        return !this.keys.some((e) => e.isEqual(t2.key));
      }
    };
    ne = class extends Jt {
      constructor(t2, e) {
        super(t2, "array-contains", e);
      }
      matches(t2) {
        const e = t2.data.field(this.field);
        return Ot(e) && St(e.arrayValue, this.value);
      }
    };
    se = class extends Jt {
      constructor(t2, e) {
        super(t2, "in", e);
      }
      matches(t2) {
        const e = t2.data.field(this.field);
        return e !== null && St(this.value.arrayValue, e);
      }
    };
    ie = class extends Jt {
      constructor(t2, e) {
        super(t2, "not-in", e);
      }
      matches(t2) {
        if (St(this.value.arrayValue, {
          nullValue: "NULL_VALUE"
        }))
          return false;
        const e = t2.data.field(this.field);
        return e !== null && !St(this.value.arrayValue, e);
      }
    };
    re = class extends Jt {
      constructor(t2, e) {
        super(t2, "array-contains-any", e);
      }
      matches(t2) {
        const e = t2.data.field(this.field);
        return !(!Ot(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => St(this.value.arrayValue, t3));
      }
    };
    oe = class {
      constructor(t2, e) {
        this.position = t2, this.before = e;
      }
    };
    ae = class {
      constructor(t2, e = "asc") {
        this.field = t2, this.dir = e;
      }
    };
    fe = class {
      constructor(t2, e = null, n = [], s2 = [], i = null, r = "F", o = null, c = null) {
        this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s2, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = c, this.V = null, this.S = null, this.startAt, this.endAt;
      }
    };
    Ne = class {
      constructor() {
        this._ = void 0;
      }
    };
    Oe = class extends Ne {
    };
    Fe = class extends Ne {
      constructor(t2) {
        super(), this.elements = t2;
      }
    };
    Le = class extends Ne {
      constructor(t2) {
        super(), this.elements = t2;
      }
    };
    Ue = class extends Ne {
      constructor(t2, e) {
        super(), this.N = t2, this.C = e;
      }
    };
    je = class {
      constructor(t2, e) {
        this.field = t2, this.transform = e;
      }
    };
    We = class {
      constructor(t2, e) {
        this.version = t2, this.transformResults = e;
      }
    };
    Ge = class {
      constructor(t2, e) {
        this.updateTime = t2, this.exists = e;
      }
      static none() {
        return new Ge();
      }
      static exists(t2) {
        return new Ge(void 0, t2);
      }
      static updateTime(t2) {
        return new Ge(t2);
      }
      get isNone() {
        return this.updateTime === void 0 && this.exists === void 0;
      }
      isEqual(t2) {
        return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
      }
    };
    He = class {
    };
    en = class extends He {
      constructor(t2, e, n, s2 = []) {
        super(), this.key = t2, this.value = e, this.precondition = n, this.fieldTransforms = s2, this.type = 0;
      }
    };
    nn = class extends He {
      constructor(t2, e, n, s2, i = []) {
        super(), this.key = t2, this.data = e, this.fieldMask = n, this.precondition = s2, this.fieldTransforms = i, this.type = 1;
      }
    };
    cn = class extends He {
      constructor(t2, e) {
        super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
      }
    };
    an = class extends He {
      constructor(t2, e) {
        super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
      }
    };
    un = class {
      constructor(t2) {
        this.count = t2;
      }
    };
    (ln = hn || (hn = {}))[ln.OK = 0] = "OK", ln[ln.CANCELLED = 1] = "CANCELLED", ln[ln.UNKNOWN = 2] = "UNKNOWN", ln[ln.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", ln[ln.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", ln[ln.NOT_FOUND = 5] = "NOT_FOUND", ln[ln.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", ln[ln.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", ln[ln.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", ln[ln.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", ln[ln.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", ln[ln.ABORTED = 10] = "ABORTED", ln[ln.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", ln[ln.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", ln[ln.INTERNAL = 13] = "INTERNAL", ln[ln.UNAVAILABLE = 14] = "UNAVAILABLE", ln[ln.DATA_LOSS = 15] = "DATA_LOSS";
    wn = class {
      constructor(t2, e) {
        this.comparator = t2, this.root = e || mn.EMPTY;
      }
      insert(t2, e) {
        return new wn(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, mn.BLACK, null, null));
      }
      remove(t2) {
        return new wn(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, mn.BLACK, null, null));
      }
      get(t2) {
        let e = this.root;
        for (; !e.isEmpty(); ) {
          const n = this.comparator(t2, e.key);
          if (n === 0)
            return e.value;
          n < 0 ? e = e.left : n > 0 && (e = e.right);
        }
        return null;
      }
      indexOf(t2) {
        let e = 0, n = this.root;
        for (; !n.isEmpty(); ) {
          const s2 = this.comparator(t2, n.key);
          if (s2 === 0)
            return e + n.left.size;
          s2 < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
        }
        return -1;
      }
      isEmpty() {
        return this.root.isEmpty();
      }
      get size() {
        return this.root.size;
      }
      minKey() {
        return this.root.minKey();
      }
      maxKey() {
        return this.root.maxKey();
      }
      inorderTraversal(t2) {
        return this.root.inorderTraversal(t2);
      }
      forEach(t2) {
        this.inorderTraversal((e, n) => (t2(e, n), false));
      }
      toString() {
        const t2 = [];
        return this.inorderTraversal((e, n) => (t2.push(`${e}:${n}`), false)), `{${t2.join(", ")}}`;
      }
      reverseTraversal(t2) {
        return this.root.reverseTraversal(t2);
      }
      getIterator() {
        return new _n(this.root, null, this.comparator, false);
      }
      getIteratorFrom(t2) {
        return new _n(this.root, t2, this.comparator, false);
      }
      getReverseIterator() {
        return new _n(this.root, null, this.comparator, true);
      }
      getReverseIteratorFrom(t2) {
        return new _n(this.root, t2, this.comparator, true);
      }
    };
    _n = class {
      constructor(t2, e, n, s2) {
        this.isReverse = s2, this.nodeStack = [];
        let i = 1;
        for (; !t2.isEmpty(); )
          if (i = e ? n(t2.key, e) : 1, s2 && (i *= -1), i < 0)
            t2 = this.isReverse ? t2.left : t2.right;
          else {
            if (i === 0) {
              this.nodeStack.push(t2);
              break;
            }
            this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
          }
      }
      getNext() {
        let t2 = this.nodeStack.pop();
        const e = {
          key: t2.key,
          value: t2.value
        };
        if (this.isReverse)
          for (t2 = t2.left; !t2.isEmpty(); )
            this.nodeStack.push(t2), t2 = t2.right;
        else
          for (t2 = t2.right; !t2.isEmpty(); )
            this.nodeStack.push(t2), t2 = t2.left;
        return e;
      }
      hasNext() {
        return this.nodeStack.length > 0;
      }
      peek() {
        if (this.nodeStack.length === 0)
          return null;
        const t2 = this.nodeStack[this.nodeStack.length - 1];
        return {
          key: t2.key,
          value: t2.value
        };
      }
    };
    mn = class {
      constructor(t2, e, n, s2, i) {
        this.key = t2, this.value = e, this.color = n != null ? n : mn.RED, this.left = s2 != null ? s2 : mn.EMPTY, this.right = i != null ? i : mn.EMPTY, this.size = this.left.size + 1 + this.right.size;
      }
      copy(t2, e, n, s2, i) {
        return new mn(t2 != null ? t2 : this.key, e != null ? e : this.value, n != null ? n : this.color, s2 != null ? s2 : this.left, i != null ? i : this.right);
      }
      isEmpty() {
        return false;
      }
      inorderTraversal(t2) {
        return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
      }
      reverseTraversal(t2) {
        return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
      }
      min() {
        return this.left.isEmpty() ? this : this.left.min();
      }
      minKey() {
        return this.min().key;
      }
      maxKey() {
        return this.right.isEmpty() ? this.key : this.right.maxKey();
      }
      insert(t2, e, n) {
        let s2 = this;
        const i = n(t2, s2.key);
        return s2 = i < 0 ? s2.copy(null, null, null, s2.left.insert(t2, e, n), null) : i === 0 ? s2.copy(null, e, null, null, null) : s2.copy(null, null, null, null, s2.right.insert(t2, e, n)), s2.fixUp();
      }
      removeMin() {
        if (this.left.isEmpty())
          return mn.EMPTY;
        let t2 = this;
        return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
      }
      remove(t2, e) {
        let n, s2 = this;
        if (e(t2, s2.key) < 0)
          s2.left.isEmpty() || s2.left.isRed() || s2.left.left.isRed() || (s2 = s2.moveRedLeft()), s2 = s2.copy(null, null, null, s2.left.remove(t2, e), null);
        else {
          if (s2.left.isRed() && (s2 = s2.rotateRight()), s2.right.isEmpty() || s2.right.isRed() || s2.right.left.isRed() || (s2 = s2.moveRedRight()), e(t2, s2.key) === 0) {
            if (s2.right.isEmpty())
              return mn.EMPTY;
            n = s2.right.min(), s2 = s2.copy(n.key, n.value, null, null, s2.right.removeMin());
          }
          s2 = s2.copy(null, null, null, null, s2.right.remove(t2, e));
        }
        return s2.fixUp();
      }
      isRed() {
        return this.color;
      }
      fixUp() {
        let t2 = this;
        return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
      }
      moveRedLeft() {
        let t2 = this.colorFlip();
        return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
      }
      moveRedRight() {
        let t2 = this.colorFlip();
        return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
      }
      rotateLeft() {
        const t2 = this.copy(null, null, mn.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, t2, null);
      }
      rotateRight() {
        const t2 = this.copy(null, null, mn.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, t2);
      }
      colorFlip() {
        const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, t2, e);
      }
      checkMaxDepth() {
        const t2 = this.check();
        return Math.pow(2, t2) <= this.size + 1;
      }
      check() {
        if (this.isRed() && this.left.isRed())
          throw L();
        if (this.right.isRed())
          throw L();
        const t2 = this.left.check();
        if (t2 !== this.right.check())
          throw L();
        return t2 + (this.isRed() ? 0 : 1);
      }
    };
    mn.EMPTY = null, mn.RED = true, mn.BLACK = false;
    mn.EMPTY = new class {
      constructor() {
        this.size = 0;
      }
      get key() {
        throw L();
      }
      get value() {
        throw L();
      }
      get color() {
        throw L();
      }
      get left() {
        throw L();
      }
      get right() {
        throw L();
      }
      copy(t2, e, n, s2, i) {
        return this;
      }
      insert(t2, e, n) {
        return new mn(t2, e);
      }
      remove(t2, e) {
        return this;
      }
      isEmpty() {
        return true;
      }
      inorderTraversal(t2) {
        return false;
      }
      reverseTraversal(t2) {
        return false;
      }
      minKey() {
        return null;
      }
      maxKey() {
        return null;
      }
      isRed() {
        return false;
      }
      checkMaxDepth() {
        return true;
      }
      check() {
        return 0;
      }
    }();
    gn = class {
      constructor(t2) {
        this.comparator = t2, this.data = new wn(this.comparator);
      }
      has(t2) {
        return this.data.get(t2) !== null;
      }
      first() {
        return this.data.minKey();
      }
      last() {
        return this.data.maxKey();
      }
      get size() {
        return this.data.size;
      }
      indexOf(t2) {
        return this.data.indexOf(t2);
      }
      forEach(t2) {
        this.data.inorderTraversal((e, n) => (t2(e), false));
      }
      forEachInRange(t2, e) {
        const n = this.data.getIteratorFrom(t2[0]);
        for (; n.hasNext(); ) {
          const s2 = n.getNext();
          if (this.comparator(s2.key, t2[1]) >= 0)
            return;
          e(s2.key);
        }
      }
      forEachWhile(t2, e) {
        let n;
        for (n = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
          if (!t2(n.getNext().key))
            return;
        }
      }
      firstAfterOrEqual(t2) {
        const e = this.data.getIteratorFrom(t2);
        return e.hasNext() ? e.getNext().key : null;
      }
      getIterator() {
        return new yn(this.data.getIterator());
      }
      getIteratorFrom(t2) {
        return new yn(this.data.getIteratorFrom(t2));
      }
      add(t2) {
        return this.copy(this.data.remove(t2).insert(t2, true));
      }
      delete(t2) {
        return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
      }
      isEmpty() {
        return this.data.isEmpty();
      }
      unionWith(t2) {
        let e = this;
        return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
          e = e.add(t3);
        }), e;
      }
      isEqual(t2) {
        if (!(t2 instanceof gn))
          return false;
        if (this.size !== t2.size)
          return false;
        const e = this.data.getIterator(), n = t2.data.getIterator();
        for (; e.hasNext(); ) {
          const t3 = e.getNext().key, s2 = n.getNext().key;
          if (this.comparator(t3, s2) !== 0)
            return false;
        }
        return true;
      }
      toArray() {
        const t2 = [];
        return this.forEach((e) => {
          t2.push(e);
        }), t2;
      }
      toString() {
        const t2 = [];
        return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
      }
      copy(t2) {
        const e = new gn(this.comparator);
        return e.data = t2, e;
      }
    };
    yn = class {
      constructor(t2) {
        this.iter = t2;
      }
      getNext() {
        return this.iter.getNext().key;
      }
      hasNext() {
        return this.iter.hasNext();
      }
    };
    pn = new wn(Pt.comparator);
    En = new wn(Pt.comparator);
    An = new wn(Pt.comparator);
    bn = new gn(Pt.comparator);
    vn = new gn(et);
    Sn = class {
      constructor(t2, e, n, s2, i) {
        this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s2, this.resolvedLimboDocuments = i;
      }
      static createSynthesizedRemoteEventForCurrentChange(t2, e) {
        const n = new Map();
        return n.set(t2, Dn.createSynthesizedTargetChangeForCurrentChange(t2, e)), new Sn(rt.min(), n, Vn(), Tn(), Pn());
      }
    };
    Dn = class {
      constructor(t2, e, n, s2, i) {
        this.resumeToken = t2, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s2, this.removedDocuments = i;
      }
      static createSynthesizedTargetChangeForCurrentChange(t2, e) {
        return new Dn(_t.EMPTY_BYTE_STRING, e, Pn(), Pn(), Pn());
      }
    };
    Cn = class {
      constructor(t2, e, n, s2) {
        this.k = t2, this.removedTargetIds = e, this.key = n, this.$ = s2;
      }
    };
    Nn = class {
      constructor(t2, e) {
        this.targetId = t2, this.O = e;
      }
    };
    xn = class {
      constructor(t2, e, n = _t.EMPTY_BYTE_STRING, s2 = null) {
        this.state = t2, this.targetIds = e, this.resumeToken = n, this.cause = s2;
      }
    };
    kn = class {
      constructor() {
        this.F = 0, this.M = Fn(), this.L = _t.EMPTY_BYTE_STRING, this.B = false, this.U = true;
      }
      get current() {
        return this.B;
      }
      get resumeToken() {
        return this.L;
      }
      get q() {
        return this.F !== 0;
      }
      get K() {
        return this.U;
      }
      j(t2) {
        t2.approximateByteSize() > 0 && (this.U = true, this.L = t2);
      }
      W() {
        let t2 = Pn(), e = Pn(), n = Pn();
        return this.M.forEach((s2, i) => {
          switch (i) {
            case 0:
              t2 = t2.add(s2);
              break;
            case 2:
              e = e.add(s2);
              break;
            case 1:
              n = n.add(s2);
              break;
            default:
              L();
          }
        }), new Dn(this.L, this.B, t2, e, n);
      }
      G() {
        this.U = false, this.M = Fn();
      }
      H(t2, e) {
        this.U = true, this.M = this.M.insert(t2, e);
      }
      J(t2) {
        this.U = true, this.M = this.M.remove(t2);
      }
      Y() {
        this.F += 1;
      }
      X() {
        this.F -= 1;
      }
      Z() {
        this.U = true, this.B = true;
      }
    };
    $n = class {
      constructor(t2) {
        this.tt = t2, this.et = new Map(), this.nt = Tn(), this.st = On(), this.it = new gn(et);
      }
      rt(t2) {
        for (const e of t2.k)
          t2.$ && t2.$.isFoundDocument() ? this.ot(e, t2.$) : this.ct(e, t2.key, t2.$);
        for (const e of t2.removedTargetIds)
          this.ct(e, t2.key, t2.$);
      }
      at(t2) {
        this.forEachTarget(t2, (e) => {
          const n = this.ut(e);
          switch (t2.state) {
            case 0:
              this.ht(e) && n.j(t2.resumeToken);
              break;
            case 1:
              n.X(), n.q || n.G(), n.j(t2.resumeToken);
              break;
            case 2:
              n.X(), n.q || this.removeTarget(e);
              break;
            case 3:
              this.ht(e) && (n.Z(), n.j(t2.resumeToken));
              break;
            case 4:
              this.ht(e) && (this.lt(e), n.j(t2.resumeToken));
              break;
            default:
              L();
          }
        });
      }
      forEachTarget(t2, e) {
        t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.et.forEach((t3, n) => {
          this.ht(n) && e(n);
        });
      }
      ft(t2) {
        const e = t2.targetId, n = t2.O.count, s2 = this.dt(e);
        if (s2) {
          const t3 = s2.target;
          if (Ht(t3))
            if (n === 0) {
              const n2 = new Pt(t3.path);
              this.ct(e, n2, Kt.newNoDocument(n2, rt.min()));
            } else
              B(n === 1);
          else {
            this.wt(e) !== n && (this.lt(e), this.it = this.it.add(e));
          }
        }
      }
      _t(t2) {
        const e = new Map();
        this.et.forEach((n2, s22) => {
          const i = this.dt(s22);
          if (i) {
            if (n2.current && Ht(i.target)) {
              const e2 = new Pt(i.target.path);
              this.nt.get(e2) !== null || this.gt(s22, e2) || this.ct(s22, e2, Kt.newNoDocument(e2, t2));
            }
            n2.K && (e.set(s22, n2.W()), n2.G());
          }
        });
        let n = Pn();
        this.st.forEach((t3, e2) => {
          let s22 = true;
          e2.forEachWhile((t4) => {
            const e3 = this.dt(t4);
            return !e3 || e3.purpose === 2 || (s22 = false, false);
          }), s22 && (n = n.add(t3));
        });
        const s2 = new Sn(t2, e, this.it, this.nt, n);
        return this.nt = Tn(), this.st = On(), this.it = new gn(et), s2;
      }
      ot(t2, e) {
        if (!this.ht(t2))
          return;
        const n = this.gt(t2, e.key) ? 2 : 0;
        this.ut(t2).H(e.key, n), this.nt = this.nt.insert(e.key, e), this.st = this.st.insert(e.key, this.yt(e.key).add(t2));
      }
      ct(t2, e, n) {
        if (!this.ht(t2))
          return;
        const s2 = this.ut(t2);
        this.gt(t2, e) ? s2.H(e, 1) : s2.J(e), this.st = this.st.insert(e, this.yt(e).delete(t2)), n && (this.nt = this.nt.insert(e, n));
      }
      removeTarget(t2) {
        this.et.delete(t2);
      }
      wt(t2) {
        const e = this.ut(t2).W();
        return this.tt.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
      }
      Y(t2) {
        this.ut(t2).Y();
      }
      ut(t2) {
        let e = this.et.get(t2);
        return e || (e = new kn(), this.et.set(t2, e)), e;
      }
      yt(t2) {
        let e = this.st.get(t2);
        return e || (e = new gn(et), this.st = this.st.insert(t2, e)), e;
      }
      ht(t2) {
        const e = this.dt(t2) !== null;
        return e || $("WatchChangeAggregator", "Detected inactive target", t2), e;
      }
      dt(t2) {
        const e = this.et.get(t2);
        return e && e.q ? null : this.tt.Tt(t2);
      }
      lt(t2) {
        this.et.set(t2, new kn());
        this.tt.getRemoteKeysForTarget(t2).forEach((e) => {
          this.ct(t2, e, null);
        });
      }
      gt(t2, e) {
        return this.tt.getRemoteKeysForTarget(t2).has(e);
      }
    };
    Mn = (() => {
      const t2 = {
        asc: "ASCENDING",
        desc: "DESCENDING"
      };
      return t2;
    })();
    Ln = (() => {
      const t2 = {
        "<": "LESS_THAN",
        "<=": "LESS_THAN_OR_EQUAL",
        ">": "GREATER_THAN",
        ">=": "GREATER_THAN_OR_EQUAL",
        "==": "EQUAL",
        "!=": "NOT_EQUAL",
        "array-contains": "ARRAY_CONTAINS",
        in: "IN",
        "not-in": "NOT_IN",
        "array-contains-any": "ARRAY_CONTAINS_ANY"
      };
      return t2;
    })();
    Bn = class {
      constructor(t2, e) {
        this.databaseId = t2, this.D = e;
      }
    };
    qs = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
    Ks = class {
      constructor() {
        this.onCommittedListeners = [];
      }
      addOnCommittedListener(t2) {
        this.onCommittedListeners.push(t2);
      }
      raiseOnCommittedEvent() {
        this.onCommittedListeners.forEach((t2) => t2());
      }
    };
    js = class {
      constructor(t2) {
        this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
          this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
        }, (t3) => {
          this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
        });
      }
      catch(t2) {
        return this.next(void 0, t2);
      }
      next(t2, e) {
        return this.callbackAttached && L(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new js((n, s2) => {
          this.nextCallback = (e2) => {
            this.wrapSuccess(t2, e2).next(n, s2);
          }, this.catchCallback = (t3) => {
            this.wrapFailure(e, t3).next(n, s2);
          };
        });
      }
      toPromise() {
        return new Promise((t2, e) => {
          this.next(t2, e);
        });
      }
      wrapUserFunction(t2) {
        try {
          const e = t2();
          return e instanceof js ? e : js.resolve(e);
        } catch (t3) {
          return js.reject(t3);
        }
      }
      wrapSuccess(t2, e) {
        return t2 ? this.wrapUserFunction(() => t2(e)) : js.resolve(e);
      }
      wrapFailure(t2, e) {
        return t2 ? this.wrapUserFunction(() => t2(e)) : js.reject(e);
      }
      static resolve(t2) {
        return new js((e, n) => {
          e(t2);
        });
      }
      static reject(t2) {
        return new js((e, n) => {
          n(t2);
        });
      }
      static waitFor(t2) {
        return new js((e, n) => {
          let s2 = 0, i = 0, r = false;
          t2.forEach((t3) => {
            ++s2, t3.next(() => {
              ++i, r && i === s2 && e();
            }, (t4) => n(t4));
          }), r = true, i === s2 && e();
        });
      }
      static or(t2) {
        let e = js.resolve(false);
        for (const n of t2)
          e = e.next((t3) => t3 ? js.resolve(t3) : n());
        return e;
      }
      static forEach(t2, e) {
        const n = [];
        return t2.forEach((t3, s2) => {
          n.push(e.call(this, t3, s2));
        }), this.waitFor(n);
      }
    };
    ni = class {
      constructor(t2, e, n, s2) {
        this.batchId = t2, this.localWriteTime = e, this.baseMutations = n, this.mutations = s2;
      }
      applyToRemoteDocument(t2, e) {
        const n = e.mutationResults;
        for (let e2 = 0; e2 < this.mutations.length; e2++) {
          const s2 = this.mutations[e2];
          if (s2.key.isEqual(t2.key)) {
            Je(s2, t2, n[e2]);
          }
        }
      }
      applyToLocalView(t2) {
        for (const e of this.baseMutations)
          e.key.isEqual(t2.key) && Ye(e, t2, this.localWriteTime);
        for (const e of this.mutations)
          e.key.isEqual(t2.key) && Ye(e, t2, this.localWriteTime);
      }
      applyToLocalDocumentSet(t2) {
        this.mutations.forEach((e) => {
          const n = t2.get(e.key), s2 = n;
          this.applyToLocalView(s2), n.isValidDocument() || s2.convertToNoDocument(rt.min());
        });
      }
      keys() {
        return this.mutations.reduce((t2, e) => t2.add(e.key), Pn());
      }
      isEqual(t2) {
        return this.batchId === t2.batchId && nt(this.mutations, t2.mutations, (t3, e) => Ze(t3, e)) && nt(this.baseMutations, t2.baseMutations, (t3, e) => Ze(t3, e));
      }
    };
    si = class {
      constructor(t2, e, n, s2) {
        this.batch = t2, this.commitVersion = e, this.mutationResults = n, this.docVersions = s2;
      }
      static from(t2, e, n) {
        B(t2.mutations.length === n.length);
        let s2 = Rn();
        const i = t2.mutations;
        for (let t3 = 0; t3 < i.length; t3++)
          s2 = s2.insert(i[t3].key, n[t3].version);
        return new si(t2, e, n, s2);
      }
    };
    ii = class {
      constructor(t2, e, n, s2, i = rt.min(), r = rt.min(), o = _t.EMPTY_BYTE_STRING) {
        this.target = t2, this.targetId = e, this.purpose = n, this.sequenceNumber = s2, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
      }
      withSequenceNumber(t2) {
        return new ii(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
      }
      withResumeToken(t2, e) {
        return new ii(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
      }
      withLastLimboFreeSnapshotVersion(t2) {
        return new ii(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
      }
    };
    ri = class {
      constructor(t2) {
        this.Wt = t2;
      }
    };
    pi = class {
      constructor() {
        this.Gt = new Ti();
      }
      addToCollectionParentIndex(t2, e) {
        return this.Gt.add(e), js.resolve();
      }
      getCollectionParents(t2, e) {
        return js.resolve(this.Gt.getEntries(e));
      }
    };
    Ti = class {
      constructor() {
        this.index = {};
      }
      add(t2) {
        const e = t2.lastSegment(), n = t2.popLast(), s2 = this.index[e] || new gn(ht.comparator), i = !s2.has(n);
        return this.index[e] = s2.add(n), i;
      }
      has(t2) {
        const e = t2.lastSegment(), n = t2.popLast(), s2 = this.index[e];
        return s2 && s2.has(n);
      }
      getEntries(t2) {
        return (this.index[t2] || new gn(ht.comparator)).toArray();
      }
    };
    Ni = class {
      constructor(t2) {
        this.ne = t2;
      }
      next() {
        return this.ne += 2, this.ne;
      }
      static se() {
        return new Ni(0);
      }
      static ie() {
        return new Ni(-1);
      }
    };
    ji = class {
      constructor(t2, e) {
        this.mapKeyFn = t2, this.equalsFn = e, this.inner = {};
      }
      get(t2) {
        const e = this.mapKeyFn(t2), n = this.inner[e];
        if (n !== void 0) {
          for (const [e2, s2] of n)
            if (this.equalsFn(e2, t2))
              return s2;
        }
      }
      has(t2) {
        return this.get(t2) !== void 0;
      }
      set(t2, e) {
        const n = this.mapKeyFn(t2), s2 = this.inner[n];
        if (s2 !== void 0) {
          for (let n2 = 0; n2 < s2.length; n2++)
            if (this.equalsFn(s2[n2][0], t2))
              return void (s2[n2] = [t2, e]);
          s2.push([t2, e]);
        } else
          this.inner[n] = [[t2, e]];
      }
      delete(t2) {
        const e = this.mapKeyFn(t2), n = this.inner[e];
        if (n === void 0)
          return false;
        for (let s2 = 0; s2 < n.length; s2++)
          if (this.equalsFn(n[s2][0], t2))
            return n.length === 1 ? delete this.inner[e] : n.splice(s2, 1), true;
        return false;
      }
      forEach(t2) {
        ct(this.inner, (e, n) => {
          for (const [e2, s2] of n)
            t2(e2, s2);
        });
      }
      isEmpty() {
        return at(this.inner);
      }
    };
    Qi = class {
      constructor() {
        this.changes = new ji((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
      }
      getReadTime(t2) {
        const e = this.changes.get(t2);
        return e ? e.readTime : rt.min();
      }
      addEntry(t2, e) {
        this.assertNotApplied(), this.changes.set(t2.key, {
          document: t2,
          readTime: e
        });
      }
      removeEntry(t2, e = null) {
        this.assertNotApplied(), this.changes.set(t2, {
          document: Kt.newInvalidDocument(t2),
          readTime: e
        });
      }
      getEntry(t2, e) {
        this.assertNotApplied();
        const n = this.changes.get(e);
        return n !== void 0 ? js.resolve(n.document) : this.getFromCache(t2, e);
      }
      getEntries(t2, e) {
        return this.getAllFromCache(t2, e);
      }
      apply(t2) {
        return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
      }
      assertNotApplied() {
      }
    };
    rr = class {
      constructor(t2, e, n) {
        this.He = t2, this.In = e, this.Ht = n;
      }
      An(t2, e) {
        return this.In.getAllMutationBatchesAffectingDocumentKey(t2, e).next((n) => this.Rn(t2, e, n));
      }
      Rn(t2, e, n) {
        return this.He.getEntry(t2, e).next((t3) => {
          for (const e2 of n)
            e2.applyToLocalView(t3);
          return t3;
        });
      }
      bn(t2, e) {
        t2.forEach((t3, n) => {
          for (const t4 of e)
            t4.applyToLocalView(n);
        });
      }
      Pn(t2, e) {
        return this.He.getEntries(t2, e).next((e2) => this.vn(t2, e2).next(() => e2));
      }
      vn(t2, e) {
        return this.In.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => this.bn(e, t3));
      }
      getDocumentsMatchingQuery(t2, e, n) {
        return function(t3) {
          return Pt.isDocumentKey(t3.path) && t3.collectionGroup === null && t3.filters.length === 0;
        }(e) ? this.Vn(t2, e.path) : pe(e) ? this.Sn(t2, e, n) : this.Dn(t2, e, n);
      }
      Vn(t2, e) {
        return this.An(t2, new Pt(e)).next((t3) => {
          let e2 = In();
          return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
        });
      }
      Sn(t2, e, n) {
        const s2 = e.collectionGroup;
        let i = In();
        return this.Ht.getCollectionParents(t2, s2).next((r) => js.forEach(r, (r2) => {
          const o = function(t3, e2) {
            return new fe(e2, null, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
          }(e, r2.child(s2));
          return this.Dn(t2, o, n).next((t3) => {
            t3.forEach((t4, e2) => {
              i = i.insert(t4, e2);
            });
          });
        }).next(() => i));
      }
      Dn(t2, e, n) {
        let s2, i;
        return this.He.getDocumentsMatchingQuery(t2, e, n).next((n2) => (s2 = n2, this.In.getAllMutationBatchesAffectingQuery(t2, e))).next((e2) => (i = e2, this.Cn(t2, i, s2).next((t3) => {
          s2 = t3;
          for (const t4 of i)
            for (const e3 of t4.mutations) {
              const n2 = e3.key;
              let i2 = s2.get(n2);
              i2 == null && (i2 = Kt.newInvalidDocument(n2), s2 = s2.insert(n2, i2)), Ye(e3, i2, t4.localWriteTime), i2.isFoundDocument() || (s2 = s2.remove(n2));
            }
        }))).next(() => (s2.forEach((t3, n2) => {
          Pe(e, n2) || (s2 = s2.remove(t3));
        }), s2));
      }
      Cn(t2, e, n) {
        let s2 = Pn();
        for (const t3 of e)
          for (const e2 of t3.mutations)
            e2 instanceof nn && n.get(e2.key) === null && (s2 = s2.add(e2.key));
        let i = n;
        return this.He.getEntries(t2, s2).next((t3) => (t3.forEach((t4, e2) => {
          e2.isFoundDocument() && (i = i.insert(t4, e2));
        }), i));
      }
    };
    or = class {
      constructor(t2, e, n, s2) {
        this.targetId = t2, this.fromCache = e, this.Nn = n, this.xn = s2;
      }
      static kn(t2, e) {
        let n = Pn(), s2 = Pn();
        for (const t3 of e.docChanges)
          switch (t3.type) {
            case 0:
              n = n.add(t3.doc.key);
              break;
            case 1:
              s2 = s2.add(t3.doc.key);
          }
        return new or(t2, e.fromCache, n, s2);
      }
    };
    cr = class {
      $n(t2) {
        this.On = t2;
      }
      getDocumentsMatchingQuery(t2, e, n, s2) {
        return function(t3) {
          return t3.filters.length === 0 && t3.limit === null && t3.startAt == null && t3.endAt == null && (t3.explicitOrderBy.length === 0 || t3.explicitOrderBy.length === 1 && t3.explicitOrderBy[0].field.isKeyField());
        }(e) || n.isEqual(rt.min()) ? this.Fn(t2, e) : this.On.Pn(t2, s2).next((i) => {
          const r = this.Mn(e, i);
          return (_e(e) || me(e)) && this.Ln(e.limitType, r, s2, n) ? this.Fn(t2, e) : (x() <= LogLevel.DEBUG && $("QueryEngine", "Re-using previous result from %s to execute query: %s", n.toString(), be(e)), this.On.getDocumentsMatchingQuery(t2, e, n).next((t3) => (r.forEach((e2) => {
            t3 = t3.insert(e2.key, e2);
          }), t3)));
        });
      }
      Mn(t2, e) {
        let n = new gn(ve(t2));
        return e.forEach((e2, s2) => {
          Pe(t2, s2) && (n = n.add(s2));
        }), n;
      }
      Ln(t2, e, n, s2) {
        if (n.size !== e.size)
          return true;
        const i = t2 === "F" ? e.last() : e.first();
        return !!i && (i.hasPendingWrites || i.version.compareTo(s2) > 0);
      }
      Fn(t2, e) {
        return x() <= LogLevel.DEBUG && $("QueryEngine", "Using full collection scan to execute query:", be(e)), this.On.getDocumentsMatchingQuery(t2, e, rt.min());
      }
    };
    ar = class {
      constructor(t2, e, n, s2) {
        this.persistence = t2, this.Bn = e, this.N = s2, this.Un = new wn(et), this.qn = new ji((t3) => Wt(t3), zt), this.Kn = rt.min(), this.In = t2.getMutationQueue(n), this.jn = t2.getRemoteDocumentCache(), this.ze = t2.getTargetCache(), this.Qn = new rr(this.jn, this.In, this.persistence.getIndexManager()), this.Je = t2.getBundleCache(), this.Bn.$n(this.Qn);
      }
      collectGarbage(t2) {
        return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.Un));
      }
    };
    Rr = class {
      constructor(t2) {
        this.N = t2, this.Yn = new Map(), this.Xn = new Map();
      }
      getBundleMetadata(t2, e) {
        return js.resolve(this.Yn.get(e));
      }
      saveBundleMetadata(t2, e) {
        var n;
        return this.Yn.set(e.id, {
          id: (n = e).id,
          version: n.version,
          createTime: jn(n.createTime)
        }), js.resolve();
      }
      getNamedQuery(t2, e) {
        return js.resolve(this.Xn.get(e));
      }
      saveNamedQuery(t2, e) {
        return this.Xn.set(e.name, function(t3) {
          return {
            name: t3.name,
            query: _i(t3.bundledQuery),
            readTime: jn(t3.readTime)
          };
        }(e)), js.resolve();
      }
    };
    br = class {
      constructor() {
        this.Zn = new gn(Pr.ts), this.es = new gn(Pr.ns);
      }
      isEmpty() {
        return this.Zn.isEmpty();
      }
      addReference(t2, e) {
        const n = new Pr(t2, e);
        this.Zn = this.Zn.add(n), this.es = this.es.add(n);
      }
      ss(t2, e) {
        t2.forEach((t3) => this.addReference(t3, e));
      }
      removeReference(t2, e) {
        this.rs(new Pr(t2, e));
      }
      os(t2, e) {
        t2.forEach((t3) => this.removeReference(t3, e));
      }
      cs(t2) {
        const e = new Pt(new ht([])), n = new Pr(e, t2), s2 = new Pr(e, t2 + 1), i = [];
        return this.es.forEachInRange([n, s2], (t3) => {
          this.rs(t3), i.push(t3.key);
        }), i;
      }
      us() {
        this.Zn.forEach((t2) => this.rs(t2));
      }
      rs(t2) {
        this.Zn = this.Zn.delete(t2), this.es = this.es.delete(t2);
      }
      hs(t2) {
        const e = new Pt(new ht([])), n = new Pr(e, t2), s2 = new Pr(e, t2 + 1);
        let i = Pn();
        return this.es.forEachInRange([n, s2], (t3) => {
          i = i.add(t3.key);
        }), i;
      }
      containsKey(t2) {
        const e = new Pr(t2, 0), n = this.Zn.firstAfterOrEqual(e);
        return n !== null && t2.isEqual(n.key);
      }
    };
    Pr = class {
      constructor(t2, e) {
        this.key = t2, this.ls = e;
      }
      static ts(t2, e) {
        return Pt.comparator(t2.key, e.key) || et(t2.ls, e.ls);
      }
      static ns(t2, e) {
        return et(t2.ls, e.ls) || Pt.comparator(t2.key, e.key);
      }
    };
    vr = class {
      constructor(t2, e) {
        this.Ht = t2, this.referenceDelegate = e, this.In = [], this.fs = 1, this.ds = new gn(Pr.ts);
      }
      checkEmpty(t2) {
        return js.resolve(this.In.length === 0);
      }
      addMutationBatch(t2, e, n, s2) {
        const i = this.fs;
        this.fs++, this.In.length > 0 && this.In[this.In.length - 1];
        const r = new ni(i, e, n, s2);
        this.In.push(r);
        for (const e2 of s2)
          this.ds = this.ds.add(new Pr(e2.key, i)), this.Ht.addToCollectionParentIndex(t2, e2.key.path.popLast());
        return js.resolve(r);
      }
      lookupMutationBatch(t2, e) {
        return js.resolve(this.ws(e));
      }
      getNextMutationBatchAfterBatchId(t2, e) {
        const n = e + 1, s2 = this._s(n), i = s2 < 0 ? 0 : s2;
        return js.resolve(this.In.length > i ? this.In[i] : null);
      }
      getHighestUnacknowledgedBatchId() {
        return js.resolve(this.In.length === 0 ? -1 : this.fs - 1);
      }
      getAllMutationBatches(t2) {
        return js.resolve(this.In.slice());
      }
      getAllMutationBatchesAffectingDocumentKey(t2, e) {
        const n = new Pr(e, 0), s2 = new Pr(e, Number.POSITIVE_INFINITY), i = [];
        return this.ds.forEachInRange([n, s2], (t3) => {
          const e2 = this.ws(t3.ls);
          i.push(e2);
        }), js.resolve(i);
      }
      getAllMutationBatchesAffectingDocumentKeys(t2, e) {
        let n = new gn(et);
        return e.forEach((t3) => {
          const e2 = new Pr(t3, 0), s2 = new Pr(t3, Number.POSITIVE_INFINITY);
          this.ds.forEachInRange([e2, s2], (t4) => {
            n = n.add(t4.ls);
          });
        }), js.resolve(this.gs(n));
      }
      getAllMutationBatchesAffectingQuery(t2, e) {
        const n = e.path, s2 = n.length + 1;
        let i = n;
        Pt.isDocumentKey(i) || (i = i.child(""));
        const r = new Pr(new Pt(i), 0);
        let o = new gn(et);
        return this.ds.forEachWhile((t3) => {
          const e2 = t3.key.path;
          return !!n.isPrefixOf(e2) && (e2.length === s2 && (o = o.add(t3.ls)), true);
        }, r), js.resolve(this.gs(o));
      }
      gs(t2) {
        const e = [];
        return t2.forEach((t3) => {
          const n = this.ws(t3);
          n !== null && e.push(n);
        }), e;
      }
      removeMutationBatch(t2, e) {
        B(this.ys(e.batchId, "removed") === 0), this.In.shift();
        let n = this.ds;
        return js.forEach(e.mutations, (s2) => {
          const i = new Pr(s2.key, e.batchId);
          return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s2.key);
        }).next(() => {
          this.ds = n;
        });
      }
      te(t2) {
      }
      containsKey(t2, e) {
        const n = new Pr(e, 0), s2 = this.ds.firstAfterOrEqual(n);
        return js.resolve(e.isEqual(s2 && s2.key));
      }
      performConsistencyCheck(t2) {
        return this.In.length, js.resolve();
      }
      ys(t2, e) {
        return this._s(t2);
      }
      _s(t2) {
        if (this.In.length === 0)
          return 0;
        return t2 - this.In[0].batchId;
      }
      ws(t2) {
        const e = this._s(t2);
        if (e < 0 || e >= this.In.length)
          return null;
        return this.In[e];
      }
    };
    Vr = class {
      constructor(t2, e) {
        this.Ht = t2, this.ps = e, this.docs = new wn(Pt.comparator), this.size = 0;
      }
      addEntry(t2, e, n) {
        const s2 = e.key, i = this.docs.get(s2), r = i ? i.size : 0, o = this.ps(e);
        return this.docs = this.docs.insert(s2, {
          document: e.clone(),
          size: o,
          readTime: n
        }), this.size += o - r, this.Ht.addToCollectionParentIndex(t2, s2.path.popLast());
      }
      removeEntry(t2) {
        const e = this.docs.get(t2);
        e && (this.docs = this.docs.remove(t2), this.size -= e.size);
      }
      getEntry(t2, e) {
        const n = this.docs.get(e);
        return js.resolve(n ? n.document.clone() : Kt.newInvalidDocument(e));
      }
      getEntries(t2, e) {
        let n = Tn();
        return e.forEach((t3) => {
          const e2 = this.docs.get(t3);
          n = n.insert(t3, e2 ? e2.document.clone() : Kt.newInvalidDocument(t3));
        }), js.resolve(n);
      }
      getDocumentsMatchingQuery(t2, e, n) {
        let s2 = Tn();
        const i = new Pt(e.path.child("")), r = this.docs.getIteratorFrom(i);
        for (; r.hasNext(); ) {
          const { key: t3, value: { document: i2, readTime: o } } = r.getNext();
          if (!e.path.isPrefixOf(t3.path))
            break;
          o.compareTo(n) <= 0 || Pe(e, i2) && (s2 = s2.insert(i2.key, i2.clone()));
        }
        return js.resolve(s2);
      }
      Ts(t2, e) {
        return js.forEach(this.docs, (t3) => e(t3));
      }
      newChangeBuffer(t2) {
        return new Sr(this);
      }
      getSize(t2) {
        return js.resolve(this.size);
      }
    };
    Sr = class extends Qi {
      constructor(t2) {
        super(), this.Se = t2;
      }
      applyChanges(t2) {
        const e = [];
        return this.changes.forEach((n, s2) => {
          s2.document.isValidDocument() ? e.push(this.Se.addEntry(t2, s2.document, this.getReadTime(n))) : this.Se.removeEntry(n);
        }), js.waitFor(e);
      }
      getFromCache(t2, e) {
        return this.Se.getEntry(t2, e);
      }
      getAllFromCache(t2, e) {
        return this.Se.getEntries(t2, e);
      }
    };
    Dr = class {
      constructor(t2) {
        this.persistence = t2, this.Es = new ji((t3) => Wt(t3), zt), this.lastRemoteSnapshotVersion = rt.min(), this.highestTargetId = 0, this.Is = 0, this.As = new br(), this.targetCount = 0, this.Rs = Ni.se();
      }
      forEachTarget(t2, e) {
        return this.Es.forEach((t3, n) => e(n)), js.resolve();
      }
      getLastRemoteSnapshotVersion(t2) {
        return js.resolve(this.lastRemoteSnapshotVersion);
      }
      getHighestSequenceNumber(t2) {
        return js.resolve(this.Is);
      }
      allocateTargetId(t2) {
        return this.highestTargetId = this.Rs.next(), js.resolve(this.highestTargetId);
      }
      setTargetsMetadata(t2, e, n) {
        return n && (this.lastRemoteSnapshotVersion = n), e > this.Is && (this.Is = e), js.resolve();
      }
      ce(t2) {
        this.Es.set(t2.target, t2);
        const e = t2.targetId;
        e > this.highestTargetId && (this.Rs = new Ni(e), this.highestTargetId = e), t2.sequenceNumber > this.Is && (this.Is = t2.sequenceNumber);
      }
      addTargetData(t2, e) {
        return this.ce(e), this.targetCount += 1, js.resolve();
      }
      updateTargetData(t2, e) {
        return this.ce(e), js.resolve();
      }
      removeTargetData(t2, e) {
        return this.Es.delete(e.target), this.As.cs(e.targetId), this.targetCount -= 1, js.resolve();
      }
      removeTargets(t2, e, n) {
        let s2 = 0;
        const i = [];
        return this.Es.forEach((r, o) => {
          o.sequenceNumber <= e && n.get(o.targetId) === null && (this.Es.delete(r), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s2++);
        }), js.waitFor(i).next(() => s2);
      }
      getTargetCount(t2) {
        return js.resolve(this.targetCount);
      }
      getTargetData(t2, e) {
        const n = this.Es.get(e) || null;
        return js.resolve(n);
      }
      addMatchingKeys(t2, e, n) {
        return this.As.ss(e, n), js.resolve();
      }
      removeMatchingKeys(t2, e, n) {
        this.As.os(e, n);
        const s2 = this.persistence.referenceDelegate, i = [];
        return s2 && e.forEach((e2) => {
          i.push(s2.markPotentiallyOrphaned(t2, e2));
        }), js.waitFor(i);
      }
      removeMatchingKeysForTargetId(t2, e) {
        return this.As.cs(e), js.resolve();
      }
      getMatchingKeysForTargetId(t2, e) {
        const n = this.As.hs(e);
        return js.resolve(n);
      }
      containsKey(t2, e) {
        return js.resolve(this.As.containsKey(e));
      }
    };
    Cr = class {
      constructor(t2, e) {
        this.bs = {}, this.Le = new X(0), this.Be = false, this.Be = true, this.referenceDelegate = t2(this), this.ze = new Dr(this);
        this.Ht = new pi(), this.He = function(t3, e2) {
          return new Vr(t3, e2);
        }(this.Ht, (t3) => this.referenceDelegate.Ps(t3)), this.N = new ri(e), this.Je = new Rr(this.N);
      }
      start() {
        return Promise.resolve();
      }
      shutdown() {
        return this.Be = false, Promise.resolve();
      }
      get started() {
        return this.Be;
      }
      setDatabaseDeletedListener() {
      }
      setNetworkEnabled() {
      }
      getIndexManager() {
        return this.Ht;
      }
      getMutationQueue(t2) {
        let e = this.bs[t2.toKey()];
        return e || (e = new vr(this.Ht, this.referenceDelegate), this.bs[t2.toKey()] = e), e;
      }
      getTargetCache() {
        return this.ze;
      }
      getRemoteDocumentCache() {
        return this.He;
      }
      getBundleCache() {
        return this.Je;
      }
      runTransaction(t2, e, n) {
        $("MemoryPersistence", "Starting transaction:", t2);
        const s2 = new Nr(this.Le.next());
        return this.referenceDelegate.vs(), n(s2).next((t3) => this.referenceDelegate.Vs(s2).next(() => t3)).toPromise().then((t3) => (s2.raiseOnCommittedEvent(), t3));
      }
      Ss(t2, e) {
        return js.or(Object.values(this.bs).map((n) => () => n.containsKey(t2, e)));
      }
    };
    Nr = class extends Ks {
      constructor(t2) {
        super(), this.currentSequenceNumber = t2;
      }
    };
    xr = class {
      constructor(t2) {
        this.persistence = t2, this.Ds = new br(), this.Cs = null;
      }
      static Ns(t2) {
        return new xr(t2);
      }
      get xs() {
        if (this.Cs)
          return this.Cs;
        throw L();
      }
      addReference(t2, e, n) {
        return this.Ds.addReference(n, e), this.xs.delete(n.toString()), js.resolve();
      }
      removeReference(t2, e, n) {
        return this.Ds.removeReference(n, e), this.xs.add(n.toString()), js.resolve();
      }
      markPotentiallyOrphaned(t2, e) {
        return this.xs.add(e.toString()), js.resolve();
      }
      removeTarget(t2, e) {
        this.Ds.cs(e.targetId).forEach((t3) => this.xs.add(t3.toString()));
        const n = this.persistence.getTargetCache();
        return n.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
          t3.forEach((t4) => this.xs.add(t4.toString()));
        }).next(() => n.removeTargetData(t2, e));
      }
      vs() {
        this.Cs = new Set();
      }
      Vs(t2) {
        const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
        return js.forEach(this.xs, (n) => {
          const s2 = Pt.fromPath(n);
          return this.ks(t2, s2).next((t3) => {
            t3 || e.removeEntry(s2);
          });
        }).next(() => (this.Cs = null, e.apply(t2)));
      }
      updateLimboDocument(t2, e) {
        return this.ks(t2, e).next((t3) => {
          t3 ? this.xs.delete(e.toString()) : this.xs.add(e.toString());
        });
      }
      Ps(t2) {
        return 0;
      }
      ks(t2, e) {
        return js.or([() => js.resolve(this.Ds.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Ss(t2, e)]);
      }
    };
    Ur = class {
      constructor() {
        this.activeTargetIds = Vn();
      }
      Fs(t2) {
        this.activeTargetIds = this.activeTargetIds.add(t2);
      }
      Ms(t2) {
        this.activeTargetIds = this.activeTargetIds.delete(t2);
      }
      Os() {
        const t2 = {
          activeTargetIds: this.activeTargetIds.toArray(),
          updateTimeMs: Date.now()
        };
        return JSON.stringify(t2);
      }
    };
    Kr = class {
      constructor() {
        this.yi = new Ur(), this.pi = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
      }
      addPendingMutation(t2) {
      }
      updateMutationState(t2, e, n) {
      }
      addLocalQueryTarget(t2) {
        return this.yi.Fs(t2), this.pi[t2] || "not-current";
      }
      updateQueryState(t2, e, n) {
        this.pi[t2] = e;
      }
      removeLocalQueryTarget(t2) {
        this.yi.Ms(t2);
      }
      isLocalQueryTarget(t2) {
        return this.yi.activeTargetIds.has(t2);
      }
      clearQueryState(t2) {
        delete this.pi[t2];
      }
      getAllActiveQueryTargets() {
        return this.yi.activeTargetIds;
      }
      isActiveQueryTarget(t2) {
        return this.yi.activeTargetIds.has(t2);
      }
      start() {
        return this.yi = new Ur(), Promise.resolve();
      }
      handleUserChange(t2, e, n) {
      }
      setOnlineState(t2) {
      }
      shutdown() {
      }
      writeSequenceNumber(t2) {
      }
      notifyBundleLoaded() {
      }
    };
    jr = class {
      Ti(t2) {
      }
      shutdown() {
      }
    };
    Qr = class {
      constructor() {
        this.Ei = () => this.Ii(), this.Ai = () => this.Ri(), this.bi = [], this.Pi();
      }
      Ti(t2) {
        this.bi.push(t2);
      }
      shutdown() {
        window.removeEventListener("online", this.Ei), window.removeEventListener("offline", this.Ai);
      }
      Pi() {
        window.addEventListener("online", this.Ei), window.addEventListener("offline", this.Ai);
      }
      Ii() {
        $("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
        for (const t2 of this.bi)
          t2(0);
      }
      Ri() {
        $("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
        for (const t2 of this.bi)
          t2(1);
      }
      static bt() {
        return typeof window != "undefined" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
      }
    };
    Wr = {
      BatchGetDocuments: "batchGet",
      Commit: "commit",
      RunQuery: "runQuery"
    };
    Gr = class {
      constructor(t2) {
        this.vi = t2.vi, this.Vi = t2.Vi;
      }
      Si(t2) {
        this.Di = t2;
      }
      Ci(t2) {
        this.Ni = t2;
      }
      onMessage(t2) {
        this.xi = t2;
      }
      close() {
        this.Vi();
      }
      send(t2) {
        this.vi(t2);
      }
      ki() {
        this.Di();
      }
      $i(t2) {
        this.Ni(t2);
      }
      Oi(t2) {
        this.xi(t2);
      }
    };
    zr = class extends class {
      constructor(t2) {
        this.databaseInfo = t2, this.databaseId = t2.databaseId;
        const e = t2.ssl ? "https" : "http";
        this.Fi = e + "://" + t2.host, this.Mi = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
      }
      Li(t2, e, n, s2) {
        const i = this.Bi(t2, e);
        $("RestConnection", "Sending: ", i, n);
        const r = {};
        return this.Ui(r, s2), this.qi(t2, i, r, n).then((t3) => ($("RestConnection", "Received: ", t3), t3), (e2) => {
          throw F("RestConnection", `${t2} failed with error: `, e2, "url: ", i, "request:", n), e2;
        });
      }
      Ki(t2, e, n, s2) {
        return this.Li(t2, e, n, s2);
      }
      Ui(t2, e) {
        if (t2["X-Goog-Api-Client"] = "gl-js/ fire/" + C, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e)
          for (const n in e.authHeaders)
            e.authHeaders.hasOwnProperty(n) && (t2[n] = e.authHeaders[n]);
      }
      Bi(t2, e) {
        const n = Wr[t2];
        return `${this.Fi}/v1/${e}:${n}`;
      }
    } {
      constructor(t2) {
        super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
      }
      qi(t2, e, n, s2) {
        return new Promise((i, r) => {
          const o = new XhrIo();
          o.listenOnce(EventType.COMPLETE, () => {
            try {
              switch (o.getLastErrorCode()) {
                case ErrorCode.NO_ERROR:
                  const e2 = o.getResponseJson();
                  $("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
                  break;
                case ErrorCode.TIMEOUT:
                  $("Connection", 'RPC "' + t2 + '" timed out'), r(new j(K.DEADLINE_EXCEEDED, "Request time out"));
                  break;
                case ErrorCode.HTTP_ERROR:
                  const n2 = o.getStatus();
                  if ($("Connection", 'RPC "' + t2 + '" failed with status:', n2, "response text:", o.getResponseText()), n2 > 0) {
                    const t3 = o.getResponseJson().error;
                    if (t3 && t3.status && t3.message) {
                      const e3 = function(t4) {
                        const e4 = t4.toLowerCase().replace(/_/g, "-");
                        return Object.values(K).indexOf(e4) >= 0 ? e4 : K.UNKNOWN;
                      }(t3.status);
                      r(new j(e3, t3.message));
                    } else
                      r(new j(K.UNKNOWN, "Server responded with status " + o.getStatus()));
                  } else
                    r(new j(K.UNAVAILABLE, "Connection failed."));
                  break;
                default:
                  L();
              }
            } finally {
              $("Connection", 'RPC "' + t2 + '" completed.');
            }
          });
          const c = JSON.stringify(s2);
          o.send(e, "POST", c, n, 15);
        });
      }
      ji(t2, e) {
        const n = [this.Fi, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], s2 = createWebChannelTransport(), i = getStatEventTarget(), r = {
          httpSessionIdParam: "gsessionid",
          initMessageHeaders: {},
          messageUrlParams: {
            database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
          },
          sendRawJson: true,
          supportsCrossDomainXhr: true,
          internalChannelParams: {
            forwardChannelRequestTimeoutMs: 6e5
          },
          forceLongPolling: this.forceLongPolling,
          detectBufferingProxy: this.autoDetectLongPolling
        };
        this.useFetchStreams && (r.xmlHttpFactory = new FetchXmlHttpFactory({})), this.Ui(r.initMessageHeaders, e), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (r.httpHeadersOverwriteParam = "$httpHeaders");
        const o = n.join("");
        $("Connection", "Creating WebChannel: " + o, r);
        const c = s2.createWebChannel(o, r);
        let a = false, u = false;
        const h = new Gr({
          vi: (t3) => {
            u ? $("Connection", "Not sending because WebChannel is closed:", t3) : (a || ($("Connection", "Opening WebChannel transport."), c.open(), a = true), $("Connection", "WebChannel sending:", t3), c.send(t3));
          },
          Vi: () => c.close()
        }), g = (t3, e2, n2) => {
          t3.listen(e2, (t4) => {
            try {
              n2(t4);
            } catch (t5) {
              setTimeout(() => {
                throw t5;
              }, 0);
            }
          });
        };
        return g(c, WebChannel.EventType.OPEN, () => {
          u || $("Connection", "WebChannel transport opened.");
        }), g(c, WebChannel.EventType.CLOSE, () => {
          u || (u = true, $("Connection", "WebChannel transport closed"), h.$i());
        }), g(c, WebChannel.EventType.ERROR, (t3) => {
          u || (u = true, F("Connection", "WebChannel transport errored:", t3), h.$i(new j(K.UNAVAILABLE, "The operation could not be completed")));
        }), g(c, WebChannel.EventType.MESSAGE, (t3) => {
          var e2;
          if (!u) {
            const n2 = t3.data[0];
            B(!!n2);
            const s22 = n2, i2 = s22.error || ((e2 = s22[0]) === null || e2 === void 0 ? void 0 : e2.error);
            if (i2) {
              $("Connection", "WebChannel received error:", i2);
              const t4 = i2.status;
              let e3 = function(t5) {
                const e4 = hn[t5];
                if (e4 !== void 0)
                  return dn(e4);
              }(t4), n3 = i2.message;
              e3 === void 0 && (e3 = K.INTERNAL, n3 = "Unknown error status: " + t4 + " with message " + i2.message), u = true, h.$i(new j(e3, n3)), c.close();
            } else
              $("Connection", "WebChannel received:", n2), h.Oi(n2);
          }
        }), g(i, Event2.STAT_EVENT, (t3) => {
          t3.stat === Stat.PROXY ? $("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && $("Connection", "Detected no buffering proxy");
        }), setTimeout(() => {
          h.ki();
        }, 0), h;
      }
    };
    Xr = class {
      constructor(t2, e, n = 1e3, s2 = 1.5, i = 6e4) {
        this.Oe = t2, this.timerId = e, this.Qi = n, this.Wi = s2, this.Gi = i, this.zi = 0, this.Hi = null, this.Ji = Date.now(), this.reset();
      }
      reset() {
        this.zi = 0;
      }
      Yi() {
        this.zi = this.Gi;
      }
      Xi(t2) {
        this.cancel();
        const e = Math.floor(this.zi + this.Zi()), n = Math.max(0, Date.now() - this.Ji), s2 = Math.max(0, e - n);
        s2 > 0 && $("ExponentialBackoff", `Backing off for ${s2} ms (base delay: ${this.zi} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.Hi = this.Oe.enqueueAfterDelay(this.timerId, s2, () => (this.Ji = Date.now(), t2())), this.zi *= this.Wi, this.zi < this.Qi && (this.zi = this.Qi), this.zi > this.Gi && (this.zi = this.Gi);
      }
      tr() {
        this.Hi !== null && (this.Hi.skipDelay(), this.Hi = null);
      }
      cancel() {
        this.Hi !== null && (this.Hi.cancel(), this.Hi = null);
      }
      Zi() {
        return (Math.random() - 0.5) * this.zi;
      }
    };
    Zr = class {
      constructor(t2, e, n, s2, i, r, o) {
        this.Oe = t2, this.er = n, this.nr = s2, this.sr = i, this.credentialsProvider = r, this.listener = o, this.state = 0, this.ir = 0, this.rr = null, this.cr = null, this.stream = null, this.ar = new Xr(t2, e);
      }
      ur() {
        return this.state === 1 || this.state === 5 || this.hr();
      }
      hr() {
        return this.state === 2 || this.state === 3;
      }
      start() {
        this.state !== 4 ? this.auth() : this.lr();
      }
      async stop() {
        this.ur() && await this.close(0);
      }
      dr() {
        this.state = 0, this.ar.reset();
      }
      wr() {
        this.hr() && this.rr === null && (this.rr = this.Oe.enqueueAfterDelay(this.er, 6e4, () => this._r()));
      }
      mr(t2) {
        this.gr(), this.stream.send(t2);
      }
      async _r() {
        if (this.hr())
          return this.close(0);
      }
      gr() {
        this.rr && (this.rr.cancel(), this.rr = null);
      }
      yr() {
        this.cr && (this.cr.cancel(), this.cr = null);
      }
      async close(t2, e) {
        this.gr(), this.yr(), this.ar.cancel(), this.ir++, t2 !== 4 ? this.ar.reset() : e && e.code === K.RESOURCE_EXHAUSTED ? (O(e.toString()), O("Using maximum backoff delay to prevent overloading the backend."), this.ar.Yi()) : e && e.code === K.UNAUTHENTICATED && this.state !== 3 && this.credentialsProvider.invalidateToken(), this.stream !== null && (this.pr(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Ci(e);
      }
      pr() {
      }
      auth() {
        this.state = 1;
        const t2 = this.Tr(this.ir), e = this.ir;
        this.credentialsProvider.getToken().then((t3) => {
          this.ir === e && this.Er(t3);
        }, (e2) => {
          t2(() => {
            const t3 = new j(K.UNKNOWN, "Fetching auth token failed: " + e2.message);
            return this.Ir(t3);
          });
        });
      }
      Er(t2) {
        const e = this.Tr(this.ir);
        this.stream = this.Ar(t2), this.stream.Si(() => {
          e(() => (this.state = 2, this.cr = this.Oe.enqueueAfterDelay(this.nr, 1e4, () => (this.hr() && (this.state = 3), Promise.resolve())), this.listener.Si()));
        }), this.stream.Ci((t3) => {
          e(() => this.Ir(t3));
        }), this.stream.onMessage((t3) => {
          e(() => this.onMessage(t3));
        });
      }
      lr() {
        this.state = 5, this.ar.Xi(async () => {
          this.state = 0, this.start();
        });
      }
      Ir(t2) {
        return $("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(4, t2);
      }
      Tr(t2) {
        return (e) => {
          this.Oe.enqueueAndForget(() => this.ir === t2 ? e() : ($("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
        };
      }
    };
    to = class extends Zr {
      constructor(t2, e, n, s2, i) {
        super(t2, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e, n, i), this.N = s2;
      }
      Ar(t2) {
        return this.sr.ji("Listen", t2);
      }
      onMessage(t2) {
        this.ar.reset();
        const e = ns(this.N, t2), n = function(t3) {
          if (!("targetChange" in t3))
            return rt.min();
          const e2 = t3.targetChange;
          return e2.targetIds && e2.targetIds.length ? rt.min() : e2.readTime ? jn(e2.readTime) : rt.min();
        }(t2);
        return this.listener.Rr(e, n);
      }
      br(t2) {
        const e = {};
        e.database = Yn(this.N), e.addTarget = function(t3, e2) {
          let n2;
          const s2 = e2.target;
          return n2 = Ht(s2) ? {
            documents: os(t3, s2)
          } : {
            query: cs(t3, s2)
          }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = qn(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(rt.min()) > 0 && (n2.readTime = Un(t3, e2.snapshotVersion.toTimestamp())), n2;
        }(this.N, t2);
        const n = us(this.N, t2);
        n && (e.labels = n), this.mr(e);
      }
      Pr(t2) {
        const e = {};
        e.database = Yn(this.N), e.removeTarget = t2, this.mr(e);
      }
    };
    eo = class extends Zr {
      constructor(t2, e, n, s2, i) {
        super(t2, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", e, n, i), this.N = s2, this.vr = false;
      }
      get Vr() {
        return this.vr;
      }
      start() {
        this.vr = false, this.lastStreamToken = void 0, super.start();
      }
      pr() {
        this.vr && this.Sr([]);
      }
      Ar(t2) {
        return this.sr.ji("Write", t2);
      }
      onMessage(t2) {
        if (B(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.vr) {
          this.ar.reset();
          const e = rs(t2.writeResults, t2.commitTime), n = jn(t2.commitTime);
          return this.listener.Dr(n, e);
        }
        return B(!t2.writeResults || t2.writeResults.length === 0), this.vr = true, this.listener.Cr();
      }
      Nr() {
        const t2 = {};
        t2.database = Yn(this.N), this.mr(t2);
      }
      Sr(t2) {
        const e = {
          streamToken: this.lastStreamToken,
          writes: t2.map((t3) => ss(this.N, t3))
        };
        this.mr(e);
      }
    };
    no = class extends class {
    } {
      constructor(t2, e, n) {
        super(), this.credentials = t2, this.sr = e, this.N = n, this.kr = false;
      }
      $r() {
        if (this.kr)
          throw new j(K.FAILED_PRECONDITION, "The client has already been terminated.");
      }
      Li(t2, e, n) {
        return this.$r(), this.credentials.getToken().then((s2) => this.sr.Li(t2, e, n, s2)).catch((t3) => {
          throw t3.name === "FirebaseError" ? (t3.code === K.UNAUTHENTICATED && this.credentials.invalidateToken(), t3) : new j(K.UNKNOWN, t3.toString());
        });
      }
      Ki(t2, e, n) {
        return this.$r(), this.credentials.getToken().then((s2) => this.sr.Ki(t2, e, n, s2)).catch((t3) => {
          throw t3.name === "FirebaseError" ? (t3.code === K.UNAUTHENTICATED && this.credentials.invalidateToken(), t3) : new j(K.UNKNOWN, t3.toString());
        });
      }
      terminate() {
        this.kr = true;
      }
    };
    so = class {
      constructor(t2, e) {
        this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.Or = 0, this.Fr = null, this.Mr = true;
      }
      Lr() {
        this.Or === 0 && (this.Br("Unknown"), this.Fr = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.Fr = null, this.Ur("Backend didn't respond within 10 seconds."), this.Br("Offline"), Promise.resolve())));
      }
      qr(t2) {
        this.state === "Online" ? this.Br("Unknown") : (this.Or++, this.Or >= 1 && (this.Kr(), this.Ur(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.Br("Offline")));
      }
      set(t2) {
        this.Kr(), this.Or = 0, t2 === "Online" && (this.Mr = false), this.Br(t2);
      }
      Br(t2) {
        t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
      }
      Ur(t2) {
        const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
        this.Mr ? (O(e), this.Mr = false) : $("OnlineStateTracker", e);
      }
      Kr() {
        this.Fr !== null && (this.Fr.cancel(), this.Fr = null);
      }
    };
    io = class {
      constructor(t2, e, n, s2, i) {
        this.localStore = t2, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.jr = [], this.Qr = new Map(), this.Wr = new Set(), this.Gr = [], this.zr = i, this.zr.Ti((t3) => {
          n.enqueueAndForget(async () => {
            wo(this) && ($("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
              const e2 = q(t4);
              e2.Wr.add(4), await oo(e2), e2.Hr.set("Unknown"), e2.Wr.delete(4), await ro(e2);
            }(this));
          });
        }), this.Hr = new so(n, s2);
      }
    };
    xo = class {
      constructor(t2, e, n, s2, i) {
        this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n, this.op = s2, this.removalCallback = i, this.deferred = new Q(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
        });
      }
      static createAndSchedule(t2, e, n, s2, i) {
        const r = Date.now() + n, o = new xo(t2, e, r, s2, i);
        return o.start(n), o;
      }
      start(t2) {
        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
      }
      skipDelay() {
        return this.handleDelayElapsed();
      }
      cancel(t2) {
        this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new j(K.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
      }
      handleDelayElapsed() {
        this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
      }
      clearTimeout() {
        this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
      }
    };
    $o = class {
      constructor(t2) {
        this.comparator = t2 ? (e, n) => t2(e, n) || Pt.comparator(e.key, n.key) : (t3, e) => Pt.comparator(t3.key, e.key), this.keyedMap = In(), this.sortedSet = new wn(this.comparator);
      }
      static emptySet(t2) {
        return new $o(t2.comparator);
      }
      has(t2) {
        return this.keyedMap.get(t2) != null;
      }
      get(t2) {
        return this.keyedMap.get(t2);
      }
      first() {
        return this.sortedSet.minKey();
      }
      last() {
        return this.sortedSet.maxKey();
      }
      isEmpty() {
        return this.sortedSet.isEmpty();
      }
      indexOf(t2) {
        const e = this.keyedMap.get(t2);
        return e ? this.sortedSet.indexOf(e) : -1;
      }
      get size() {
        return this.sortedSet.size;
      }
      forEach(t2) {
        this.sortedSet.inorderTraversal((e, n) => (t2(e), false));
      }
      add(t2) {
        const e = this.delete(t2.key);
        return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
      }
      delete(t2) {
        const e = this.get(t2);
        return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
      }
      isEqual(t2) {
        if (!(t2 instanceof $o))
          return false;
        if (this.size !== t2.size)
          return false;
        const e = this.sortedSet.getIterator(), n = t2.sortedSet.getIterator();
        for (; e.hasNext(); ) {
          const t3 = e.getNext().key, s2 = n.getNext().key;
          if (!t3.isEqual(s2))
            return false;
        }
        return true;
      }
      toString() {
        const t2 = [];
        return this.forEach((e) => {
          t2.push(e.toString());
        }), t2.length === 0 ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
      }
      copy(t2, e) {
        const n = new $o();
        return n.comparator = this.comparator, n.keyedMap = t2, n.sortedSet = e, n;
      }
    };
    Oo = class {
      constructor() {
        this.Zr = new wn(Pt.comparator);
      }
      track(t2) {
        const e = t2.doc.key, n = this.Zr.get(e);
        n ? t2.type !== 0 && n.type === 3 ? this.Zr = this.Zr.insert(e, t2) : t2.type === 3 && n.type !== 1 ? this.Zr = this.Zr.insert(e, {
          type: n.type,
          doc: t2.doc
        }) : t2.type === 2 && n.type === 2 ? this.Zr = this.Zr.insert(e, {
          type: 2,
          doc: t2.doc
        }) : t2.type === 2 && n.type === 0 ? this.Zr = this.Zr.insert(e, {
          type: 0,
          doc: t2.doc
        }) : t2.type === 1 && n.type === 0 ? this.Zr = this.Zr.remove(e) : t2.type === 1 && n.type === 2 ? this.Zr = this.Zr.insert(e, {
          type: 1,
          doc: n.doc
        }) : t2.type === 0 && n.type === 1 ? this.Zr = this.Zr.insert(e, {
          type: 2,
          doc: t2.doc
        }) : L() : this.Zr = this.Zr.insert(e, t2);
      }
      eo() {
        const t2 = [];
        return this.Zr.inorderTraversal((e, n) => {
          t2.push(n);
        }), t2;
      }
    };
    Fo = class {
      constructor(t2, e, n, s2, i, r, o, c) {
        this.query = t2, this.docs = e, this.oldDocs = n, this.docChanges = s2, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = c;
      }
      static fromInitialDocuments(t2, e, n, s2) {
        const i = [];
        return e.forEach((t3) => {
          i.push({
            type: 0,
            doc: t3
          });
        }), new Fo(t2, e, $o.emptySet(e), i, n, s2, true, false);
      }
      get hasPendingWrites() {
        return !this.mutatedKeys.isEmpty();
      }
      isEqual(t2) {
        if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && Ae(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
          return false;
        const e = this.docChanges, n = t2.docChanges;
        if (e.length !== n.length)
          return false;
        for (let t3 = 0; t3 < e.length; t3++)
          if (e[t3].type !== n[t3].type || !e[t3].doc.isEqual(n[t3].doc))
            return false;
        return true;
      }
    };
    Mo = class {
      constructor() {
        this.no = void 0, this.listeners = [];
      }
    };
    Lo = class {
      constructor() {
        this.queries = new ji((t2) => Re(t2), Ae), this.onlineState = "Unknown", this.so = new Set();
      }
    };
    Qo = class {
      constructor(t2, e, n) {
        this.query = t2, this.oo = e, this.co = false, this.ao = null, this.onlineState = "Unknown", this.options = n || {};
      }
      ro(t2) {
        if (!this.options.includeMetadataChanges) {
          const e2 = [];
          for (const n of t2.docChanges)
            n.type !== 3 && e2.push(n);
          t2 = new Fo(t2.query, t2.docs, t2.oldDocs, e2, t2.mutatedKeys, t2.fromCache, t2.syncStateChanged, true);
        }
        let e = false;
        return this.co ? this.uo(t2) && (this.oo.next(t2), e = true) : this.ho(t2, this.onlineState) && (this.lo(t2), e = true), this.ao = t2, e;
      }
      onError(t2) {
        this.oo.error(t2);
      }
      io(t2) {
        this.onlineState = t2;
        let e = false;
        return this.ao && !this.co && this.ho(this.ao, t2) && (this.lo(this.ao), e = true), e;
      }
      ho(t2, e) {
        if (!t2.fromCache)
          return true;
        const n = e !== "Offline";
        return (!this.options.fo || !n) && (!t2.docs.isEmpty() || e === "Offline");
      }
      uo(t2) {
        if (t2.docChanges.length > 0)
          return true;
        const e = this.ao && this.ao.hasPendingWrites !== t2.hasPendingWrites;
        return !(!t2.syncStateChanged && !e) && this.options.includeMetadataChanges === true;
      }
      lo(t2) {
        t2 = Fo.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.co = true, this.oo.next(t2);
      }
    };
    Jo = class {
      constructor(t2) {
        this.key = t2;
      }
    };
    Yo = class {
      constructor(t2) {
        this.key = t2;
      }
    };
    Xo = class {
      constructor(t2, e) {
        this.query = t2, this.po = e, this.To = null, this.current = false, this.Eo = Pn(), this.mutatedKeys = Pn(), this.Io = ve(t2), this.Ao = new $o(this.Io);
      }
      get Ro() {
        return this.po;
      }
      bo(t2, e) {
        const n = e ? e.Po : new Oo(), s2 = e ? e.Ao : this.Ao;
        let i = e ? e.mutatedKeys : this.mutatedKeys, r = s2, o = false;
        const c = _e(this.query) && s2.size === this.query.limit ? s2.last() : null, a = me(this.query) && s2.size === this.query.limit ? s2.first() : null;
        if (t2.inorderTraversal((t3, e2) => {
          const u = s2.get(t3), h = Pe(this.query, e2) ? e2 : null, l2 = !!u && this.mutatedKeys.has(u.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
          let d2 = false;
          if (u && h) {
            u.data.isEqual(h.data) ? l2 !== f && (n.track({
              type: 3,
              doc: h
            }), d2 = true) : this.vo(u, h) || (n.track({
              type: 2,
              doc: h
            }), d2 = true, (c && this.Io(h, c) > 0 || a && this.Io(h, a) < 0) && (o = true));
          } else
            !u && h ? (n.track({
              type: 0,
              doc: h
            }), d2 = true) : u && !h && (n.track({
              type: 1,
              doc: u
            }), d2 = true, (c || a) && (o = true));
          d2 && (h ? (r = r.add(h), i = f ? i.add(t3) : i.delete(t3)) : (r = r.delete(t3), i = i.delete(t3)));
        }), _e(this.query) || me(this.query))
          for (; r.size > this.query.limit; ) {
            const t3 = _e(this.query) ? r.last() : r.first();
            r = r.delete(t3.key), i = i.delete(t3.key), n.track({
              type: 1,
              doc: t3
            });
          }
        return {
          Ao: r,
          Po: n,
          Ln: o,
          mutatedKeys: i
        };
      }
      vo(t2, e) {
        return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
      }
      applyChanges(t2, e, n) {
        const s2 = this.Ao;
        this.Ao = t2.Ao, this.mutatedKeys = t2.mutatedKeys;
        const i = t2.Po.eo();
        i.sort((t3, e2) => function(t4, e3) {
          const n2 = (t5) => {
            switch (t5) {
              case 0:
                return 1;
              case 2:
              case 3:
                return 2;
              case 1:
                return 0;
              default:
                return L();
            }
          };
          return n2(t4) - n2(e3);
        }(t3.type, e2.type) || this.Io(t3.doc, e2.doc)), this.Vo(n);
        const r = e ? this.So() : [], o = this.Eo.size === 0 && this.current ? 1 : 0, c = o !== this.To;
        if (this.To = o, i.length !== 0 || c) {
          return {
            snapshot: new Fo(this.query, t2.Ao, s2, i, t2.mutatedKeys, o === 0, c, false),
            Do: r
          };
        }
        return {
          Do: r
        };
      }
      io(t2) {
        return this.current && t2 === "Offline" ? (this.current = false, this.applyChanges({
          Ao: this.Ao,
          Po: new Oo(),
          mutatedKeys: this.mutatedKeys,
          Ln: false
        }, false)) : {
          Do: []
        };
      }
      Co(t2) {
        return !this.po.has(t2) && (!!this.Ao.has(t2) && !this.Ao.get(t2).hasLocalMutations);
      }
      Vo(t2) {
        t2 && (t2.addedDocuments.forEach((t3) => this.po = this.po.add(t3)), t2.modifiedDocuments.forEach((t3) => {
        }), t2.removedDocuments.forEach((t3) => this.po = this.po.delete(t3)), this.current = t2.current);
      }
      So() {
        if (!this.current)
          return [];
        const t2 = this.Eo;
        this.Eo = Pn(), this.Ao.forEach((t3) => {
          this.Co(t3.key) && (this.Eo = this.Eo.add(t3.key));
        });
        const e = [];
        return t2.forEach((t3) => {
          this.Eo.has(t3) || e.push(new Yo(t3));
        }), this.Eo.forEach((n) => {
          t2.has(n) || e.push(new Jo(n));
        }), e;
      }
      No(t2) {
        this.po = t2.Gn, this.Eo = Pn();
        const e = this.bo(t2.documents);
        return this.applyChanges(e, true);
      }
      xo() {
        return Fo.fromInitialDocuments(this.query, this.Ao, this.mutatedKeys, this.To === 0);
      }
    };
    Zo = class {
      constructor(t2, e, n) {
        this.query = t2, this.targetId = e, this.view = n;
      }
    };
    tc = class {
      constructor(t2) {
        this.key = t2, this.ko = false;
      }
    };
    ec = class {
      constructor(t2, e, n, s2, i, r) {
        this.localStore = t2, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s2, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.$o = {}, this.Oo = new ji((t3) => Re(t3), Ae), this.Fo = new Map(), this.Mo = new Set(), this.Lo = new wn(Pt.comparator), this.Bo = new Map(), this.Uo = new br(), this.qo = {}, this.Ko = new Map(), this.jo = Ni.ie(), this.onlineState = "Unknown", this.Qo = void 0;
      }
      get isPrimaryClient() {
        return this.Qo === true;
      }
    };
    kc = class {
      constructor() {
        this.synchronizeTabs = false;
      }
      async initialize(t2) {
        this.N = Yr(t2.databaseInfo.databaseId), this.sharedClientState = this.Ho(t2), this.persistence = this.Jo(t2), await this.persistence.start(), this.gcScheduler = this.Yo(t2), this.localStore = this.Xo(t2);
      }
      Yo(t2) {
        return null;
      }
      Xo(t2) {
        return ur(this.persistence, new cr(), t2.initialUser, this.N);
      }
      Jo(t2) {
        return new Cr(xr.Ns, this.N);
      }
      Ho(t2) {
        return new Kr();
      }
      async terminate() {
        this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
      }
    };
    Fc = class {
      async initialize(t2, e) {
        this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(e, !t2.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t3) => cc(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = Tc.bind(null, this.syncEngine), await Do(this.remoteStore, this.syncEngine.isPrimaryClient));
      }
      createEventManager(t2) {
        return new Lo();
      }
      createDatastore(t2) {
        const e = Yr(t2.databaseInfo.databaseId), n = (s2 = t2.databaseInfo, new zr(s2));
        var s2;
        return function(t3, e2, n2) {
          return new no(t3, e2, n2);
        }(t2.credentials, n, e);
      }
      createRemoteStore(t2) {
        return e = this.localStore, n = this.datastore, s2 = t2.asyncQueue, i = (t3) => cc(this.syncEngine, t3, 0), r = Qr.bt() ? new Qr() : new jr(), new io(e, n, s2, i, r);
        var e, n, s2, i, r;
      }
      createSyncEngine(t2, e) {
        return function(t3, e2, n, s2, i, r, o) {
          const c = new ec(t3, e2, n, s2, i, r);
          return o && (c.Qo = true), c;
        }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
      }
      terminate() {
        return async function(t2) {
          const e = q(t2);
          $("RemoteStore", "RemoteStore shutting down."), e.Wr.add(5), await oo(e), e.zr.shutdown(), e.Hr.set("Unknown");
        }(this.remoteStore);
      }
    };
    Lc = class {
      constructor(t2) {
        this.observer = t2, this.muted = false;
      }
      next(t2) {
        this.observer.next && this.tc(this.observer.next, t2);
      }
      error(t2) {
        this.observer.error ? this.tc(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
      }
      ec() {
        this.muted = true;
      }
      tc(t2, e) {
        this.muted || setTimeout(() => {
          this.muted || t2(e);
        }, 0);
      }
    };
    Kc = class {
      constructor(t2, e, n) {
        this.credentials = t2, this.asyncQueue = e, this.databaseInfo = n, this.user = D.UNAUTHENTICATED, this.clientId = tt.I(), this.credentialListener = () => Promise.resolve(), this.credentials.start(e, async (t3) => {
          $("FirestoreClient", "Received user=", t3.uid), await this.credentialListener(t3), this.user = t3;
        });
      }
      async getConfiguration() {
        return {
          asyncQueue: this.asyncQueue,
          databaseInfo: this.databaseInfo,
          clientId: this.clientId,
          credentials: this.credentials,
          initialUser: this.user,
          maxConcurrentLimboResolutions: 100
        };
      }
      setCredentialChangeListener(t2) {
        this.credentialListener = t2;
      }
      verifyNotTerminated() {
        if (this.asyncQueue.isShuttingDown)
          throw new j(K.FAILED_PRECONDITION, "The client has already been terminated.");
      }
      terminate() {
        this.asyncQueue.enterRestrictedMode();
        const t2 = new Q();
        return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
          try {
            this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.credentials.shutdown(), t2.resolve();
          } catch (e) {
            const n = ko(e, "Failed to shutdown persistence");
            t2.reject(n);
          }
        }), t2.promise;
      }
    };
    ua = class {
      constructor(t2, e, n, s2, i, r, o, c) {
        this.databaseId = t2, this.appId = e, this.persistenceKey = n, this.host = s2, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = c;
      }
    };
    ha = class {
      constructor(t2, e) {
        this.projectId = t2, this.database = e || "(default)";
      }
      get isDefaultDatabase() {
        return this.database === "(default)";
      }
      isEqual(t2) {
        return t2 instanceof ha && t2.projectId === this.projectId && t2.database === this.database;
      }
    };
    la = new Map();
    pa = class {
      constructor(t2) {
        var e;
        if (t2.host === void 0) {
          if (t2.ssl !== void 0)
            throw new j(K.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
          this.host = "firestore.googleapis.com", this.ssl = true;
        } else
          this.host = t2.host, this.ssl = (e = t2.ssl) === null || e === void 0 || e;
        if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, t2.cacheSizeBytes === void 0)
          this.cacheSizeBytes = 41943040;
        else {
          if (t2.cacheSizeBytes !== -1 && t2.cacheSizeBytes < 1048576)
            throw new j(K.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
          this.cacheSizeBytes = t2.cacheSizeBytes;
        }
        this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, da("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
      }
      isEqual(t2) {
        return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
      }
    };
    Ta = class {
      constructor(t2, e) {
        this._credentials = e, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new pa({}), this._settingsFrozen = false, t2 instanceof ha ? this._databaseId = t2 : (this._app = t2, this._databaseId = function(t3) {
          if (!Object.prototype.hasOwnProperty.apply(t3.options, ["projectId"]))
            throw new j(K.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
          return new ha(t3.options.projectId);
        }(t2));
      }
      get app() {
        if (!this._app)
          throw new j(K.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
        return this._app;
      }
      get _initialized() {
        return this._settingsFrozen;
      }
      get _terminated() {
        return this._terminateTask !== void 0;
      }
      _setSettings(t2) {
        if (this._settingsFrozen)
          throw new j(K.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
        this._settings = new pa(t2), t2.credentials !== void 0 && (this._credentials = function(t3) {
          if (!t3)
            return new G();
          switch (t3.type) {
            case "gapi":
              const e = t3.client;
              return B(!(typeof e != "object" || e === null || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new Y(e, t3.sessionIndex || "0", t3.iamToken || null);
            case "provider":
              return t3.client;
            default:
              throw new j(K.INVALID_ARGUMENT, "makeCredentialsProvider failed due to invalid credential type");
          }
        }(t2.credentials));
      }
      _getSettings() {
        return this._settings;
      }
      _freezeSettings() {
        return this._settingsFrozen = true, this._settings;
      }
      _delete() {
        return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
      }
      toJSON() {
        return {
          app: this._app,
          databaseId: this._databaseId,
          settings: this._settings
        };
      }
      _terminate() {
        return function(t2) {
          const e = la.get(t2);
          e && ($("ComponentProvider", "Removing Datastore"), la.delete(t2), e.terminate());
        }(this), Promise.resolve();
      }
    };
    Ia = class {
      constructor(t2, e, n) {
        this.converter = e, this._key = n, this.type = "document", this.firestore = t2;
      }
      get _path() {
        return this._key.path;
      }
      get id() {
        return this._key.path.lastSegment();
      }
      get path() {
        return this._key.path.canonicalString();
      }
      get parent() {
        return new Ra(this.firestore, this.converter, this._key.path.popLast());
      }
      withConverter(t2) {
        return new Ia(this.firestore, t2, this._key);
      }
    };
    Aa = class {
      constructor(t2, e, n) {
        this.converter = e, this._query = n, this.type = "query", this.firestore = t2;
      }
      withConverter(t2) {
        return new Aa(this.firestore, t2, this._query);
      }
    };
    Ra = class extends Aa {
      constructor(t2, e, n) {
        super(t2, e, we(n)), this._path = n, this.type = "collection";
      }
      get id() {
        return this._query.path.lastSegment();
      }
      get path() {
        return this._query.path.canonicalString();
      }
      get parent() {
        const t2 = this._path.popLast();
        return t2.isEmpty() ? null : new Ia(this.firestore, null, new Pt(t2));
      }
      withConverter(t2) {
        return new Ra(this.firestore, t2, this._path);
      }
    };
    Da = class {
      constructor() {
        this._c = Promise.resolve(), this.mc = [], this.gc = false, this.yc = [], this.Tc = null, this.Ec = false, this.Ic = false, this.Ac = [], this.ar = new Xr(this, "async_queue_retry"), this.Rc = () => {
          const t3 = Jr();
          t3 && $("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.ar.tr();
        };
        const t2 = Jr();
        t2 && typeof t2.addEventListener == "function" && t2.addEventListener("visibilitychange", this.Rc);
      }
      get isShuttingDown() {
        return this.gc;
      }
      enqueueAndForget(t2) {
        this.enqueue(t2);
      }
      enqueueAndForgetEvenWhileRestricted(t2) {
        this.bc(), this.Pc(t2);
      }
      enterRestrictedMode(t2) {
        if (!this.gc) {
          this.gc = true, this.Ic = t2 || false;
          const e = Jr();
          e && typeof e.removeEventListener == "function" && e.removeEventListener("visibilitychange", this.Rc);
        }
      }
      enqueue(t2) {
        if (this.bc(), this.gc)
          return new Promise(() => {
          });
        const e = new Q();
        return this.Pc(() => this.gc && this.Ic ? Promise.resolve() : (t2().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
      }
      enqueueRetryable(t2) {
        this.enqueueAndForget(() => (this.mc.push(t2), this.vc()));
      }
      async vc() {
        if (this.mc.length !== 0) {
          try {
            await this.mc[0](), this.mc.shift(), this.ar.reset();
          } catch (t2) {
            if (!Hs(t2))
              throw t2;
            $("AsyncQueue", "Operation failed with retryable error: " + t2);
          }
          this.mc.length > 0 && this.ar.Xi(() => this.vc());
        }
      }
      Pc(t2) {
        const e = this._c.then(() => (this.Ec = true, t2().catch((t3) => {
          this.Tc = t3, this.Ec = false;
          const e2 = function(t4) {
            let e3 = t4.message || "";
            t4.stack && (e3 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
            return e3;
          }(t3);
          throw O("INTERNAL UNHANDLED ERROR: ", e2), t3;
        }).then((t3) => (this.Ec = false, t3))));
        return this._c = e, e;
      }
      enqueueAfterDelay(t2, e, n) {
        this.bc(), this.Ac.indexOf(t2) > -1 && (e = 0);
        const s2 = xo.createAndSchedule(this, t2, e, n, (t3) => this.Vc(t3));
        return this.yc.push(s2), s2;
      }
      bc() {
        this.Tc && L();
      }
      verifyOperationInProgress() {
      }
      async Sc() {
        let t2;
        do {
          t2 = this._c, await t2;
        } while (t2 !== this._c);
      }
      Dc(t2) {
        for (const e of this.yc)
          if (e.timerId === t2)
            return true;
        return false;
      }
      Cc(t2) {
        return this.Sc().then(() => {
          this.yc.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
          for (const e of this.yc)
            if (e.skipDelay(), t2 !== "all" && e.timerId === t2)
              break;
          return this.Sc();
        });
      }
      Nc(t2) {
        this.Ac.push(t2);
      }
      Vc(t2) {
        const e = this.yc.indexOf(t2);
        this.yc.splice(e, 1);
      }
    };
    ka = class extends Ta {
      constructor(t2, e) {
        super(t2, e), this.type = "firestore", this._queue = new Da(), this._persistenceKey = "name" in t2 ? t2.name : "[DEFAULT]";
      }
      _terminate() {
        return this._firestoreClient || Ma(this), this._firestoreClient.terminate();
      }
    };
    Ja = class {
      constructor(...t2) {
        for (let e = 0; e < t2.length; ++e)
          if (t2[e].length === 0)
            throw new j(K.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
        this._internalPath = new ft(t2);
      }
      isEqual(t2) {
        return this._internalPath.isEqual(t2._internalPath);
      }
    };
    Xa = class {
      constructor(t2) {
        this._byteString = t2;
      }
      static fromBase64String(t2) {
        try {
          return new Xa(_t.fromBase64String(t2));
        } catch (t3) {
          throw new j(K.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
        }
      }
      static fromUint8Array(t2) {
        return new Xa(_t.fromUint8Array(t2));
      }
      toBase64() {
        return this._byteString.toBase64();
      }
      toUint8Array() {
        return this._byteString.toUint8Array();
      }
      toString() {
        return "Bytes(base64: " + this.toBase64() + ")";
      }
      isEqual(t2) {
        return this._byteString.isEqual(t2._byteString);
      }
    };
    Za = class {
      constructor(t2) {
        this._methodName = t2;
      }
    };
    tu = class {
      constructor(t2, e) {
        if (!isFinite(t2) || t2 < -90 || t2 > 90)
          throw new j(K.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
        if (!isFinite(e) || e < -180 || e > 180)
          throw new j(K.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
        this._lat = t2, this._long = e;
      }
      get latitude() {
        return this._lat;
      }
      get longitude() {
        return this._long;
      }
      isEqual(t2) {
        return this._lat === t2._lat && this._long === t2._long;
      }
      toJSON() {
        return {
          latitude: this._lat,
          longitude: this._long
        };
      }
      _compareTo(t2) {
        return et(this._lat, t2._lat) || et(this._long, t2._long);
      }
    };
    eu = /^__.*__$/;
    nu = class {
      constructor(t2, e, n) {
        this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
      }
      toMutation(t2, e) {
        return this.fieldMask !== null ? new nn(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new en(t2, this.data, e, this.fieldTransforms);
      }
    };
    su = class {
      constructor(t2, e, n) {
        this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
      }
      toMutation(t2, e) {
        return new nn(t2, this.data, this.fieldMask, e, this.fieldTransforms);
      }
    };
    ru = class {
      constructor(t2, e, n, s2, i, r) {
        this.settings = t2, this.databaseId = e, this.N = n, this.ignoreUndefinedProperties = s2, i === void 0 && this.xc(), this.fieldTransforms = i || [], this.fieldMask = r || [];
      }
      get path() {
        return this.settings.path;
      }
      get kc() {
        return this.settings.kc;
      }
      $c(t2) {
        return new ru(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.N, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
      }
      Oc(t2) {
        var e;
        const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s2 = this.$c({
          path: n,
          Fc: false
        });
        return s2.Mc(t2), s2;
      }
      Lc(t2) {
        var e;
        const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s2 = this.$c({
          path: n,
          Fc: false
        });
        return s2.xc(), s2;
      }
      Bc(t2) {
        return this.$c({
          path: void 0,
          Fc: true
        });
      }
      Uc(t2) {
        return bu(t2, this.settings.methodName, this.settings.qc || false, this.path, this.settings.Kc);
      }
      contains(t2) {
        return this.fieldMask.find((e) => t2.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t2.isPrefixOf(e.field)) !== void 0;
      }
      xc() {
        if (this.path)
          for (let t2 = 0; t2 < this.path.length; t2++)
            this.Mc(this.path.get(t2));
      }
      Mc(t2) {
        if (t2.length === 0)
          throw this.Uc("Document fields must not be empty");
        if (iu(this.kc) && eu.test(t2))
          throw this.Uc('Document fields cannot begin and end with "__"');
      }
    };
    ou = class {
      constructor(t2, e, n) {
        this.databaseId = t2, this.ignoreUndefinedProperties = e, this.N = n || Yr(t2);
      }
      jc(t2, e, n, s2 = false) {
        return new ru({
          kc: t2,
          methodName: e,
          Kc: n,
          path: ft.emptyPath(),
          Fc: false,
          qc: s2
        }, this.databaseId, this.N, this.ignoreUndefinedProperties);
      }
    };
    uu = class extends Za {
      _toFieldTransform(t2) {
        if (t2.kc !== 2)
          throw t2.kc === 1 ? t2.Uc(`${this._methodName}() can only appear at the top level of your update data`) : t2.Uc(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
        return t2.fieldMask.push(t2.path), null;
      }
      isEqual(t2) {
        return t2 instanceof uu;
      }
    };
    lu = class extends Za {
      _toFieldTransform(t2) {
        return new je(t2.path, new Oe());
      }
      isEqual(t2) {
        return t2 instanceof lu;
      }
    };
    fu = class extends Za {
      constructor(t2, e) {
        super(t2), this.Qc = e;
      }
      _toFieldTransform(t2) {
        const e = hu(this, t2, true), n = this.Qc.map((t3) => yu(t3, e)), s2 = new Fe(n);
        return new je(t2.path, s2);
      }
      isEqual(t2) {
        return this === t2;
      }
    };
    wu = class extends Za {
      constructor(t2, e) {
        super(t2), this.Wc = e;
      }
      _toFieldTransform(t2) {
        const e = new Ue(t2.N, Ce(t2.N, this.Wc));
        return new je(t2.path, e);
      }
      isEqual(t2) {
        return this === t2;
      }
    };
    Au = new RegExp("[~\\*/\\[\\]]");
    vu = class {
      constructor(t2, e, n, s2, i) {
        this._firestore = t2, this._userDataWriter = e, this._key = n, this._document = s2, this._converter = i;
      }
      get id() {
        return this._key.path.lastSegment();
      }
      get ref() {
        return new Ia(this._firestore, this._converter, this._key);
      }
      exists() {
        return this._document !== null;
      }
      data() {
        if (this._document) {
          if (this._converter) {
            const t2 = new Vu(this._firestore, this._userDataWriter, this._key, this._document, null);
            return this._converter.fromFirestore(t2);
          }
          return this._userDataWriter.convertValue(this._document.data.value);
        }
      }
      get(t2) {
        if (this._document) {
          const e = this._document.data.field(Su("DocumentSnapshot.get", t2));
          if (e !== null)
            return this._userDataWriter.convertValue(e);
        }
      }
    };
    Vu = class extends vu {
      data() {
        return super.data();
      }
    };
    Du = class {
      constructor(t2, e) {
        this.hasPendingWrites = t2, this.fromCache = e;
      }
      isEqual(t2) {
        return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
      }
    };
    Cu = class extends vu {
      constructor(t2, e, n, s2, i, r) {
        super(t2, e, n, s2, r), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
      }
      exists() {
        return super.exists();
      }
      data(t2 = {}) {
        if (this._document) {
          if (this._converter) {
            const e = new Nu(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
            return this._converter.fromFirestore(e, t2);
          }
          return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
        }
      }
      get(t2, e = {}) {
        if (this._document) {
          const n = this._document.data.field(Su("DocumentSnapshot.get", t2));
          if (n !== null)
            return this._userDataWriter.convertValue(n, e.serverTimestamps);
        }
      }
    };
    Nu = class extends Cu {
      data(t2 = {}) {
        return super.data(t2);
      }
    };
    xu = class {
      constructor(t2, e, n, s2) {
        this._firestore = t2, this._userDataWriter = e, this._snapshot = s2, this.metadata = new Du(s2.hasPendingWrites, s2.fromCache), this.query = n;
      }
      get docs() {
        const t2 = [];
        return this.forEach((e) => t2.push(e)), t2;
      }
      get size() {
        return this._snapshot.docs.size;
      }
      get empty() {
        return this.size === 0;
      }
      forEach(t2, e) {
        this._snapshot.docs.forEach((n) => {
          t2.call(e, new Nu(this._firestore, this._userDataWriter, n.key, n, new Du(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
        });
      }
      docChanges(t2 = {}) {
        const e = !!t2.includeMetadataChanges;
        if (e && this._snapshot.excludesMetadataChanges)
          throw new j(K.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
        return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
          if (t3._snapshot.oldDocs.isEmpty()) {
            let e3 = 0;
            return t3._snapshot.docChanges.map((n) => ({
              type: "added",
              doc: new Nu(t3._firestore, t3._userDataWriter, n.doc.key, n.doc, new Du(t3._snapshot.mutatedKeys.has(n.doc.key), t3._snapshot.fromCache), t3.query.converter),
              oldIndex: -1,
              newIndex: e3++
            }));
          }
          {
            let n = t3._snapshot.oldDocs;
            return t3._snapshot.docChanges.filter((t4) => e2 || t4.type !== 3).map((e3) => {
              const s2 = new Nu(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new Du(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query.converter);
              let i = -1, r = -1;
              return e3.type !== 0 && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), e3.type !== 1 && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
                type: ku(e3.type),
                doc: s2,
                oldIndex: i,
                newIndex: r
              };
            });
          }
        }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
      }
    };
    Fu = class {
    };
    Uu = class extends Fu {
      constructor(t2, e) {
        super(), this.Gc = t2, this.Jc = e, this.type = "orderBy";
      }
      _apply(t2) {
        const e = function(t3, e2, n) {
          if (t3.startAt !== null)
            throw new j(K.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
          if (t3.endAt !== null)
            throw new j(K.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
          const s2 = new ae(e2, n);
          return function(t4, e3) {
            if (ge(t4) === null) {
              const n2 = ye(t4);
              n2 !== null && eh(t4, n2, e3.field);
            }
          }(t3, s2), s2;
        }(t2._query, this.Gc, this.Jc);
        return new Aa(t2.firestore, t2.converter, function(t3, e2) {
          const n = t3.explicitOrderBy.concat([e2]);
          return new fe(t3.path, t3.collectionGroup, n, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
        }(t2._query, e));
      }
    };
    nh = class {
      convertValue(t2, e = "none") {
        switch (vt(t2)) {
          case 0:
            return null;
          case 1:
            return t2.booleanValue;
          case 2:
            return yt(t2.integerValue || t2.doubleValue);
          case 3:
            return this.convertTimestamp(t2.timestampValue);
          case 4:
            return this.convertServerTimestamp(t2, e);
          case 5:
            return t2.stringValue;
          case 6:
            return this.convertBytes(pt(t2.bytesValue));
          case 7:
            return this.convertReference(t2.referenceValue);
          case 8:
            return this.convertGeoPoint(t2.geoPointValue);
          case 9:
            return this.convertArray(t2.arrayValue, e);
          case 10:
            return this.convertObject(t2.mapValue, e);
          default:
            throw L();
        }
      }
      convertObject(t2, e) {
        const n = {};
        return ct(t2.fields, (t3, s2) => {
          n[t3] = this.convertValue(s2, e);
        }), n;
      }
      convertGeoPoint(t2) {
        return new tu(yt(t2.latitude), yt(t2.longitude));
      }
      convertArray(t2, e) {
        return (t2.values || []).map((t3) => this.convertValue(t3, e));
      }
      convertServerTimestamp(t2, e) {
        switch (e) {
          case "previous":
            const n = Et(t2);
            return n == null ? null : this.convertValue(n, e);
          case "estimate":
            return this.convertTimestamp(It(t2));
          default:
            return null;
        }
      }
      convertTimestamp(t2) {
        const e = gt(t2);
        return new it(e.seconds, e.nanos);
      }
      convertDocumentKey(t2, e) {
        const n = ht.fromString(t2);
        B(Ts(n));
        const s2 = new ha(n.get(1), n.get(3)), i = new Pt(n.popFirst(5));
        return s2.isEqual(e) || O(`Document ${i} contains a document reference within a different database (${s2.projectId}/${s2.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
      }
    };
    rh = class {
      constructor(t2, e) {
        this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = cu(t2);
      }
      set(t2, e, n) {
        this._verifyNotCommitted();
        const s2 = oh(t2, this._firestore), i = sh(s2.converter, e, n), r = au(this._dataReader, "WriteBatch.set", s2._key, i, s2.converter !== null, n);
        return this._mutations.push(r.toMutation(s2._key, Ge.none())), this;
      }
      update(t2, e, n, ...s2) {
        this._verifyNotCommitted();
        const i = oh(t2, this._firestore);
        let r;
        return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Ja ? mu(this._dataReader, "WriteBatch.update", i._key, e, n, s2) : _u(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, Ge.exists(true))), this;
      }
      delete(t2) {
        this._verifyNotCommitted();
        const e = oh(t2, this._firestore);
        return this._mutations = this._mutations.concat(new cn(e._key, Ge.none())), this;
      }
      commit() {
        return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
      }
      _verifyNotCommitted() {
        if (this._committed)
          throw new j(K.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
      }
    };
    ah = class extends nh {
      constructor(t2) {
        super(), this.firestore = t2;
      }
      convertBytes(t2) {
        return new Xa(t2);
      }
      convertReference(t2) {
        const e = this.convertDocumentKey(t2, this.firestore._databaseId);
        return new Ia(this.firestore, null, e);
      }
    };
    !function(t2, e = true) {
      !function(t3) {
        C = t3;
      }(SDK_VERSION), _registerComponent(new Component("firestore", (t3, { options: n }) => {
        const s2 = t3.getProvider("app").getImmediate(), i = new ka(s2, new H(t3.getProvider("auth-internal")));
        return n = Object.assign({
          useFetchStreams: e
        }, n), i._setSettings(n), i;
      }, "PUBLIC")), registerVersion(S, "3.3.1", t2), registerVersion(S, "3.3.1", "esm2017");
    }();
    extendStatics = function(d2, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d22, b2) {
        d22.__proto__ = b2;
      } || function(d22, b2) {
        for (var p2 in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p2))
            d22[p2] = b2[p2];
      };
      return extendStatics(d2, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t2) {
        for (var s2, i = 1, n = arguments.length; i < n; i++) {
          s2 = arguments[i];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    subscriber_queue = [];
    displayDate = function(dateString, format2 = {
      month: "short",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      timeZone: "utc"
    }) {
      const deserializedDate = new Date(dateString);
      let currentTimeZoneOffset = deserializedDate.getTimezoneOffset() * 6e4;
      return new Date(deserializedDate - currentTimeZoneOffset).toLocaleDateString("en-US", format2);
    };
    canvasHeight = writable(0);
    canvasWidth = writable(0);
    hasFetchedUser = writable(false);
    user = writable({});
    currentTool = writable({
      type: "pencil",
      color: "white",
      lineWidth: 3
    });
    onlyAllowApplePencil = writable(true);
    dailyMicStream = writable(null);
    roomToPeople = writable({});
    dailyRoomParticipants = writable({});
    browserTabID = readable(getRandomID());
    isFirestoreDocCreated = writable(false);
    willPreventPageLeave = writable(false);
  }
});

// node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "node_modules/webidl-conversions/lib/index.js"(exports, module2) {
    init_shims();
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x2) {
      return x2 < 0 ? -1 : 1;
    }
    function evenRound(x2) {
      if (x2 % 1 === 0.5 && (x2 & 1) === 0) {
        return Math.floor(x2);
      } else {
        return Math.round(x2);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V2, opts) {
        if (!opts)
          opts = {};
        let x2 = +V2;
        if (opts.enforceRange) {
          if (!Number.isFinite(x2)) {
            throw new TypeError("Argument is not a finite number");
          }
          x2 = sign(x2) * Math.floor(Math.abs(x2));
          if (x2 < lowerBound || x2 > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x2;
        }
        if (!isNaN(x2) && opts.clamp) {
          x2 = evenRound(x2);
          if (x2 < lowerBound)
            x2 = lowerBound;
          if (x2 > upperBound)
            x2 = upperBound;
          return x2;
        }
        if (!Number.isFinite(x2) || x2 === 0) {
          return 0;
        }
        x2 = sign(x2) * Math.floor(Math.abs(x2));
        x2 = x2 % moduloVal;
        if (!typeOpts.unsigned && x2 >= moduloBound) {
          return x2 - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x2 < 0) {
            x2 += moduloVal;
          } else if (x2 === -0) {
            return 0;
          }
        }
        return x2;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V2) {
      const x2 = +V2;
      if (!Number.isFinite(x2)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x2;
    };
    conversions["unrestricted double"] = function(V2) {
      const x2 = +V2;
      if (isNaN(x2)) {
        throw new TypeError("Argument is NaN");
      }
      return x2;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V2, opts) {
      if (!opts)
        opts = {};
      if (opts.treatNullAsEmptyString && V2 === null) {
        return "";
      }
      return String(V2);
    };
    conversions["ByteString"] = function(V2, opts) {
      const x2 = String(V2);
      let c = void 0;
      for (let i = 0; (c = x2.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x2;
    };
    conversions["USVString"] = function(V2) {
      const S2 = String(V2);
      const n = S2.length;
      const U2 = [];
      for (let i = 0; i < n; ++i) {
        const c = S2.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U2.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U2.push(String.fromCodePoint(65533));
        } else {
          if (i === n - 1) {
            U2.push(String.fromCodePoint(65533));
          } else {
            const d2 = S2.charCodeAt(i + 1);
            if (56320 <= d2 && d2 <= 57343) {
              const a = c & 1023;
              const b = d2 & 1023;
              U2.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U2.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U2.join("");
    };
    conversions["Date"] = function(V2, opts) {
      if (!(V2 instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V2)) {
        return void 0;
      }
      return V2;
    };
    conversions["RegExp"] = function(V2, opts) {
      if (!(V2 instanceof RegExp)) {
        V2 = new RegExp(V2);
      }
      return V2;
    };
  }
});

// node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({
  "node_modules/whatwg-url/lib/utils.js"(exports, module2) {
    init_shims();
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i = 0; i < keys.length; ++i) {
        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/tr46/lib/mappingTable.json"(exports, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/tr46/index.js"(exports, module2) {
    init_shims();
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize2(str) {
      return str.split("\0").map(function(s2) {
        return s2.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start2 = 0;
      var end = mappingTable.length - 1;
      while (start2 <= end) {
        var mid = Math.floor((start2 + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start2 = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error3 = false;
      if (normalize2(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error3 = true;
      }
      var len = countSymbols(label);
      for (var i = 0; i < len; ++i) {
        var status = findStatus(label.codePointAt(i));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error3 = true;
          break;
        }
      }
      return {
        label,
        error: error3
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize2(result.string);
      var labels = result.string.split(".");
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i]);
          labels[i] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l2) {
        try {
          return punycode.toASCII(l2);
        } catch (e) {
          result.error = true;
          return l2;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error)
        return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/whatwg-url/lib/url-state-machine.js"(exports, module2) {
    init_shims();
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at2(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme2) {
      return specialSchemes[scheme2] !== void 0;
    }
    function isSpecial(url2) {
      return isSpecialScheme(url2.scheme);
    }
    function defaultPort(scheme2) {
      return specialSchemes[scheme2];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37) {
          output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
          output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
          i += 2;
        } else {
          output.push(input[i]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R3 = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R3 = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R3 = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R3 === 10 ? /[^0-9]/ : R3 === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R3);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers2 = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers2.push(n);
      }
      for (let i = 0; i < numbers2.length - 1; ++i) {
        if (numbers2[i] > 255) {
          return failure;
        }
      }
      if (numbers2[numbers2.length - 1] >= Math.pow(256, 5 - numbers2.length)) {
        return failure;
      }
      let ipv4 = numbers2.pop();
      let counter3 = 0;
      for (const n of numbers2) {
        ipv4 += n * Math.pow(256, 3 - counter3);
        ++counter3;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at2(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at2(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i = 0; i < decoded.length; ++i) {
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url2) {
      return url2.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url2) {
      return url2.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url2) {
      const path = url2.path;
      if (path.length === 0) {
        return;
      }
      if (url2.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
      }
      path.pop();
    }
    function includesCredentials(url2) {
      return url2.username !== "" || url2.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url2) {
      return url2.host === null || url2.host === "" || url2.cannotBeABaseURL || url2.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base3, encodingOverride, url2, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base3 || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url2;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
            this.url.query += percentEncode(buffer[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url2, excludeFragment) {
      let output = url2.scheme + ":";
      if (url2.host !== null) {
        output += "//";
        if (url2.username !== "" || url2.password !== "") {
          output += url2.username;
          if (url2.password !== "") {
            output += ":" + url2.password;
          }
          output += "@";
        }
        output += serializeHost(url2.host);
        if (url2.port !== null) {
          output += ":" + url2.port;
        }
      } else if (url2.host === null && url2.scheme === "file") {
        output += "//";
      }
      if (url2.cannotBeABaseURL) {
        output += url2.path[0];
      } else {
        for (const string of url2.path) {
          output += "/" + string;
        }
      }
      if (url2.query !== null) {
        output += "?" + url2.query;
      }
      if (!excludeFragment && url2.fragment !== null) {
        output += "#" + url2.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url2) {
      switch (url2.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url2.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url2.scheme,
            host: url2.host,
            port: url2.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      const usm = new URLStateMachine(input, options2.baseURL, options2.encodingOverride, options2.url, options2.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url2, username) {
      url2.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url2.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url2, password) {
      url2.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i = 0; i < decoded.length; ++i) {
        url2.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options2.baseURL, encodingOverride: options2.encodingOverride });
    };
  }
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    init_shims();
    "use strict";
    var usm = require_url_state_machine();
    exports.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url2 = constructorArgs[0];
        const base3 = constructorArgs[1];
        let parsedBase = null;
        if (base3 !== void 0) {
          parsedBase = usm.basicURLParse(base3);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url2, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v2) {
        const parsedURL = usm.basicURLParse(v2);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v2) {
        usm.basicURLParse(v2 + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v2);
      }
      get password() {
        return this._url.password;
      }
      set password(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v2);
      }
      get host() {
        const url2 = this._url;
        if (url2.host === null) {
          return "";
        }
        if (url2.port === null) {
          return usm.serializeHost(url2.host);
        }
        return usm.serializeHost(url2.host) + ":" + usm.serializeInteger(url2.port);
      }
      set host(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v2, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v2, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v2 === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v2, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v2, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v2) {
        const url2 = this._url;
        if (v2 === "") {
          url2.query = null;
          return;
        }
        const input = v2[0] === "?" ? v2.substring(1) : v2;
        url2.query = "";
        usm.basicURLParse(input, { url: url2, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v2) {
        if (v2 === "") {
          this._url.fragment = null;
          return;
        }
        const input = v2[0] === "#" ? v2.substring(1) : v2;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/whatwg-url/lib/URL.js"(exports, module2) {
    init_shims();
    "use strict";
    var conversions = require_lib();
    var utils = require_utils();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL2(url2) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].href = V2;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].protocol = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].username = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].password = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].host = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].hostname = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].port = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].pathname = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].search = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].hash = V2;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    };
  }
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/whatwg-url/lib/public-api.js"(exports) {
    init_shims();
    "use strict";
    exports.URL = require_URL().interface;
    exports.serializeURL = require_url_state_machine().serializeURL;
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports.basicURLParse = require_url_state_machine().basicURLParse;
    exports.setTheUsername = require_url_state_machine().setTheUsername;
    exports.setThePassword = require_url_state_machine().setThePassword;
    exports.serializeHost = require_url_state_machine().serializeHost;
    exports.serializeInteger = require_url_state_machine().serializeInteger;
    exports.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports, module2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream3 = _interopDefault(require("stream"));
    var http2 = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https2 = _interopDefault(require("https"));
    var zlib2 = _interopDefault(require("zlib"));
    var Readable = Stream3.Readable;
    var BUFFER2 = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob3 = class {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options2 = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof Blob3) {
              buffer = element[BUFFER2];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER2] = Buffer.concat(buffers);
        let type = options2 && options2.type !== void 0 && String(options2.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER2].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER2].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER2];
        const ab2 = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab2);
      }
      stream() {
        const readable2 = new Readable();
        readable2._read = function() {
        };
        readable2.push(this[BUFFER2]);
        readable2.push(null);
        return readable2;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start2 = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start2 === void 0) {
          relativeStart = 0;
        } else if (start2 < 0) {
          relativeStart = Math.max(size + start2, 0);
        } else {
          relativeStart = Math.min(start2, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER2];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob3([], { type: arguments[2] });
        blob[BUFFER2] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob3.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob3.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError2(message2, type, systemError) {
      Error.call(this, message2);
      this.message = message2;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError2.prototype = Object.create(Error.prototype);
    FetchError2.prototype.constructor = FetchError2;
    FetchError2.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS2 = Symbol("Body internals");
    var PassThrough2 = Stream3.PassThrough;
    function Body2(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob2(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream3)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS2] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream3) {
        body.on("error", function(err) {
          const error3 = err.name === "AbortError" ? err : new FetchError2(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS2].error = error3;
        });
      }
    }
    Body2.prototype = {
      get body() {
        return this[INTERNALS2].body;
      },
      get bodyUsed() {
        return this[INTERNALS2].disturbed;
      },
      arrayBuffer() {
        return consumeBody2.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      blob() {
        let ct2 = this.headers && this.headers.get("content-type") || "";
        return consumeBody2.call(this).then(function(buf) {
          return Object.assign(new Blob3([], {
            type: ct2.toLowerCase()
          }), {
            [BUFFER2]: buf
          });
        });
      },
      json() {
        var _this2 = this;
        return consumeBody2.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body2.Promise.reject(new FetchError2(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      text() {
        return consumeBody2.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      buffer() {
        return consumeBody2.call(this);
      },
      textConverted() {
        var _this3 = this;
        return consumeBody2.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body2.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body2.mixIn = function(proto) {
      for (const name6 of Object.getOwnPropertyNames(Body2.prototype)) {
        if (!(name6 in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body2.prototype, name6);
          Object.defineProperty(proto, name6, desc);
        }
      }
    };
    function consumeBody2() {
      var _this4 = this;
      if (this[INTERNALS2].disturbed) {
        return Body2.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS2].disturbed = true;
      if (this[INTERNALS2].error) {
        return Body2.Promise.reject(this[INTERNALS2].error);
      }
      let body = this.body;
      if (body === null) {
        return Body2.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob2(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body2.Promise.resolve(body);
      }
      if (!(body instanceof Stream3)) {
        return Body2.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body2.Promise(function(resolve2, reject2) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject2(new FetchError2(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject2(err);
          } else {
            reject2(new FetchError2(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject2(new FetchError2(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve2(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject2(new FetchError2(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers2) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct2 = headers2.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct2) {
        res = /charset=([^;]*)/i.exec(ct2);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob2(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone2(instance2) {
      let p1, p2;
      let body = instance2.body;
      if (instance2.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream3 && typeof body.getBoundary !== "function") {
        p1 = new PassThrough2();
        p2 = new PassThrough2();
        body.pipe(p1);
        body.pipe(p2);
        instance2[INTERNALS2].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType2(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob2(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream3) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes2(instance2) {
      const body = instance2.body;
      if (body === null) {
        return 0;
      } else if (isBlob2(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream2(dest, instance2) {
      const body = instance2.body;
      if (body === null) {
        dest.end();
      } else if (isBlob2(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body2.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name6) {
      name6 = `${name6}`;
      if (invalidTokenRegex.test(name6) || name6 === "") {
        throw new TypeError(`${name6} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map2, name6) {
      name6 = name6.toLowerCase();
      for (const key in map2) {
        if (key.toLowerCase() === name6) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers4 = class {
      constructor() {
        let init2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = Object.create(null);
        if (init2 instanceof Headers4) {
          const rawHeaders = init2.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init2 == null)
          ;
        else if (typeof init2 === "object") {
          const method = init2[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init2) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init2)) {
              const value = init2[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      get(name6) {
        name6 = `${name6}`;
        validateName(name6);
        const key = find(this[MAP], name6);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name6 = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name6, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      set(name6, value) {
        name6 = `${name6}`;
        value = `${value}`;
        validateName(name6);
        validateValue(value);
        const key = find(this[MAP], name6);
        this[MAP][key !== void 0 ? key : name6] = [value];
      }
      append(name6, value) {
        name6 = `${name6}`;
        value = `${value}`;
        validateName(name6);
        validateValue(value);
        const key = find(this[MAP], name6);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name6] = [value];
        }
      }
      has(name6) {
        name6 = `${name6}`;
        validateName(name6);
        return find(this[MAP], name6) !== void 0;
      }
      delete(name6) {
        name6 = `${name6}`;
        validateName(name6);
        const key = find(this[MAP], name6);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      raw() {
        return this[MAP];
      }
      keys() {
        return createHeadersIterator(this, "key");
      }
      values() {
        return createHeadersIterator(this, "value");
      }
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers4.prototype.entries = Headers4.prototype[Symbol.iterator];
    Object.defineProperty(Headers4.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers4.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers2) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers2[MAP]).sort();
      return keys.map(kind === "key" ? function(k2) {
        return k2.toLowerCase();
      } : kind === "value" ? function(k2) {
        return headers2[MAP][k2].join(", ");
      } : function(k2) {
        return [k2.toLowerCase(), headers2[MAP][k2].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers2) {
      const obj = Object.assign({ __proto__: null }, headers2[MAP]);
      const hostHeaderKey = find(headers2[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers2 = new Headers4();
      for (const name6 of Object.keys(obj)) {
        if (invalidTokenRegex.test(name6)) {
          continue;
        }
        if (Array.isArray(obj[name6])) {
          for (const val of obj[name6]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers2[MAP][name6] === void 0) {
              headers2[MAP][name6] = [val];
            } else {
              headers2[MAP][name6].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name6])) {
          headers2[MAP][name6] = [obj[name6]];
        }
      }
      return headers2;
    }
    var INTERNALS$12 = Symbol("Response internals");
    var STATUS_CODES = http2.STATUS_CODES;
    var Response3 = class {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body2.call(this, body, opts);
        const status = opts.status || 200;
        const headers2 = new Headers4(opts.headers);
        if (body != null && !headers2.has("Content-Type")) {
          const contentType = extractContentType2(body);
          if (contentType) {
            headers2.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$12] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers: headers2,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$12].url || "";
      }
      get status() {
        return this[INTERNALS$12].status;
      }
      get ok() {
        return this[INTERNALS$12].status >= 200 && this[INTERNALS$12].status < 300;
      }
      get redirected() {
        return this[INTERNALS$12].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$12].statusText;
      }
      get headers() {
        return this[INTERNALS$12].headers;
      }
      clone() {
        return new Response3(clone2(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body2.mixIn(Response3.prototype);
    Object.defineProperties(Response3.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response3.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$22 = Symbol("Request internals");
    var URL2 = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream3.Readable.prototype;
    function isRequest2(input) {
      return typeof input === "object" && typeof input[INTERNALS$22] === "object";
    }
    function isAbortSignal2(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request2 = class {
      constructor(input) {
        let init2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest2(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest2(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init2.body != null ? init2.body : isRequest2(input) && input.body !== null ? clone2(input) : null;
        Body2.call(this, inputBody, {
          timeout: init2.timeout || input.timeout || 0,
          size: init2.size || input.size || 0
        });
        const headers2 = new Headers4(init2.headers || input.headers || {});
        if (inputBody != null && !headers2.has("Content-Type")) {
          const contentType = extractContentType2(inputBody);
          if (contentType) {
            headers2.append("Content-Type", contentType);
          }
        }
        let signal = isRequest2(input) ? input.signal : null;
        if ("signal" in init2)
          signal = init2.signal;
        if (signal != null && !isAbortSignal2(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$22] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers: headers2,
          parsedURL,
          signal
        };
        this.follow = init2.follow !== void 0 ? init2.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init2.compress !== void 0 ? init2.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$22].method;
      }
      get url() {
        return format_url(this[INTERNALS$22].parsedURL);
      }
      get headers() {
        return this[INTERNALS$22].headers;
      }
      get redirect() {
        return this[INTERNALS$22].redirect;
      }
      get signal() {
        return this[INTERNALS$22].signal;
      }
      clone() {
        return new Request2(this);
      }
    };
    Body2.mixIn(Request2.prototype);
    Object.defineProperty(Request2.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions2(request) {
      const parsedURL = request[INTERNALS$22].parsedURL;
      const headers2 = new Headers4(request[INTERNALS$22].headers);
      if (!headers2.has("Accept")) {
        headers2.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream3.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes2(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers2.set("Content-Length", contentLengthValue);
      }
      if (!headers2.has("User-Agent")) {
        headers2.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers2.has("Accept-Encoding")) {
        headers2.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers2.has("Connection") && !agent) {
        headers2.set("Connection", "close");
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers2),
        agent
      });
    }
    function AbortError2(message2) {
      Error.call(this, message2);
      this.type = "aborted";
      this.message = message2;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError2.prototype = Object.create(Error.prototype);
    AbortError2.prototype.constructor = AbortError2;
    AbortError2.prototype.name = "AbortError";
    var PassThrough$1 = Stream3.PassThrough;
    var resolve_url = Url.resolve;
    function fetch2(url2, opts) {
      if (!fetch2.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body2.Promise = fetch2.Promise;
      return new fetch2.Promise(function(resolve2, reject2) {
        const request = new Request2(url2, opts);
        const options2 = getNodeRequestOptions2(request);
        const send = (options2.protocol === "https:" ? https2 : http2).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error3 = new AbortError2("The user aborted a request.");
          reject2(error3);
          if (request.body && request.body instanceof Stream3.Readable) {
            request.body.destroy(error3);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error3);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options2);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject2(new FetchError2(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject2(new FetchError2(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          finalize();
        });
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers2 = createHeadersLenient(res.headers);
          if (fetch2.isRedirect(res.statusCode)) {
            const location2 = headers2.get("Location");
            const locationURL = location2 === null ? null : resolve_url(request.url, location2);
            switch (request.redirect) {
              case "error":
                reject2(new FetchError2(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers2.set("Location", locationURL);
                  } catch (err) {
                    reject2(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject2(new FetchError2(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers4(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (res.statusCode !== 303 && request.body && getTotalBytes2(request) === null) {
                  reject2(new FetchError2("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve2(fetch2(new Request2(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: headers2,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers2.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response3(body, response_options);
            resolve2(response);
            return;
          }
          const zlibOptions = {
            flush: zlib2.Z_SYNC_FLUSH,
            finishFlush: zlib2.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib2.createGunzip(zlibOptions));
            response = new Response3(body, response_options);
            resolve2(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib2.createInflate());
              } else {
                body = body.pipe(zlib2.createInflateRaw());
              }
              response = new Response3(body, response_options);
              resolve2(response);
            });
            return;
          }
          if (codings == "br" && typeof zlib2.createBrotliDecompress === "function") {
            body = body.pipe(zlib2.createBrotliDecompress());
            response = new Response3(body, response_options);
            resolve2(response);
            return;
          }
          response = new Response3(body, response_options);
          resolve2(response);
        });
        writeToStream2(req, request);
      });
    }
    fetch2.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch2.Promise = global.Promise;
    module2.exports = exports = fetch2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = exports;
    exports.Headers = Headers4;
    exports.Request = Request2;
    exports.Response = Response3;
    exports.FetchError = FetchError2;
  }
});

// .svelte-kit/output/server/chunks/index-c327074d-b42dfde1.js
function _prodErrorMap() {
  return {
    ["dependent-sdk-initialized-before-auth"]: "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
  };
}
function _logError(msg, ...args) {
  if (logClient.logLevel <= LogLevel.ERROR) {
    logClient.error(`Auth (${SDK_VERSION}): ${msg}`, ...args);
  }
}
function _fail(authOrCode, ...rest) {
  throw createErrorInternal(authOrCode, ...rest);
}
function _createError(authOrCode, ...rest) {
  return createErrorInternal(authOrCode, ...rest);
}
function _errorWithCustomMessage(auth, code, message2) {
  const errorMap = Object.assign(Object.assign({}, prodErrorMap()), { [code]: message2 });
  const factory2 = new ErrorFactory("auth", "Firebase", errorMap);
  return factory2.create(code, {
    appName: auth.name
  });
}
function createErrorInternal(authOrCode, ...rest) {
  if (typeof authOrCode !== "string") {
    const code = rest[0];
    const fullParams = [...rest.slice(1)];
    if (fullParams[0]) {
      fullParams[0].appName = authOrCode.name;
    }
    return authOrCode._errorFactory.create(code, ...fullParams);
  }
  return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);
}
function _assert(assertion, authOrCode, ...rest) {
  if (!assertion) {
    throw createErrorInternal(authOrCode, ...rest);
  }
}
function debugFail(failure) {
  const message2 = `INTERNAL ASSERTION FAILED: ` + failure;
  _logError(message2);
  throw new Error(message2);
}
function debugAssert(assertion, message2) {
  if (!assertion) {
    debugFail(message2);
  }
}
function _getInstance(cls) {
  debugAssert(cls instanceof Function, "Expected a class definition");
  let instance2 = instanceCache.get(cls);
  if (instance2) {
    debugAssert(instance2 instanceof cls, "Instance stored in cache mismatched with class");
    return instance2;
  }
  instance2 = new cls();
  instanceCache.set(cls, instance2);
  return instance2;
}
function initializeAuth(app, deps) {
  const provider = _getProvider(app, "auth");
  if (provider.isInitialized()) {
    const auth2 = provider.getImmediate();
    const initialOptions = provider.getOptions();
    if (deepEqual(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {
      return auth2;
    } else {
      _fail(auth2, "already-initialized");
    }
  }
  const auth = provider.initialize({ options: deps });
  return auth;
}
function _initializeAuthInstance(auth, deps) {
  const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];
  const hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);
  if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {
    auth._updateErrorMap(deps.errorMap);
  }
  auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);
}
function _isHttpOrHttps() {
  return _getCurrentScheme() === "http:" || _getCurrentScheme() === "https:";
}
function _getCurrentScheme() {
  var _a2;
  return typeof self !== "undefined" && ((_a2 = self.location) === null || _a2 === void 0 ? void 0 : _a2.protocol) || null;
}
function _isOnline() {
  if (typeof navigator !== "undefined" && navigator && "onLine" in navigator && typeof navigator.onLine === "boolean" && (_isHttpOrHttps() || isBrowserExtension() || "connection" in navigator)) {
    return navigator.onLine;
  }
  return true;
}
function _getUserLanguage() {
  if (typeof navigator === "undefined") {
    return null;
  }
  const navigatorLanguage = navigator;
  return navigatorLanguage.languages && navigatorLanguage.languages[0] || navigatorLanguage.language || null;
}
function _emulatorUrl(config, path) {
  debugAssert(config.emulator, "Emulator should always be set here");
  const { url: url2 } = config.emulator;
  if (!path) {
    return url2;
  }
  return `${url2}${path.startsWith("/") ? path.slice(1) : path}`;
}
async function _performApiRequest(auth, method, path, request, customErrorMap = {}) {
  return _performFetchWithErrorHandling(auth, customErrorMap, () => {
    let body = {};
    let params = {};
    if (request) {
      if (method === "GET") {
        params = request;
      } else {
        body = {
          body: JSON.stringify(request)
        };
      }
    }
    const query = querystring(Object.assign({ key: auth.config.apiKey }, params)).slice(1);
    const headers2 = new (FetchProvider.headers())();
    headers2.set("Content-Type", "application/json");
    headers2.set("X-Client-Version", auth._getSdkClientVersion());
    if (auth.languageCode) {
      headers2.set("X-Firebase-Locale", auth.languageCode);
    }
    return FetchProvider.fetch()(_getFinalTarget(auth, auth.config.apiHost, path, query), Object.assign({
      method,
      headers: headers2,
      referrerPolicy: "no-referrer"
    }, body));
  });
}
async function _performFetchWithErrorHandling(auth, customErrorMap, fetchFn) {
  auth._canInitEmulator = false;
  const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);
  try {
    const networkTimeout = new NetworkTimeout(auth);
    const response = await Promise.race([
      fetchFn(),
      networkTimeout.promise
    ]);
    networkTimeout.clearNetworkTimeout();
    const json = await response.json();
    if ("needConfirmation" in json) {
      throw _makeTaggedError(auth, "account-exists-with-different-credential", json);
    }
    if (response.ok && !("errorMessage" in json)) {
      return json;
    } else {
      const errorMessage = response.ok ? json.errorMessage : json.error.message;
      const [serverErrorCode, serverErrorMessage] = errorMessage.split(" : ");
      if (serverErrorCode === "FEDERATED_USER_ID_ALREADY_LINKED") {
        throw _makeTaggedError(auth, "credential-already-in-use", json);
      } else if (serverErrorCode === "EMAIL_EXISTS") {
        throw _makeTaggedError(auth, "email-already-in-use", json);
      }
      const authError = errorMap[serverErrorCode] || serverErrorCode.toLowerCase().replace(/[_\s]+/g, "-");
      if (serverErrorMessage) {
        throw _errorWithCustomMessage(auth, authError, serverErrorMessage);
      } else {
        _fail(auth, authError);
      }
    }
  } catch (e) {
    if (e instanceof FirebaseError) {
      throw e;
    }
    _fail(auth, "network-request-failed");
  }
}
function _getFinalTarget(auth, host, path, query) {
  const base3 = `${host}${path}?${query}`;
  if (!auth.config.emulator) {
    return `${auth.config.apiScheme}://${base3}`;
  }
  return _emulatorUrl(auth.config, base3);
}
function _makeTaggedError(auth, code, response) {
  const errorParams = {
    appName: auth.name
  };
  if (response.email) {
    errorParams.email = response.email;
  }
  if (response.phoneNumber) {
    errorParams.phoneNumber = response.phoneNumber;
  }
  const error3 = _createError(auth, code, errorParams);
  error3.customData._tokenResponse = response;
  return error3;
}
async function deleteAccount(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:delete", request);
}
async function getAccountInfo(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:lookup", request);
}
function utcTimestampToDateString(utcTimestamp) {
  if (!utcTimestamp) {
    return void 0;
  }
  try {
    const date = new Date(Number(utcTimestamp));
    if (!isNaN(date.getTime())) {
      return date.toUTCString();
    }
  } catch (e) {
  }
  return void 0;
}
async function getIdTokenResult(user2, forceRefresh = false) {
  const userInternal = getModularInstance(user2);
  const token = await userInternal.getIdToken(forceRefresh);
  const claims = _parseToken(token);
  _assert(claims && claims.exp && claims.auth_time && claims.iat, userInternal.auth, "internal-error");
  const firebase = typeof claims.firebase === "object" ? claims.firebase : void 0;
  const signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase["sign_in_provider"];
  return {
    claims,
    token,
    authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),
    issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),
    expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),
    signInProvider: signInProvider || null,
    signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase["sign_in_second_factor"]) || null
  };
}
function secondsStringToMilliseconds(seconds) {
  return Number(seconds) * 1e3;
}
function _parseToken(token) {
  const [algorithm, payload, signature] = token.split(".");
  if (algorithm === void 0 || payload === void 0 || signature === void 0) {
    _logError("JWT malformed, contained fewer than 3 sections");
    return null;
  }
  try {
    const decoded = base64Decode(payload);
    if (!decoded) {
      _logError("Failed to decode base64 JWT payload");
      return null;
    }
    return JSON.parse(decoded);
  } catch (e) {
    _logError("Caught error parsing JWT payload as JSON", e);
    return null;
  }
}
function _tokenExpiresIn(token) {
  const parsedToken = _parseToken(token);
  _assert(parsedToken, "internal-error");
  _assert(typeof parsedToken.exp !== "undefined", "internal-error");
  _assert(typeof parsedToken.iat !== "undefined", "internal-error");
  return Number(parsedToken.exp) - Number(parsedToken.iat);
}
async function _logoutIfInvalidated(user2, promise, bypassAuthState = false) {
  if (bypassAuthState) {
    return promise;
  }
  try {
    return await promise;
  } catch (e) {
    if (e instanceof FirebaseError && isUserInvalidated(e)) {
      if (user2.auth.currentUser === user2) {
        await user2.auth.signOut();
      }
    }
    throw e;
  }
}
function isUserInvalidated({ code }) {
  return code === `auth/${"user-disabled"}` || code === `auth/${"user-token-expired"}`;
}
async function _reloadWithoutSaving(user2) {
  var _a2;
  const auth = user2.auth;
  const idToken = await user2.getIdToken();
  const response = await _logoutIfInvalidated(user2, getAccountInfo(auth, { idToken }));
  _assert(response === null || response === void 0 ? void 0 : response.users.length, auth, "internal-error");
  const coreAccount = response.users[0];
  user2._notifyReloadListener(coreAccount);
  const newProviderData = ((_a2 = coreAccount.providerUserInfo) === null || _a2 === void 0 ? void 0 : _a2.length) ? extractProviderData(coreAccount.providerUserInfo) : [];
  const providerData = mergeProviderData(user2.providerData, newProviderData);
  const oldIsAnonymous = user2.isAnonymous;
  const newIsAnonymous = !(user2.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);
  const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;
  const updates = {
    uid: coreAccount.localId,
    displayName: coreAccount.displayName || null,
    photoURL: coreAccount.photoUrl || null,
    email: coreAccount.email || null,
    emailVerified: coreAccount.emailVerified || false,
    phoneNumber: coreAccount.phoneNumber || null,
    tenantId: coreAccount.tenantId || null,
    providerData,
    metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),
    isAnonymous
  };
  Object.assign(user2, updates);
}
async function reload(user2) {
  const userInternal = getModularInstance(user2);
  await _reloadWithoutSaving(userInternal);
  await userInternal.auth._persistUserIfCurrent(userInternal);
  userInternal.auth._notifyListenersIfCurrent(userInternal);
}
function mergeProviderData(original, newData) {
  const deduped = original.filter((o) => !newData.some((n) => n.providerId === o.providerId));
  return [...deduped, ...newData];
}
function extractProviderData(providers) {
  return providers.map((_a2) => {
    var { providerId } = _a2, provider = __rest(_a2, ["providerId"]);
    return {
      providerId,
      uid: provider.rawId || "",
      displayName: provider.displayName || null,
      email: provider.email || null,
      phoneNumber: provider.phoneNumber || null,
      photoURL: provider.photoUrl || null
    };
  });
}
async function requestStsToken(auth, refreshToken) {
  const response = await _performFetchWithErrorHandling(auth, {}, () => {
    const body = querystring({
      "grant_type": "refresh_token",
      "refresh_token": refreshToken
    }).slice(1);
    const { tokenApiHost, apiKey } = auth.config;
    const url2 = _getFinalTarget(auth, tokenApiHost, "/v1/token", `key=${apiKey}`);
    return FetchProvider.fetch()(url2, {
      method: "POST",
      headers: {
        "X-Client-Version": auth._getSdkClientVersion(),
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body
    });
  });
  return {
    accessToken: response.access_token,
    expiresIn: response.expires_in,
    refreshToken: response.refresh_token
  };
}
function assertStringOrUndefined(assertion, appName) {
  _assert(typeof assertion === "string" || typeof assertion === "undefined", "internal-error", { appName });
}
function _persistenceKeyName(key, apiKey, appName) {
  return `${"firebase"}:${key}:${apiKey}:${appName}`;
}
function _getBrowserName(userAgent) {
  const ua2 = userAgent.toLowerCase();
  if (ua2.includes("opera/") || ua2.includes("opr/") || ua2.includes("opios/")) {
    return "Opera";
  } else if (_isIEMobile(ua2)) {
    return "IEMobile";
  } else if (ua2.includes("msie") || ua2.includes("trident/")) {
    return "IE";
  } else if (ua2.includes("edge/")) {
    return "Edge";
  } else if (_isFirefox(ua2)) {
    return "Firefox";
  } else if (ua2.includes("silk/")) {
    return "Silk";
  } else if (_isBlackBerry(ua2)) {
    return "Blackberry";
  } else if (_isWebOS(ua2)) {
    return "Webos";
  } else if (_isSafari(ua2)) {
    return "Safari";
  } else if ((ua2.includes("chrome/") || _isChromeIOS(ua2)) && !ua2.includes("edge/")) {
    return "Chrome";
  } else if (_isAndroid(ua2)) {
    return "Android";
  } else {
    const re2 = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/;
    const matches2 = userAgent.match(re2);
    if ((matches2 === null || matches2 === void 0 ? void 0 : matches2.length) === 2) {
      return matches2[1];
    }
  }
  return "Other";
}
function _isFirefox(ua2 = getUA()) {
  return /firefox\//i.test(ua2);
}
function _isSafari(userAgent = getUA()) {
  const ua2 = userAgent.toLowerCase();
  return ua2.includes("safari/") && !ua2.includes("chrome/") && !ua2.includes("crios/") && !ua2.includes("android");
}
function _isChromeIOS(ua2 = getUA()) {
  return /crios\//i.test(ua2);
}
function _isIEMobile(ua2 = getUA()) {
  return /iemobile/i.test(ua2);
}
function _isAndroid(ua2 = getUA()) {
  return /android/i.test(ua2);
}
function _isBlackBerry(ua2 = getUA()) {
  return /blackberry/i.test(ua2);
}
function _isWebOS(ua2 = getUA()) {
  return /webos/i.test(ua2);
}
function _getClientVersion(clientPlatform, frameworks = []) {
  let reportedPlatform;
  switch (clientPlatform) {
    case "Browser":
      reportedPlatform = _getBrowserName(getUA());
      break;
    case "Worker":
      reportedPlatform = `${_getBrowserName(getUA())}-${clientPlatform}`;
      break;
    default:
      reportedPlatform = clientPlatform;
  }
  const reportedFrameworks = frameworks.length ? frameworks.join(",") : "FirebaseCore-web";
  return `${reportedPlatform}/${"JsCore"}/${SDK_VERSION}/${reportedFrameworks}`;
}
function _castAuth(auth) {
  return getModularInstance(auth);
}
function getVersionForPlatform(clientPlatform) {
  switch (clientPlatform) {
    case "Node":
      return "node";
    case "ReactNative":
      return "rn";
    case "Worker":
      return "webworker";
    case "Cordova":
      return "cordova";
    default:
      return void 0;
  }
}
function registerAuth(clientPlatform) {
  _registerComponent(new Component("auth", (container, { options: deps }) => {
    const app = container.getProvider("app").getImmediate();
    const { apiKey, authDomain } = app.options;
    return ((app2) => {
      _assert(apiKey && !apiKey.includes(":"), "invalid-api-key", { appName: app2.name });
      _assert(!(authDomain === null || authDomain === void 0 ? void 0 : authDomain.includes(":")), "argument-error", {
        appName: app2.name
      });
      const config = {
        apiKey,
        authDomain,
        clientPlatform,
        apiHost: "identitytoolkit.googleapis.com",
        tokenApiHost: "securetoken.googleapis.com",
        apiScheme: "https",
        sdkClientVersion: _getClientVersion(clientPlatform)
      };
      const authInstance = new AuthImpl(app2, config);
      _initializeAuthInstance(authInstance, deps);
      return authInstance;
    })(app);
  }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((container, _instanceIdentifier, _instance) => {
    const authInternalProvider = container.getProvider("auth-internal");
    authInternalProvider.initialize();
  }));
  _registerComponent(new Component("auth-internal", (container) => {
    const auth = _castAuth(container.getProvider("auth").getImmediate());
    return ((auth2) => new AuthInterop(auth2))(auth);
  }, "PRIVATE").setInstantiationMode("EXPLICIT"));
  registerVersion(name2, version2, getVersionForPlatform(clientPlatform));
  registerVersion(name2, version2, "esm2017");
}
function getAuth(app = getApp()) {
  const provider = _getProvider(app, "auth");
  if (provider.isInitialized()) {
    return provider.getImmediate();
  }
  return initializeAuth(app);
}
async function fail() {
  throw NOT_AVAILABLE_ERROR;
}
var fetchImpl, prodErrorMap, _DEFAULT_AUTH_ERROR_FACTORY, logClient, instanceCache, Delay, FetchProvider, SERVER_ERROR_MAP, DEFAULT_API_TIMEOUT_MS, NetworkTimeout, ProactiveRefresh, UserMetadata, StsTokenManager, UserImpl, InMemoryPersistence, inMemoryPersistence, PersistenceUserManager, AuthImpl, Subscription, name2, version2, AuthInterop, NOT_AVAILABLE_ERROR, FailClass, signInWithPhoneNumber, RecaptchaVerifier;
var init_index_c327074d_b42dfde1 = __esm({
  ".svelte-kit/output/server/chunks/index-c327074d-b42dfde1.js"() {
    init_shims();
    init_store_85fd0788();
    fetchImpl = __toModule(require_lib2());
    prodErrorMap = _prodErrorMap;
    _DEFAULT_AUTH_ERROR_FACTORY = new ErrorFactory("auth", "Firebase", _prodErrorMap());
    logClient = new Logger("@firebase/auth");
    instanceCache = new Map();
    Delay = class {
      constructor(shortDelay, longDelay) {
        this.shortDelay = shortDelay;
        this.longDelay = longDelay;
        debugAssert(longDelay > shortDelay, "Short delay should be less than long delay!");
        this.isMobile = isMobileCordova() || isReactNative();
      }
      get() {
        if (!_isOnline()) {
          return Math.min(5e3, this.shortDelay);
        }
        return this.isMobile ? this.longDelay : this.shortDelay;
      }
    };
    FetchProvider = class {
      static initialize(fetchImpl2, headersImpl, responseImpl) {
        this.fetchImpl = fetchImpl2;
        if (headersImpl) {
          this.headersImpl = headersImpl;
        }
        if (responseImpl) {
          this.responseImpl = responseImpl;
        }
      }
      static fetch() {
        if (this.fetchImpl) {
          return this.fetchImpl;
        }
        if (typeof self !== "undefined" && "fetch" in self) {
          return self.fetch;
        }
        debugFail("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
      }
      static headers() {
        if (this.headersImpl) {
          return this.headersImpl;
        }
        if (typeof self !== "undefined" && "Headers" in self) {
          return self.Headers;
        }
        debugFail("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
      }
      static response() {
        if (this.responseImpl) {
          return this.responseImpl;
        }
        if (typeof self !== "undefined" && "Response" in self) {
          return self.Response;
        }
        debugFail("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
      }
    };
    SERVER_ERROR_MAP = {
      ["CREDENTIAL_MISMATCH"]: "custom-token-mismatch",
      ["MISSING_CUSTOM_TOKEN"]: "internal-error",
      ["INVALID_IDENTIFIER"]: "invalid-email",
      ["MISSING_CONTINUE_URI"]: "internal-error",
      ["INVALID_PASSWORD"]: "wrong-password",
      ["MISSING_PASSWORD"]: "internal-error",
      ["EMAIL_EXISTS"]: "email-already-in-use",
      ["PASSWORD_LOGIN_DISABLED"]: "operation-not-allowed",
      ["INVALID_IDP_RESPONSE"]: "invalid-credential",
      ["INVALID_PENDING_TOKEN"]: "invalid-credential",
      ["FEDERATED_USER_ID_ALREADY_LINKED"]: "credential-already-in-use",
      ["MISSING_REQ_TYPE"]: "internal-error",
      ["EMAIL_NOT_FOUND"]: "user-not-found",
      ["RESET_PASSWORD_EXCEED_LIMIT"]: "too-many-requests",
      ["EXPIRED_OOB_CODE"]: "expired-action-code",
      ["INVALID_OOB_CODE"]: "invalid-action-code",
      ["MISSING_OOB_CODE"]: "internal-error",
      ["CREDENTIAL_TOO_OLD_LOGIN_AGAIN"]: "requires-recent-login",
      ["INVALID_ID_TOKEN"]: "invalid-user-token",
      ["TOKEN_EXPIRED"]: "user-token-expired",
      ["USER_NOT_FOUND"]: "user-token-expired",
      ["TOO_MANY_ATTEMPTS_TRY_LATER"]: "too-many-requests",
      ["INVALID_CODE"]: "invalid-verification-code",
      ["INVALID_SESSION_INFO"]: "invalid-verification-id",
      ["INVALID_TEMPORARY_PROOF"]: "invalid-credential",
      ["MISSING_SESSION_INFO"]: "missing-verification-id",
      ["SESSION_EXPIRED"]: "code-expired",
      ["MISSING_ANDROID_PACKAGE_NAME"]: "missing-android-pkg-name",
      ["UNAUTHORIZED_DOMAIN"]: "unauthorized-continue-uri",
      ["INVALID_OAUTH_CLIENT_ID"]: "invalid-oauth-client-id",
      ["ADMIN_ONLY_OPERATION"]: "admin-restricted-operation",
      ["INVALID_MFA_PENDING_CREDENTIAL"]: "invalid-multi-factor-session",
      ["MFA_ENROLLMENT_NOT_FOUND"]: "multi-factor-info-not-found",
      ["MISSING_MFA_ENROLLMENT_ID"]: "missing-multi-factor-info",
      ["MISSING_MFA_PENDING_CREDENTIAL"]: "missing-multi-factor-session",
      ["SECOND_FACTOR_EXISTS"]: "second-factor-already-in-use",
      ["SECOND_FACTOR_LIMIT_EXCEEDED"]: "maximum-second-factor-count-exceeded",
      ["BLOCKING_FUNCTION_ERROR_RESPONSE"]: "internal-error"
    };
    DEFAULT_API_TIMEOUT_MS = new Delay(3e4, 6e4);
    NetworkTimeout = class {
      constructor(auth) {
        this.auth = auth;
        this.timer = null;
        this.promise = new Promise((_, reject2) => {
          this.timer = setTimeout(() => {
            return reject2(_createError(this.auth, "timeout"));
          }, DEFAULT_API_TIMEOUT_MS.get());
        });
      }
      clearNetworkTimeout() {
        clearTimeout(this.timer);
      }
    };
    ProactiveRefresh = class {
      constructor(user2) {
        this.user = user2;
        this.isRunning = false;
        this.timerId = null;
        this.errorBackoff = 3e4;
      }
      _start() {
        if (this.isRunning) {
          return;
        }
        this.isRunning = true;
        this.schedule();
      }
      _stop() {
        if (!this.isRunning) {
          return;
        }
        this.isRunning = false;
        if (this.timerId !== null) {
          clearTimeout(this.timerId);
        }
      }
      getInterval(wasError) {
        var _a2;
        if (wasError) {
          const interval = this.errorBackoff;
          this.errorBackoff = Math.min(this.errorBackoff * 2, 96e4);
          return interval;
        } else {
          this.errorBackoff = 3e4;
          const expTime = (_a2 = this.user.stsTokenManager.expirationTime) !== null && _a2 !== void 0 ? _a2 : 0;
          const interval = expTime - Date.now() - 3e5;
          return Math.max(0, interval);
        }
      }
      schedule(wasError = false) {
        if (!this.isRunning) {
          return;
        }
        const interval = this.getInterval(wasError);
        this.timerId = setTimeout(async () => {
          await this.iteration();
        }, interval);
      }
      async iteration() {
        try {
          await this.user.getIdToken(true);
        } catch (e) {
          if (e.code === `auth/${"network-request-failed"}`) {
            this.schedule(true);
          }
          return;
        }
        this.schedule();
      }
    };
    UserMetadata = class {
      constructor(createdAt, lastLoginAt) {
        this.createdAt = createdAt;
        this.lastLoginAt = lastLoginAt;
        this._initializeTime();
      }
      _initializeTime() {
        this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);
        this.creationTime = utcTimestampToDateString(this.createdAt);
      }
      _copy(metadata) {
        this.createdAt = metadata.createdAt;
        this.lastLoginAt = metadata.lastLoginAt;
        this._initializeTime();
      }
      toJSON() {
        return {
          createdAt: this.createdAt,
          lastLoginAt: this.lastLoginAt
        };
      }
    };
    StsTokenManager = class {
      constructor() {
        this.refreshToken = null;
        this.accessToken = null;
        this.expirationTime = null;
      }
      get isExpired() {
        return !this.expirationTime || Date.now() > this.expirationTime - 3e4;
      }
      updateFromServerResponse(response) {
        _assert(response.idToken, "internal-error");
        _assert(typeof response.idToken !== "undefined", "internal-error");
        _assert(typeof response.refreshToken !== "undefined", "internal-error");
        const expiresIn = "expiresIn" in response && typeof response.expiresIn !== "undefined" ? Number(response.expiresIn) : _tokenExpiresIn(response.idToken);
        this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);
      }
      async getToken(auth, forceRefresh = false) {
        _assert(!this.accessToken || this.refreshToken, auth, "user-token-expired");
        if (!forceRefresh && this.accessToken && !this.isExpired) {
          return this.accessToken;
        }
        if (this.refreshToken) {
          await this.refresh(auth, this.refreshToken);
          return this.accessToken;
        }
        return null;
      }
      clearRefreshToken() {
        this.refreshToken = null;
      }
      async refresh(auth, oldToken) {
        const { accessToken, refreshToken, expiresIn } = await requestStsToken(auth, oldToken);
        this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));
      }
      updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {
        this.refreshToken = refreshToken || null;
        this.accessToken = accessToken || null;
        this.expirationTime = Date.now() + expiresInSec * 1e3;
      }
      static fromJSON(appName, object) {
        const { refreshToken, accessToken, expirationTime } = object;
        const manager = new StsTokenManager();
        if (refreshToken) {
          _assert(typeof refreshToken === "string", "internal-error", {
            appName
          });
          manager.refreshToken = refreshToken;
        }
        if (accessToken) {
          _assert(typeof accessToken === "string", "internal-error", {
            appName
          });
          manager.accessToken = accessToken;
        }
        if (expirationTime) {
          _assert(typeof expirationTime === "number", "internal-error", {
            appName
          });
          manager.expirationTime = expirationTime;
        }
        return manager;
      }
      toJSON() {
        return {
          refreshToken: this.refreshToken,
          accessToken: this.accessToken,
          expirationTime: this.expirationTime
        };
      }
      _assign(stsTokenManager) {
        this.accessToken = stsTokenManager.accessToken;
        this.refreshToken = stsTokenManager.refreshToken;
        this.expirationTime = stsTokenManager.expirationTime;
      }
      _clone() {
        return Object.assign(new StsTokenManager(), this.toJSON());
      }
      _performRefresh() {
        return debugFail("not implemented");
      }
    };
    UserImpl = class {
      constructor(_a2) {
        var { uid, auth, stsTokenManager } = _a2, opt = __rest(_a2, ["uid", "auth", "stsTokenManager"]);
        this.providerId = "firebase";
        this.emailVerified = false;
        this.isAnonymous = false;
        this.tenantId = null;
        this.providerData = [];
        this.proactiveRefresh = new ProactiveRefresh(this);
        this.reloadUserInfo = null;
        this.reloadListener = null;
        this.uid = uid;
        this.auth = auth;
        this.stsTokenManager = stsTokenManager;
        this.accessToken = stsTokenManager.accessToken;
        this.displayName = opt.displayName || null;
        this.email = opt.email || null;
        this.emailVerified = opt.emailVerified || false;
        this.phoneNumber = opt.phoneNumber || null;
        this.photoURL = opt.photoURL || null;
        this.isAnonymous = opt.isAnonymous || false;
        this.tenantId = opt.tenantId || null;
        this.metadata = new UserMetadata(opt.createdAt || void 0, opt.lastLoginAt || void 0);
      }
      async getIdToken(forceRefresh) {
        const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));
        _assert(accessToken, this.auth, "internal-error");
        if (this.accessToken !== accessToken) {
          this.accessToken = accessToken;
          await this.auth._persistUserIfCurrent(this);
          this.auth._notifyListenersIfCurrent(this);
        }
        return accessToken;
      }
      getIdTokenResult(forceRefresh) {
        return getIdTokenResult(this, forceRefresh);
      }
      reload() {
        return reload(this);
      }
      _assign(user2) {
        if (this === user2) {
          return;
        }
        _assert(this.uid === user2.uid, this.auth, "internal-error");
        this.displayName = user2.displayName;
        this.photoURL = user2.photoURL;
        this.email = user2.email;
        this.emailVerified = user2.emailVerified;
        this.phoneNumber = user2.phoneNumber;
        this.isAnonymous = user2.isAnonymous;
        this.tenantId = user2.tenantId;
        this.providerData = user2.providerData.map((userInfo) => Object.assign({}, userInfo));
        this.metadata._copy(user2.metadata);
        this.stsTokenManager._assign(user2.stsTokenManager);
      }
      _clone(auth) {
        return new UserImpl(Object.assign(Object.assign({}, this), { auth, stsTokenManager: this.stsTokenManager._clone() }));
      }
      _onReload(callback) {
        _assert(!this.reloadListener, this.auth, "internal-error");
        this.reloadListener = callback;
        if (this.reloadUserInfo) {
          this._notifyReloadListener(this.reloadUserInfo);
          this.reloadUserInfo = null;
        }
      }
      _notifyReloadListener(userInfo) {
        if (this.reloadListener) {
          this.reloadListener(userInfo);
        } else {
          this.reloadUserInfo = userInfo;
        }
      }
      _startProactiveRefresh() {
        this.proactiveRefresh._start();
      }
      _stopProactiveRefresh() {
        this.proactiveRefresh._stop();
      }
      async _updateTokensIfNecessary(response, reload2 = false) {
        let tokensRefreshed = false;
        if (response.idToken && response.idToken !== this.stsTokenManager.accessToken) {
          this.stsTokenManager.updateFromServerResponse(response);
          tokensRefreshed = true;
        }
        if (reload2) {
          await _reloadWithoutSaving(this);
        }
        await this.auth._persistUserIfCurrent(this);
        if (tokensRefreshed) {
          this.auth._notifyListenersIfCurrent(this);
        }
      }
      async delete() {
        const idToken = await this.getIdToken();
        await _logoutIfInvalidated(this, deleteAccount(this.auth, { idToken }));
        this.stsTokenManager.clearRefreshToken();
        return this.auth.signOut();
      }
      toJSON() {
        return Object.assign(Object.assign({
          uid: this.uid,
          email: this.email || void 0,
          emailVerified: this.emailVerified,
          displayName: this.displayName || void 0,
          isAnonymous: this.isAnonymous,
          photoURL: this.photoURL || void 0,
          phoneNumber: this.phoneNumber || void 0,
          tenantId: this.tenantId || void 0,
          providerData: this.providerData.map((userInfo) => Object.assign({}, userInfo)),
          stsTokenManager: this.stsTokenManager.toJSON(),
          _redirectEventId: this._redirectEventId
        }, this.metadata.toJSON()), {
          apiKey: this.auth.config.apiKey,
          appName: this.auth.name
        });
      }
      get refreshToken() {
        return this.stsTokenManager.refreshToken || "";
      }
      static _fromJSON(auth, object) {
        var _a2, _b, _c2, _d, _e2, _f, _g, _h2;
        const displayName = (_a2 = object.displayName) !== null && _a2 !== void 0 ? _a2 : void 0;
        const email = (_b = object.email) !== null && _b !== void 0 ? _b : void 0;
        const phoneNumber = (_c2 = object.phoneNumber) !== null && _c2 !== void 0 ? _c2 : void 0;
        const photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : void 0;
        const tenantId = (_e2 = object.tenantId) !== null && _e2 !== void 0 ? _e2 : void 0;
        const _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : void 0;
        const createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : void 0;
        const lastLoginAt = (_h2 = object.lastLoginAt) !== null && _h2 !== void 0 ? _h2 : void 0;
        const { uid, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager } = object;
        _assert(uid && plainObjectTokenManager, auth, "internal-error");
        const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);
        _assert(typeof uid === "string", auth, "internal-error");
        assertStringOrUndefined(displayName, auth.name);
        assertStringOrUndefined(email, auth.name);
        _assert(typeof emailVerified === "boolean", auth, "internal-error");
        _assert(typeof isAnonymous === "boolean", auth, "internal-error");
        assertStringOrUndefined(phoneNumber, auth.name);
        assertStringOrUndefined(photoURL, auth.name);
        assertStringOrUndefined(tenantId, auth.name);
        assertStringOrUndefined(_redirectEventId, auth.name);
        assertStringOrUndefined(createdAt, auth.name);
        assertStringOrUndefined(lastLoginAt, auth.name);
        const user2 = new UserImpl({
          uid,
          auth,
          email,
          emailVerified,
          displayName,
          isAnonymous,
          photoURL,
          phoneNumber,
          tenantId,
          stsTokenManager,
          createdAt,
          lastLoginAt
        });
        if (providerData && Array.isArray(providerData)) {
          user2.providerData = providerData.map((userInfo) => Object.assign({}, userInfo));
        }
        if (_redirectEventId) {
          user2._redirectEventId = _redirectEventId;
        }
        return user2;
      }
      static async _fromIdTokenResponse(auth, idTokenResponse, isAnonymous = false) {
        const stsTokenManager = new StsTokenManager();
        stsTokenManager.updateFromServerResponse(idTokenResponse);
        const user2 = new UserImpl({
          uid: idTokenResponse.localId,
          auth,
          stsTokenManager,
          isAnonymous
        });
        await _reloadWithoutSaving(user2);
        return user2;
      }
    };
    InMemoryPersistence = class {
      constructor() {
        this.type = "NONE";
        this.storage = {};
      }
      async _isAvailable() {
        return true;
      }
      async _set(key, value) {
        this.storage[key] = value;
      }
      async _get(key) {
        const value = this.storage[key];
        return value === void 0 ? null : value;
      }
      async _remove(key) {
        delete this.storage[key];
      }
      _addListener(_key, _listener) {
        return;
      }
      _removeListener(_key, _listener) {
        return;
      }
    };
    InMemoryPersistence.type = "NONE";
    inMemoryPersistence = InMemoryPersistence;
    PersistenceUserManager = class {
      constructor(persistence, auth, userKey) {
        this.persistence = persistence;
        this.auth = auth;
        this.userKey = userKey;
        const { config, name: name22 } = this.auth;
        this.fullUserKey = _persistenceKeyName(this.userKey, config.apiKey, name22);
        this.fullPersistenceKey = _persistenceKeyName("persistence", config.apiKey, name22);
        this.boundEventHandler = auth._onStorageEvent.bind(auth);
        this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
      }
      setCurrentUser(user2) {
        return this.persistence._set(this.fullUserKey, user2.toJSON());
      }
      async getCurrentUser() {
        const blob = await this.persistence._get(this.fullUserKey);
        return blob ? UserImpl._fromJSON(this.auth, blob) : null;
      }
      removeCurrentUser() {
        return this.persistence._remove(this.fullUserKey);
      }
      savePersistenceForRedirect() {
        return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
      }
      async setPersistence(newPersistence) {
        if (this.persistence === newPersistence) {
          return;
        }
        const currentUser = await this.getCurrentUser();
        await this.removeCurrentUser();
        this.persistence = newPersistence;
        if (currentUser) {
          return this.setCurrentUser(currentUser);
        }
      }
      delete() {
        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
      }
      static async create(auth, persistenceHierarchy, userKey = "authUser") {
        if (!persistenceHierarchy.length) {
          return new PersistenceUserManager(_getInstance(inMemoryPersistence), auth, userKey);
        }
        const availablePersistences = (await Promise.all(persistenceHierarchy.map(async (persistence) => {
          if (await persistence._isAvailable()) {
            return persistence;
          }
          return void 0;
        }))).filter((persistence) => persistence);
        let selectedPersistence = availablePersistences[0] || _getInstance(inMemoryPersistence);
        const key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name);
        let userToMigrate = null;
        for (const persistence of persistenceHierarchy) {
          try {
            const blob = await persistence._get(key);
            if (blob) {
              const user2 = UserImpl._fromJSON(auth, blob);
              if (persistence !== selectedPersistence) {
                userToMigrate = user2;
              }
              selectedPersistence = persistence;
              break;
            }
          } catch (_a2) {
          }
        }
        const migrationHierarchy = availablePersistences.filter((p2) => p2._shouldAllowMigration);
        if (!selectedPersistence._shouldAllowMigration || !migrationHierarchy.length) {
          return new PersistenceUserManager(selectedPersistence, auth, userKey);
        }
        selectedPersistence = migrationHierarchy[0];
        if (userToMigrate) {
          await selectedPersistence._set(key, userToMigrate.toJSON());
        }
        await Promise.all(persistenceHierarchy.map(async (persistence) => {
          if (persistence !== selectedPersistence) {
            try {
              await persistence._remove(key);
            } catch (_a2) {
            }
          }
        }));
        return new PersistenceUserManager(selectedPersistence, auth, userKey);
      }
    };
    AuthImpl = class {
      constructor(app, config) {
        this.app = app;
        this.config = config;
        this.currentUser = null;
        this.emulatorConfig = null;
        this.operations = Promise.resolve();
        this.authStateSubscription = new Subscription(this);
        this.idTokenSubscription = new Subscription(this);
        this.redirectUser = null;
        this.isProactiveRefreshEnabled = false;
        this._canInitEmulator = true;
        this._isInitialized = false;
        this._deleted = false;
        this._initializationPromise = null;
        this._popupRedirectResolver = null;
        this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;
        this.lastNotifiedUid = void 0;
        this.languageCode = null;
        this.tenantId = null;
        this.settings = { appVerificationDisabledForTesting: false };
        this.frameworks = [];
        this.name = app.name;
        this.clientVersion = config.sdkClientVersion;
      }
      _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {
        if (popupRedirectResolver) {
          this._popupRedirectResolver = _getInstance(popupRedirectResolver);
        }
        this._initializationPromise = this.queue(async () => {
          var _a2, _b;
          if (this._deleted) {
            return;
          }
          this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);
          if (this._deleted) {
            return;
          }
          if ((_a2 = this._popupRedirectResolver) === null || _a2 === void 0 ? void 0 : _a2._shouldInitProactively) {
            await this._popupRedirectResolver._initialize(this);
          }
          await this.initializeCurrentUser(popupRedirectResolver);
          this.lastNotifiedUid = ((_b = this.currentUser) === null || _b === void 0 ? void 0 : _b.uid) || null;
          if (this._deleted) {
            return;
          }
          this._isInitialized = true;
        });
        return this._initializationPromise;
      }
      async _onStorageEvent() {
        if (this._deleted) {
          return;
        }
        const user2 = await this.assertedPersistence.getCurrentUser();
        if (!this.currentUser && !user2) {
          return;
        }
        if (this.currentUser && user2 && this.currentUser.uid === user2.uid) {
          this._currentUser._assign(user2);
          await this.currentUser.getIdToken();
          return;
        }
        await this._updateCurrentUser(user2);
      }
      async initializeCurrentUser(popupRedirectResolver) {
        var _a2;
        let storedUser = await this.assertedPersistence.getCurrentUser();
        if (popupRedirectResolver && this.config.authDomain) {
          await this.getOrInitRedirectPersistenceManager();
          const redirectUserEventId = (_a2 = this.redirectUser) === null || _a2 === void 0 ? void 0 : _a2._redirectEventId;
          const storedUserEventId = storedUser === null || storedUser === void 0 ? void 0 : storedUser._redirectEventId;
          const result = await this.tryRedirectSignIn(popupRedirectResolver);
          if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) && (result === null || result === void 0 ? void 0 : result.user)) {
            storedUser = result.user;
          }
        }
        if (!storedUser) {
          return this.directlySetCurrentUser(null);
        }
        if (!storedUser._redirectEventId) {
          return this.reloadAndSetCurrentUserOrClear(storedUser);
        }
        _assert(this._popupRedirectResolver, this, "argument-error");
        await this.getOrInitRedirectPersistenceManager();
        if (this.redirectUser && this.redirectUser._redirectEventId === storedUser._redirectEventId) {
          return this.directlySetCurrentUser(storedUser);
        }
        return this.reloadAndSetCurrentUserOrClear(storedUser);
      }
      async tryRedirectSignIn(redirectResolver) {
        let result = null;
        try {
          result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);
        } catch (e) {
          await this._setRedirectUser(null);
        }
        return result;
      }
      async reloadAndSetCurrentUserOrClear(user2) {
        try {
          await _reloadWithoutSaving(user2);
        } catch (e) {
          if (e.code !== `auth/${"network-request-failed"}`) {
            return this.directlySetCurrentUser(null);
          }
        }
        return this.directlySetCurrentUser(user2);
      }
      useDeviceLanguage() {
        this.languageCode = _getUserLanguage();
      }
      async _delete() {
        this._deleted = true;
      }
      async updateCurrentUser(userExtern) {
        const user2 = userExtern ? getModularInstance(userExtern) : null;
        if (user2) {
          _assert(user2.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token");
        }
        return this._updateCurrentUser(user2 && user2._clone(this));
      }
      async _updateCurrentUser(user2) {
        if (this._deleted) {
          return;
        }
        if (user2) {
          _assert(this.tenantId === user2.tenantId, this, "tenant-id-mismatch");
        }
        return this.queue(async () => {
          await this.directlySetCurrentUser(user2);
          this.notifyAuthListeners();
        });
      }
      async signOut() {
        if (this.redirectPersistenceManager || this._popupRedirectResolver) {
          await this._setRedirectUser(null);
        }
        return this._updateCurrentUser(null);
      }
      setPersistence(persistence) {
        return this.queue(async () => {
          await this.assertedPersistence.setPersistence(_getInstance(persistence));
        });
      }
      _getPersistence() {
        return this.assertedPersistence.persistence.type;
      }
      _updateErrorMap(errorMap) {
        this._errorFactory = new ErrorFactory("auth", "Firebase", errorMap());
      }
      onAuthStateChanged(nextOrObserver, error3, completed) {
        return this.registerStateListener(this.authStateSubscription, nextOrObserver, error3, completed);
      }
      onIdTokenChanged(nextOrObserver, error3, completed) {
        return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error3, completed);
      }
      toJSON() {
        var _a2;
        return {
          apiKey: this.config.apiKey,
          authDomain: this.config.authDomain,
          appName: this.name,
          currentUser: (_a2 = this._currentUser) === null || _a2 === void 0 ? void 0 : _a2.toJSON()
        };
      }
      async _setRedirectUser(user2, popupRedirectResolver) {
        const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);
        return user2 === null ? redirectManager.removeCurrentUser() : redirectManager.setCurrentUser(user2);
      }
      async getOrInitRedirectPersistenceManager(popupRedirectResolver) {
        if (!this.redirectPersistenceManager) {
          const resolver = popupRedirectResolver && _getInstance(popupRedirectResolver) || this._popupRedirectResolver;
          _assert(resolver, this, "argument-error");
          this.redirectPersistenceManager = await PersistenceUserManager.create(this, [_getInstance(resolver._redirectPersistence)], "redirectUser");
          this.redirectUser = await this.redirectPersistenceManager.getCurrentUser();
        }
        return this.redirectPersistenceManager;
      }
      async _redirectUserForId(id2) {
        var _a2, _b;
        if (this._isInitialized) {
          await this.queue(async () => {
          });
        }
        if (((_a2 = this._currentUser) === null || _a2 === void 0 ? void 0 : _a2._redirectEventId) === id2) {
          return this._currentUser;
        }
        if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id2) {
          return this.redirectUser;
        }
        return null;
      }
      async _persistUserIfCurrent(user2) {
        if (user2 === this.currentUser) {
          return this.queue(async () => this.directlySetCurrentUser(user2));
        }
      }
      _notifyListenersIfCurrent(user2) {
        if (user2 === this.currentUser) {
          this.notifyAuthListeners();
        }
      }
      _key() {
        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
      }
      _startProactiveRefresh() {
        this.isProactiveRefreshEnabled = true;
        if (this.currentUser) {
          this._currentUser._startProactiveRefresh();
        }
      }
      _stopProactiveRefresh() {
        this.isProactiveRefreshEnabled = false;
        if (this.currentUser) {
          this._currentUser._stopProactiveRefresh();
        }
      }
      get _currentUser() {
        return this.currentUser;
      }
      notifyAuthListeners() {
        var _a2, _b;
        if (!this._isInitialized) {
          return;
        }
        this.idTokenSubscription.next(this.currentUser);
        const currentUid = (_b = (_a2 = this.currentUser) === null || _a2 === void 0 ? void 0 : _a2.uid) !== null && _b !== void 0 ? _b : null;
        if (this.lastNotifiedUid !== currentUid) {
          this.lastNotifiedUid = currentUid;
          this.authStateSubscription.next(this.currentUser);
        }
      }
      registerStateListener(subscription, nextOrObserver, error3, completed) {
        if (this._deleted) {
          return () => {
          };
        }
        const cb2 = typeof nextOrObserver === "function" ? nextOrObserver : nextOrObserver.next.bind(nextOrObserver);
        const promise = this._isInitialized ? Promise.resolve() : this._initializationPromise;
        _assert(promise, this, "internal-error");
        promise.then(() => cb2(this.currentUser));
        if (typeof nextOrObserver === "function") {
          return subscription.addObserver(nextOrObserver, error3, completed);
        } else {
          return subscription.addObserver(nextOrObserver);
        }
      }
      async directlySetCurrentUser(user2) {
        if (this.currentUser && this.currentUser !== user2) {
          this._currentUser._stopProactiveRefresh();
          if (user2 && this.isProactiveRefreshEnabled) {
            user2._startProactiveRefresh();
          }
        }
        this.currentUser = user2;
        if (user2) {
          await this.assertedPersistence.setCurrentUser(user2);
        } else {
          await this.assertedPersistence.removeCurrentUser();
        }
      }
      queue(action) {
        this.operations = this.operations.then(action, action);
        return this.operations;
      }
      get assertedPersistence() {
        _assert(this.persistenceManager, this, "internal-error");
        return this.persistenceManager;
      }
      _logFramework(framework) {
        if (!framework || this.frameworks.includes(framework)) {
          return;
        }
        this.frameworks.push(framework);
        this.frameworks.sort();
        this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());
      }
      _getFrameworks() {
        return this.frameworks;
      }
      _getSdkClientVersion() {
        return this.clientVersion;
      }
    };
    Subscription = class {
      constructor(auth) {
        this.auth = auth;
        this.observer = null;
        this.addObserver = createSubscribe((observer) => this.observer = observer);
      }
      get next() {
        _assert(this.observer, this.auth, "internal-error");
        return this.observer.next.bind(this.observer);
      }
    };
    name2 = "@firebase/auth";
    version2 = "0.19.3";
    AuthInterop = class {
      constructor(auth) {
        this.auth = auth;
        this.internalListeners = new Map();
      }
      getUid() {
        var _a2;
        this.assertAuthConfigured();
        return ((_a2 = this.auth.currentUser) === null || _a2 === void 0 ? void 0 : _a2.uid) || null;
      }
      async getToken(forceRefresh) {
        this.assertAuthConfigured();
        await this.auth._initializationPromise;
        if (!this.auth.currentUser) {
          return null;
        }
        const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);
        return { accessToken };
      }
      addAuthTokenListener(listener) {
        this.assertAuthConfigured();
        if (this.internalListeners.has(listener)) {
          return;
        }
        const unsubscribe = this.auth.onIdTokenChanged((user2) => {
          var _a2;
          listener(((_a2 = user2) === null || _a2 === void 0 ? void 0 : _a2.stsTokenManager.accessToken) || null);
        });
        this.internalListeners.set(listener, unsubscribe);
        this.updateProactiveRefresh();
      }
      removeAuthTokenListener(listener) {
        this.assertAuthConfigured();
        const unsubscribe = this.internalListeners.get(listener);
        if (!unsubscribe) {
          return;
        }
        this.internalListeners.delete(listener);
        unsubscribe();
        this.updateProactiveRefresh();
      }
      assertAuthConfigured() {
        _assert(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth");
      }
      updateProactiveRefresh() {
        if (this.internalListeners.size > 0) {
          this.auth._startProactiveRefresh();
        } else {
          this.auth._stopProactiveRefresh();
        }
      }
    };
    FetchProvider.initialize(fetchImpl.default, fetchImpl.Headers, fetchImpl.Response);
    registerAuth("Node");
    NOT_AVAILABLE_ERROR = _createError("operation-not-supported-in-this-environment");
    FailClass = class {
      constructor() {
        throw NOT_AVAILABLE_ERROR;
      }
    };
    signInWithPhoneNumber = fail;
    RecaptchaVerifier = FailClass;
    AuthImpl.prototype.setPersistence = async () => {
    };
  }
});

// .svelte-kit/output/server/chunks/__layout-a4c93375.js
var layout_a4c93375_exports = {};
__export(layout_a4c93375_exports, {
  default: () => _layout
});
var import_node_fetch, import_cookie, name3, version3, getStores, page, _layout;
var init_layout_a4c93375 = __esm({
  ".svelte-kit/output/server/chunks/__layout-a4c93375.js"() {
    init_shims();
    init_app_dafecf1b();
    init_store_85fd0788();
    init_index_c327074d_b42dfde1();
    import_node_fetch = __toModule(require_lib2());
    import_cookie = __toModule(require_cookie());
    init_dist();
    name3 = "firebase";
    version3 = "9.5.0";
    registerVersion(name3, version3, "app");
    getStores = () => {
      const stores = getContext("__svelte__");
      return {
        page: {
          subscribe: stores.page.subscribe
        },
        navigating: {
          subscribe: stores.navigating.subscribe
        },
        get preloading() {
          console.error("stores.preloading is deprecated; use stores.navigating instead");
          return {
            subscribe: stores.navigating.subscribe
          };
        },
        session: stores.session
      };
    };
    page = {
      subscribe(fn2) {
        const store2 = getStores().page;
        return store2.subscribe(fn2);
      }
    };
    _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$unsubscribe_user;
      let $$unsubscribe_page;
      let $hasFetchedUser, $$unsubscribe_hasFetchedUser;
      $$unsubscribe_user = subscribe(user, (value) => value);
      $$unsubscribe_page = subscribe(page, (value) => value);
      $$unsubscribe_hasFetchedUser = subscribe(hasFetchedUser, (value) => $hasFetchedUser = value);
      $$unsubscribe_user();
      $$unsubscribe_page();
      $$unsubscribe_hasFetchedUser();
      return `${!$hasFetchedUser ? `<h4 style="${"margin-left: 16px; font-family: Roboto, sans-serif; opacity: 70%; font-weight: 400"}">Fetching your info...
  </h4>` : `${slots.default ? slots.default({}) : `

  `}`}`;
    });
  }
});

// .svelte-kit/output/server/chunks/error-565ff2fd.js
var error_565ff2fd_exports = {};
__export(error_565ff2fd_exports, {
  default: () => Error2,
  load: () => load
});
function load({ error: error3, status }) {
  return { props: { error: error3, status } };
}
var import_cookie2, Error2;
var init_error_565ff2fd = __esm({
  ".svelte-kit/output/server/chunks/error-565ff2fd.js"() {
    init_shims();
    init_app_dafecf1b();
    import_cookie2 = __toModule(require_cookie());
    init_dist();
    Error2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { status } = $$props;
      let { error: error3 } = $$props;
      if ($$props.status === void 0 && $$bindings.status && status !== void 0)
        $$bindings.status(status);
      if ($$props.error === void 0 && $$bindings.error && error3 !== void 0)
        $$bindings.error(error3);
      return `<h1>${escape(status)}</h1>

<pre>${escape(error3.message)}</pre>



${error3.frame ? `<pre>${escape(error3.frame)}</pre>` : ``}
${error3.stack ? `<pre>${escape(error3.stack)}</pre>` : ``}`;
    });
  }
});

// .svelte-kit/output/server/chunks/SelectionGroupIcon-51f30423.js
function classMap(classObj) {
  return Object.entries(classObj).filter(([name6, value]) => name6 !== "" && value).map(([name6]) => name6).join(" ");
}
function dispatch(element, eventType, detail, eventInit = { bubbles: true }, duplicateEventForMDC = false) {
  if (typeof Event !== "undefined" && element) {
    const event2 = new CustomEvent(eventType, Object.assign(Object.assign({}, eventInit), { detail }));
    element === null || element === void 0 ? void 0 : element.dispatchEvent(event2);
    if (duplicateEventForMDC && eventType.startsWith("SMUI")) {
      const duplicateEvent = new CustomEvent(eventType.replace(/^SMUI/g, () => "MDC"), Object.assign(Object.assign({}, eventInit), { detail }));
      element === null || element === void 0 ? void 0 : element.dispatchEvent(duplicateEvent);
      if (duplicateEvent.defaultPrevented) {
        event2.preventDefault();
      }
    }
    return event2;
  }
}
function forwardEventsBuilder(component) {
  let $on;
  let events22 = [];
  component.$on = (fullEventType, callback) => {
    let eventType = fullEventType;
    let destructor = () => {
    };
    if ($on) {
      destructor = $on(eventType, callback);
    } else {
      events22.push([eventType, callback]);
    }
    const oldModifierMatch = eventType.match(oldModifierRegex);
    if (oldModifierMatch && console) {
      console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
    }
    return () => {
      destructor();
    };
  };
  function forward(e) {
    bubble(component, e);
  }
  return (node) => {
    const destructors = [];
    const forwardDestructors = {};
    $on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let handler = callback;
      let options2 = false;
      const oldModifierMatch = eventType.match(oldModifierRegex);
      const newModifierMatch = eventType.match(newModifierRegex);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (eventType.match(/^SMUI:\w+:/)) {
        const newEventTypeParts = eventType.split(":");
        let newEventType = "";
        for (let i = 0; i < newEventTypeParts.length; i++) {
          newEventType += i === newEventTypeParts.length - 1 ? ":" + newEventTypeParts[i] : newEventTypeParts[i].split("-").map((value) => value.slice(0, 1).toUpperCase() + value.slice(1)).join("");
        }
        console.warn(`The event ${eventType.split("$")[0]} has been renamed to ${newEventType.split("$")[0]}.`);
        eventType = newEventType;
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
        const eventOptions = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
        if (eventOptions.passive) {
          options2 = options2 || {};
          options2.passive = true;
        }
        if (eventOptions.nonpassive) {
          options2 = options2 || {};
          options2.passive = false;
        }
        if (eventOptions.capture) {
          options2 = options2 || {};
          options2.capture = true;
        }
        if (eventOptions.once) {
          options2 = options2 || {};
          options2.once = true;
        }
        if (eventOptions.preventDefault) {
          handler = prevent_default(handler);
        }
        if (eventOptions.stopPropagation) {
          handler = stop_propagation(handler);
        }
      }
      const off = listen(node, eventType, handler, options2);
      const destructor = () => {
        off();
        const idx = destructors.indexOf(destructor);
        if (idx > -1) {
          destructors.splice(idx, 1);
        }
      };
      destructors.push(destructor);
      if (!(eventType in forwardDestructors)) {
        forwardDestructors[eventType] = listen(node, eventType, forward);
      }
      return destructor;
    };
    for (let i = 0; i < events22.length; i++) {
      $on(events22[i][0], events22[i][1]);
    }
    return {
      destroy: () => {
        for (let i = 0; i < destructors.length; i++) {
          destructors[i]();
        }
        for (let entry of Object.entries(forwardDestructors)) {
          entry[1]();
        }
      }
    };
  };
}
function supportsCssVariables(windowObj, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  var CSS = windowObj.CSS;
  var supportsCssVars = supportsCssVariables_;
  if (typeof supportsCssVariables_ === "boolean" && !forceRefresh) {
    return supportsCssVariables_;
  }
  var supportsFunctionPresent = CSS && typeof CSS.supports === "function";
  if (!supportsFunctionPresent) {
    return false;
  }
  var explicitlySupportsCssVars = CSS.supports("--css-vars", "yes");
  var weAreFeatureDetectingSafari10plus = CSS.supports("(--css-vars: yes)") && CSS.supports("color", "#00000000");
  supportsCssVars = explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;
  if (!forceRefresh) {
    supportsCssVariables_ = supportsCssVars;
  }
  return supportsCssVars;
}
function getNormalizedEventCoords(evt, pageOffset, clientRect) {
  if (!evt) {
    return { x: 0, y: 0 };
  }
  var x2 = pageOffset.x, y2 = pageOffset.y;
  var documentX = x2 + clientRect.left;
  var documentY = y2 + clientRect.top;
  var normalizedX;
  var normalizedY;
  if (evt.type === "touchstart") {
    var touchEvent = evt;
    normalizedX = touchEvent.changedTouches[0].pageX - documentX;
    normalizedY = touchEvent.changedTouches[0].pageY - documentY;
  } else {
    var mouseEvent = evt;
    normalizedX = mouseEvent.pageX - documentX;
    normalizedY = mouseEvent.pageY - documentY;
  }
  return { x: normalizedX, y: normalizedY };
}
function applyPassive$1(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }
  return supportsPassiveOption(globalObj) ? { passive: true } : false;
}
function supportsPassiveOption(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }
  var passiveSupported = false;
  try {
    var options2 = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    var handler = function() {
    };
    globalObj.document.addEventListener("test", handler, options2);
    globalObj.document.removeEventListener("test", handler, options2);
  } catch (err) {
    passiveSupported = false;
  }
  return passiveSupported;
}
function closest(element, selector) {
  if (element.closest) {
    return element.closest(selector);
  }
  var el = element;
  while (el) {
    if (matches$1(el, selector)) {
      return el;
    }
    el = el.parentElement;
  }
  return null;
}
function matches$1(element, selector) {
  var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
  return nativeMatches.call(element, selector);
}
function estimateScrollWidth(element) {
  var htmlEl = element;
  if (htmlEl.offsetParent !== null) {
    return htmlEl.scrollWidth;
  }
  var clone2 = htmlEl.cloneNode(true);
  clone2.style.setProperty("position", "absolute");
  clone2.style.setProperty("transform", "translate(-9999px, -9999px)");
  document.documentElement.appendChild(clone2);
  var scrollWidth = clone2.scrollWidth;
  document.documentElement.removeChild(clone2);
  return scrollWidth;
}
function Ripple(node, { ripple = true, surface = false, unbounded = false, disabled = false, color, active, rippleElement, eventTarget, activeTarget, addClass = (className) => node.classList.add(className), removeClass = (className) => node.classList.remove(className), addStyle = (name6, value) => node.style.setProperty(name6, value), initPromise = Promise.resolve() } = {}) {
  let instance2;
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let oldActive = active;
  let oldEventTarget = eventTarget;
  let oldActiveTarget = activeTarget;
  function handleProps() {
    if (surface) {
      addClass("mdc-ripple-surface");
      if (color === "primary") {
        addClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      } else if (color === "secondary") {
        removeClass("smui-ripple-surface--primary");
        addClass("smui-ripple-surface--secondary");
      } else {
        removeClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      }
    } else {
      removeClass("mdc-ripple-surface");
      removeClass("smui-ripple-surface--primary");
      removeClass("smui-ripple-surface--secondary");
    }
    if (instance2 && oldActive !== active) {
      oldActive = active;
      if (active) {
        instance2.activate();
      } else if (active === false) {
        instance2.deactivate();
      }
    }
    if (ripple && !instance2) {
      instance2 = new MDCRippleFoundation({
        addClass,
        browserSupportsCssVars: () => supportsCssVariables(window),
        computeBoundingRect: () => (rippleElement || node).getBoundingClientRect(),
        containsEventTarget: (target) => node.contains(target),
        deregisterDocumentInteractionHandler: (evtType, handler) => document.documentElement.removeEventListener(evtType, handler, applyPassive()),
        deregisterInteractionHandler: (evtType, handler) => (eventTarget || node).removeEventListener(evtType, handler, applyPassive()),
        deregisterResizeHandler: (handler) => window.removeEventListener("resize", handler),
        getWindowPageOffset: () => ({
          x: window.pageXOffset,
          y: window.pageYOffset
        }),
        isSurfaceActive: () => active == null ? matches(activeTarget || node, ":active") : active,
        isSurfaceDisabled: () => !!disabled,
        isUnbounded: () => !!unbounded,
        registerDocumentInteractionHandler: (evtType, handler) => document.documentElement.addEventListener(evtType, handler, applyPassive()),
        registerInteractionHandler: (evtType, handler) => (eventTarget || node).addEventListener(evtType, handler, applyPassive()),
        registerResizeHandler: (handler) => window.addEventListener("resize", handler),
        removeClass,
        updateCssVariable: addStyle
      });
      initPromise.then(() => {
        if (instance2) {
          instance2.init();
          instance2.setUnbounded(unbounded);
        }
      });
    } else if (instance2 && !ripple) {
      initPromise.then(() => {
        if (instance2) {
          instance2.destroy();
          instance2 = void 0;
        }
      });
    }
    if (instance2 && (oldEventTarget !== eventTarget || oldActiveTarget !== activeTarget)) {
      oldEventTarget = eventTarget;
      oldActiveTarget = activeTarget;
      instance2.destroy();
      requestAnimationFrame(() => {
        if (instance2) {
          instance2.init();
          instance2.setUnbounded(unbounded);
        }
      });
    }
    if (!ripple && unbounded) {
      addClass("mdc-ripple-upgraded--unbounded");
    }
  }
  handleProps();
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  function layout() {
    if (instance2) {
      instance2.layout();
    }
  }
  return {
    update(props) {
      ({
        ripple,
        surface,
        unbounded,
        disabled,
        color,
        active,
        rippleElement,
        eventTarget,
        activeTarget,
        addClass,
        removeClass,
        addStyle,
        initPromise
      } = Object.assign({ ripple: true, surface: false, unbounded: false, disabled: false, color: void 0, active: void 0, rippleElement: void 0, eventTarget: void 0, activeTarget: void 0, addClass: (className) => node.classList.add(className), removeClass: (className) => node.classList.remove(className), addStyle: (name6, value) => node.style.setProperty(name6, value), initPromise: Promise.resolve() }, props));
      handleProps();
    },
    destroy() {
      if (instance2) {
        instance2.destroy();
        instance2 = void 0;
        removeClass("mdc-ripple-surface");
        removeClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      }
      if (removeLayoutListener) {
        removeLayoutListener();
      }
    }
  };
}
function classAdderBuilder(props) {
  return new Proxy(ClassAdder, {
    construct: function(target, args) {
      Object.assign(internals, defaults, props);
      return new target(...args);
    },
    get: function(target, prop) {
      Object.assign(internals, defaults, props);
      return target[prop];
    }
  });
}
var oldModifierRegex, newModifierRegex, supportsCssVariables_, MDCFoundation, events, ponyfill, cssClasses, strings, numbers, ACTIVATION_EVENT_TYPES, POINTER_DEACTIVATION_EVENT_TYPES, activatedTargets, MDCRippleFoundation, applyPassive, matches, A$1, Button$1, Div$1, H1$1, H2$1, H3$1, Li$1, Nav$1, Span$1, Ul$1, A2, Button, Div, H1, H2, H3, Li, Nav, Span, Ul, Object_1$1, internals, ClassAdder, defaults, HelperLine, Prefix, Suffix, List, Object_1, counter, Item$1, Text, Graphic$1, Item, Graphic;
var init_SelectionGroupIcon_51f30423 = __esm({
  ".svelte-kit/output/server/chunks/SelectionGroupIcon-51f30423.js"() {
    init_shims();
    init_app_dafecf1b();
    init_store_85fd0788();
    oldModifierRegex = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
    newModifierRegex = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
    MDCFoundation = function() {
      function MDCFoundation2(adapter) {
        if (adapter === void 0) {
          adapter = {};
        }
        this.adapter = adapter;
      }
      Object.defineProperty(MDCFoundation2, "cssClasses", {
        get: function() {
          return {};
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCFoundation2, "strings", {
        get: function() {
          return {};
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCFoundation2, "numbers", {
        get: function() {
          return {};
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCFoundation2, "defaultAdapter", {
        get: function() {
          return {};
        },
        enumerable: false,
        configurable: true
      });
      MDCFoundation2.prototype.init = function() {
      };
      MDCFoundation2.prototype.destroy = function() {
      };
      return MDCFoundation2;
    }();
    events = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      [Symbol.toStringTag]: "Module",
      applyPassive: applyPassive$1
    });
    ponyfill = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      [Symbol.toStringTag]: "Module",
      closest,
      matches: matches$1,
      estimateScrollWidth
    });
    cssClasses = {
      BG_FOCUSED: "mdc-ripple-upgraded--background-focused",
      FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation",
      FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation",
      ROOT: "mdc-ripple-upgraded",
      UNBOUNDED: "mdc-ripple-upgraded--unbounded"
    };
    strings = {
      VAR_FG_SCALE: "--mdc-ripple-fg-scale",
      VAR_FG_SIZE: "--mdc-ripple-fg-size",
      VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end",
      VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start",
      VAR_LEFT: "--mdc-ripple-left",
      VAR_TOP: "--mdc-ripple-top"
    };
    numbers = {
      DEACTIVATION_TIMEOUT_MS: 225,
      FG_DEACTIVATION_MS: 150,
      INITIAL_ORIGIN_SCALE: 0.6,
      PADDING: 10,
      TAP_DELAY_MS: 300
    };
    ACTIVATION_EVENT_TYPES = [
      "touchstart",
      "pointerdown",
      "mousedown",
      "keydown"
    ];
    POINTER_DEACTIVATION_EVENT_TYPES = [
      "touchend",
      "pointerup",
      "mouseup",
      "contextmenu"
    ];
    activatedTargets = [];
    MDCRippleFoundation = function(_super) {
      __extends(MDCRippleFoundation2, _super);
      function MDCRippleFoundation2(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation2.defaultAdapter), adapter)) || this;
        _this.activationAnimationHasEnded = false;
        _this.activationTimer = 0;
        _this.fgDeactivationRemovalTimer = 0;
        _this.fgScale = "0";
        _this.frame = { width: 0, height: 0 };
        _this.initialSize = 0;
        _this.layoutFrame = 0;
        _this.maxRadius = 0;
        _this.unboundedCoords = { left: 0, top: 0 };
        _this.activationState = _this.defaultActivationState();
        _this.activationTimerCallback = function() {
          _this.activationAnimationHasEnded = true;
          _this.runDeactivationUXLogicIfReady();
        };
        _this.activateHandler = function(e) {
          _this.activateImpl(e);
        };
        _this.deactivateHandler = function() {
          _this.deactivateImpl();
        };
        _this.focusHandler = function() {
          _this.handleFocus();
        };
        _this.blurHandler = function() {
          _this.handleBlur();
        };
        _this.resizeHandler = function() {
          _this.layout();
        };
        return _this;
      }
      Object.defineProperty(MDCRippleFoundation2, "cssClasses", {
        get: function() {
          return cssClasses;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCRippleFoundation2, "strings", {
        get: function() {
          return strings;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCRippleFoundation2, "numbers", {
        get: function() {
          return numbers;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCRippleFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            browserSupportsCssVars: function() {
              return true;
            },
            computeBoundingRect: function() {
              return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
            },
            containsEventTarget: function() {
              return true;
            },
            deregisterDocumentInteractionHandler: function() {
              return void 0;
            },
            deregisterInteractionHandler: function() {
              return void 0;
            },
            deregisterResizeHandler: function() {
              return void 0;
            },
            getWindowPageOffset: function() {
              return { x: 0, y: 0 };
            },
            isSurfaceActive: function() {
              return true;
            },
            isSurfaceDisabled: function() {
              return true;
            },
            isUnbounded: function() {
              return true;
            },
            registerDocumentInteractionHandler: function() {
              return void 0;
            },
            registerInteractionHandler: function() {
              return void 0;
            },
            registerResizeHandler: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            updateCssVariable: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCRippleFoundation2.prototype.init = function() {
        var _this = this;
        var supportsPressRipple = this.supportsPressRipple();
        this.registerRootHandlers(supportsPressRipple);
        if (supportsPressRipple) {
          var _a2 = MDCRippleFoundation2.cssClasses, ROOT_1 = _a2.ROOT, UNBOUNDED_1 = _a2.UNBOUNDED;
          requestAnimationFrame(function() {
            _this.adapter.addClass(ROOT_1);
            if (_this.adapter.isUnbounded()) {
              _this.adapter.addClass(UNBOUNDED_1);
              _this.layoutInternal();
            }
          });
        }
      };
      MDCRippleFoundation2.prototype.destroy = function() {
        var _this = this;
        if (this.supportsPressRipple()) {
          if (this.activationTimer) {
            clearTimeout(this.activationTimer);
            this.activationTimer = 0;
            this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_ACTIVATION);
          }
          if (this.fgDeactivationRemovalTimer) {
            clearTimeout(this.fgDeactivationRemovalTimer);
            this.fgDeactivationRemovalTimer = 0;
            this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_DEACTIVATION);
          }
          var _a2 = MDCRippleFoundation2.cssClasses, ROOT_2 = _a2.ROOT, UNBOUNDED_2 = _a2.UNBOUNDED;
          requestAnimationFrame(function() {
            _this.adapter.removeClass(ROOT_2);
            _this.adapter.removeClass(UNBOUNDED_2);
            _this.removeCssVars();
          });
        }
        this.deregisterRootHandlers();
        this.deregisterDeactivationHandlers();
      };
      MDCRippleFoundation2.prototype.activate = function(evt) {
        this.activateImpl(evt);
      };
      MDCRippleFoundation2.prototype.deactivate = function() {
        this.deactivateImpl();
      };
      MDCRippleFoundation2.prototype.layout = function() {
        var _this = this;
        if (this.layoutFrame) {
          cancelAnimationFrame(this.layoutFrame);
        }
        this.layoutFrame = requestAnimationFrame(function() {
          _this.layoutInternal();
          _this.layoutFrame = 0;
        });
      };
      MDCRippleFoundation2.prototype.setUnbounded = function(unbounded) {
        var UNBOUNDED = MDCRippleFoundation2.cssClasses.UNBOUNDED;
        if (unbounded) {
          this.adapter.addClass(UNBOUNDED);
        } else {
          this.adapter.removeClass(UNBOUNDED);
        }
      };
      MDCRippleFoundation2.prototype.handleFocus = function() {
        var _this = this;
        requestAnimationFrame(function() {
          return _this.adapter.addClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
        });
      };
      MDCRippleFoundation2.prototype.handleBlur = function() {
        var _this = this;
        requestAnimationFrame(function() {
          return _this.adapter.removeClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
        });
      };
      MDCRippleFoundation2.prototype.supportsPressRipple = function() {
        return this.adapter.browserSupportsCssVars();
      };
      MDCRippleFoundation2.prototype.defaultActivationState = function() {
        return {
          activationEvent: void 0,
          hasDeactivationUXRun: false,
          isActivated: false,
          isProgrammatic: false,
          wasActivatedByPointer: false,
          wasElementMadeActive: false
        };
      };
      MDCRippleFoundation2.prototype.registerRootHandlers = function(supportsPressRipple) {
        var e_1, _a2;
        if (supportsPressRipple) {
          try {
            for (var ACTIVATION_EVENT_TYPES_1 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next(); !ACTIVATION_EVENT_TYPES_1_1.done; ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next()) {
              var evtType = ACTIVATION_EVENT_TYPES_1_1.value;
              this.adapter.registerInteractionHandler(evtType, this.activateHandler);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (ACTIVATION_EVENT_TYPES_1_1 && !ACTIVATION_EVENT_TYPES_1_1.done && (_a2 = ACTIVATION_EVENT_TYPES_1.return))
                _a2.call(ACTIVATION_EVENT_TYPES_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          if (this.adapter.isUnbounded()) {
            this.adapter.registerResizeHandler(this.resizeHandler);
          }
        }
        this.adapter.registerInteractionHandler("focus", this.focusHandler);
        this.adapter.registerInteractionHandler("blur", this.blurHandler);
      };
      MDCRippleFoundation2.prototype.registerDeactivationHandlers = function(evt) {
        var e_2, _a2;
        if (evt.type === "keydown") {
          this.adapter.registerInteractionHandler("keyup", this.deactivateHandler);
        } else {
          try {
            for (var POINTER_DEACTIVATION_EVENT_TYPES_1 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next(); !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done; POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next()) {
              var evtType = POINTER_DEACTIVATION_EVENT_TYPES_1_1.value;
              this.adapter.registerDocumentInteractionHandler(evtType, this.deactivateHandler);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (POINTER_DEACTIVATION_EVENT_TYPES_1_1 && !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done && (_a2 = POINTER_DEACTIVATION_EVENT_TYPES_1.return))
                _a2.call(POINTER_DEACTIVATION_EVENT_TYPES_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      };
      MDCRippleFoundation2.prototype.deregisterRootHandlers = function() {
        var e_3, _a2;
        try {
          for (var ACTIVATION_EVENT_TYPES_2 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next(); !ACTIVATION_EVENT_TYPES_2_1.done; ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next()) {
            var evtType = ACTIVATION_EVENT_TYPES_2_1.value;
            this.adapter.deregisterInteractionHandler(evtType, this.activateHandler);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (ACTIVATION_EVENT_TYPES_2_1 && !ACTIVATION_EVENT_TYPES_2_1.done && (_a2 = ACTIVATION_EVENT_TYPES_2.return))
              _a2.call(ACTIVATION_EVENT_TYPES_2);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        this.adapter.deregisterInteractionHandler("focus", this.focusHandler);
        this.adapter.deregisterInteractionHandler("blur", this.blurHandler);
        if (this.adapter.isUnbounded()) {
          this.adapter.deregisterResizeHandler(this.resizeHandler);
        }
      };
      MDCRippleFoundation2.prototype.deregisterDeactivationHandlers = function() {
        var e_4, _a2;
        this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler);
        try {
          for (var POINTER_DEACTIVATION_EVENT_TYPES_2 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next(); !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done; POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next()) {
            var evtType = POINTER_DEACTIVATION_EVENT_TYPES_2_1.value;
            this.adapter.deregisterDocumentInteractionHandler(evtType, this.deactivateHandler);
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (POINTER_DEACTIVATION_EVENT_TYPES_2_1 && !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done && (_a2 = POINTER_DEACTIVATION_EVENT_TYPES_2.return))
              _a2.call(POINTER_DEACTIVATION_EVENT_TYPES_2);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
      };
      MDCRippleFoundation2.prototype.removeCssVars = function() {
        var _this = this;
        var rippleStrings = MDCRippleFoundation2.strings;
        var keys = Object.keys(rippleStrings);
        keys.forEach(function(key) {
          if (key.indexOf("VAR_") === 0) {
            _this.adapter.updateCssVariable(rippleStrings[key], null);
          }
        });
      };
      MDCRippleFoundation2.prototype.activateImpl = function(evt) {
        var _this = this;
        if (this.adapter.isSurfaceDisabled()) {
          return;
        }
        var activationState = this.activationState;
        if (activationState.isActivated) {
          return;
        }
        var previousActivationEvent = this.previousActivationEvent;
        var isSameInteraction = previousActivationEvent && evt !== void 0 && previousActivationEvent.type !== evt.type;
        if (isSameInteraction) {
          return;
        }
        activationState.isActivated = true;
        activationState.isProgrammatic = evt === void 0;
        activationState.activationEvent = evt;
        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== void 0 && (evt.type === "mousedown" || evt.type === "touchstart" || evt.type === "pointerdown");
        var hasActivatedChild = evt !== void 0 && activatedTargets.length > 0 && activatedTargets.some(function(target) {
          return _this.adapter.containsEventTarget(target);
        });
        if (hasActivatedChild) {
          this.resetActivationState();
          return;
        }
        if (evt !== void 0) {
          activatedTargets.push(evt.target);
          this.registerDeactivationHandlers(evt);
        }
        activationState.wasElementMadeActive = this.checkElementMadeActive(evt);
        if (activationState.wasElementMadeActive) {
          this.animateActivation();
        }
        requestAnimationFrame(function() {
          activatedTargets = [];
          if (!activationState.wasElementMadeActive && evt !== void 0 && (evt.key === " " || evt.keyCode === 32)) {
            activationState.wasElementMadeActive = _this.checkElementMadeActive(evt);
            if (activationState.wasElementMadeActive) {
              _this.animateActivation();
            }
          }
          if (!activationState.wasElementMadeActive) {
            _this.activationState = _this.defaultActivationState();
          }
        });
      };
      MDCRippleFoundation2.prototype.checkElementMadeActive = function(evt) {
        return evt !== void 0 && evt.type === "keydown" ? this.adapter.isSurfaceActive() : true;
      };
      MDCRippleFoundation2.prototype.animateActivation = function() {
        var _this = this;
        var _a2 = MDCRippleFoundation2.strings, VAR_FG_TRANSLATE_START = _a2.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a2.VAR_FG_TRANSLATE_END;
        var _b = MDCRippleFoundation2.cssClasses, FG_DEACTIVATION = _b.FG_DEACTIVATION, FG_ACTIVATION = _b.FG_ACTIVATION;
        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation2.numbers.DEACTIVATION_TIMEOUT_MS;
        this.layoutInternal();
        var translateStart = "";
        var translateEnd = "";
        if (!this.adapter.isUnbounded()) {
          var _c2 = this.getFgTranslationCoordinates(), startPoint = _c2.startPoint, endPoint = _c2.endPoint;
          translateStart = startPoint.x + "px, " + startPoint.y + "px";
          translateEnd = endPoint.x + "px, " + endPoint.y + "px";
        }
        this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
        this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
        clearTimeout(this.activationTimer);
        clearTimeout(this.fgDeactivationRemovalTimer);
        this.rmBoundedActivationClasses();
        this.adapter.removeClass(FG_DEACTIVATION);
        this.adapter.computeBoundingRect();
        this.adapter.addClass(FG_ACTIVATION);
        this.activationTimer = setTimeout(function() {
          _this.activationTimerCallback();
        }, DEACTIVATION_TIMEOUT_MS);
      };
      MDCRippleFoundation2.prototype.getFgTranslationCoordinates = function() {
        var _a2 = this.activationState, activationEvent = _a2.activationEvent, wasActivatedByPointer = _a2.wasActivatedByPointer;
        var startPoint;
        if (wasActivatedByPointer) {
          startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());
        } else {
          startPoint = {
            x: this.frame.width / 2,
            y: this.frame.height / 2
          };
        }
        startPoint = {
          x: startPoint.x - this.initialSize / 2,
          y: startPoint.y - this.initialSize / 2
        };
        var endPoint = {
          x: this.frame.width / 2 - this.initialSize / 2,
          y: this.frame.height / 2 - this.initialSize / 2
        };
        return { startPoint, endPoint };
      };
      MDCRippleFoundation2.prototype.runDeactivationUXLogicIfReady = function() {
        var _this = this;
        var FG_DEACTIVATION = MDCRippleFoundation2.cssClasses.FG_DEACTIVATION;
        var _a2 = this.activationState, hasDeactivationUXRun = _a2.hasDeactivationUXRun, isActivated = _a2.isActivated;
        var activationHasEnded = hasDeactivationUXRun || !isActivated;
        if (activationHasEnded && this.activationAnimationHasEnded) {
          this.rmBoundedActivationClasses();
          this.adapter.addClass(FG_DEACTIVATION);
          this.fgDeactivationRemovalTimer = setTimeout(function() {
            _this.adapter.removeClass(FG_DEACTIVATION);
          }, numbers.FG_DEACTIVATION_MS);
        }
      };
      MDCRippleFoundation2.prototype.rmBoundedActivationClasses = function() {
        var FG_ACTIVATION = MDCRippleFoundation2.cssClasses.FG_ACTIVATION;
        this.adapter.removeClass(FG_ACTIVATION);
        this.activationAnimationHasEnded = false;
        this.adapter.computeBoundingRect();
      };
      MDCRippleFoundation2.prototype.resetActivationState = function() {
        var _this = this;
        this.previousActivationEvent = this.activationState.activationEvent;
        this.activationState = this.defaultActivationState();
        setTimeout(function() {
          return _this.previousActivationEvent = void 0;
        }, MDCRippleFoundation2.numbers.TAP_DELAY_MS);
      };
      MDCRippleFoundation2.prototype.deactivateImpl = function() {
        var _this = this;
        var activationState = this.activationState;
        if (!activationState.isActivated) {
          return;
        }
        var state = __assign({}, activationState);
        if (activationState.isProgrammatic) {
          requestAnimationFrame(function() {
            _this.animateDeactivation(state);
          });
          this.resetActivationState();
        } else {
          this.deregisterDeactivationHandlers();
          requestAnimationFrame(function() {
            _this.activationState.hasDeactivationUXRun = true;
            _this.animateDeactivation(state);
            _this.resetActivationState();
          });
        }
      };
      MDCRippleFoundation2.prototype.animateDeactivation = function(_a2) {
        var wasActivatedByPointer = _a2.wasActivatedByPointer, wasElementMadeActive = _a2.wasElementMadeActive;
        if (wasActivatedByPointer || wasElementMadeActive) {
          this.runDeactivationUXLogicIfReady();
        }
      };
      MDCRippleFoundation2.prototype.layoutInternal = function() {
        var _this = this;
        this.frame = this.adapter.computeBoundingRect();
        var maxDim = Math.max(this.frame.height, this.frame.width);
        var getBoundedRadius = function() {
          var hypotenuse = Math.sqrt(Math.pow(_this.frame.width, 2) + Math.pow(_this.frame.height, 2));
          return hypotenuse + MDCRippleFoundation2.numbers.PADDING;
        };
        this.maxRadius = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();
        var initialSize = Math.floor(maxDim * MDCRippleFoundation2.numbers.INITIAL_ORIGIN_SCALE);
        if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {
          this.initialSize = initialSize - 1;
        } else {
          this.initialSize = initialSize;
        }
        this.fgScale = "" + this.maxRadius / this.initialSize;
        this.updateLayoutCssVars();
      };
      MDCRippleFoundation2.prototype.updateLayoutCssVars = function() {
        var _a2 = MDCRippleFoundation2.strings, VAR_FG_SIZE = _a2.VAR_FG_SIZE, VAR_LEFT = _a2.VAR_LEFT, VAR_TOP = _a2.VAR_TOP, VAR_FG_SCALE = _a2.VAR_FG_SCALE;
        this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize + "px");
        this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale);
        if (this.adapter.isUnbounded()) {
          this.unboundedCoords = {
            left: Math.round(this.frame.width / 2 - this.initialSize / 2),
            top: Math.round(this.frame.height / 2 - this.initialSize / 2)
          };
          this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords.left + "px");
          this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords.top + "px");
        }
      };
      return MDCRippleFoundation2;
    }(MDCFoundation);
    ({ applyPassive } = events);
    ({ matches } = ponyfill);
    A$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "href", "getElement"]);
      let { use = [] } = $$props;
      let { href = "javascript:void(0);" } = $$props;
      forwardEventsBuilder(get_current_component());
      let element;
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.href === void 0 && $$bindings.href && href !== void 0)
        $$bindings.href(href);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<a${spread([{ href: escape_attribute_value(href) }, escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</a>`;
    });
    Button$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
      let { use = [] } = $$props;
      forwardEventsBuilder(get_current_component());
      let element;
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<button${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</button>`;
    });
    Div$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
      let { use = [] } = $$props;
      forwardEventsBuilder(get_current_component());
      let element;
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<div${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</div>`;
    });
    H1$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
      let { use = [] } = $$props;
      forwardEventsBuilder(get_current_component());
      let element;
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<h1${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</h1>`;
    });
    H2$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
      let { use = [] } = $$props;
      forwardEventsBuilder(get_current_component());
      let element;
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<h2${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</h2>`;
    });
    H3$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
      let { use = [] } = $$props;
      forwardEventsBuilder(get_current_component());
      let element;
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<h3${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</h3>`;
    });
    Li$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
      let { use = [] } = $$props;
      forwardEventsBuilder(get_current_component());
      let element;
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<li${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</li>`;
    });
    Nav$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
      let { use = [] } = $$props;
      forwardEventsBuilder(get_current_component());
      let element;
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<nav${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</nav>`;
    });
    Span$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
      let { use = [] } = $$props;
      forwardEventsBuilder(get_current_component());
      let element;
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<span${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</span>`;
    });
    Ul$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
      let { use = [] } = $$props;
      forwardEventsBuilder(get_current_component());
      let element;
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<ul${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</ul>`;
    });
    A2 = A$1;
    Button = Button$1;
    Div = Div$1;
    H1 = H1$1;
    H2 = H2$1;
    H3 = H3$1;
    Li = Li$1;
    Nav = Nav$1;
    Span = Span$1;
    Ul = Ul$1;
    ({ Object: Object_1$1 } = globals);
    internals = {
      component: Div$1,
      class: "",
      classMap: {},
      contexts: {},
      props: {}
    };
    ClassAdder = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "class", "component", "getElement"]);
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let element;
      const smuiClass = internals.class;
      const smuiClassMap = {};
      const smuiClassUnsubscribes = [];
      const contexts = internals.contexts;
      const props = internals.props;
      let { component = internals.component } = $$props;
      Object.entries(internals.classMap).forEach(([name6, context]) => {
        const store2 = getContext(context);
        if (store2 && "subscribe" in store2) {
          smuiClassUnsubscribes.push(store2.subscribe((value) => {
            smuiClassMap[name6] = value;
          }));
        }
      });
      const forwardEvents = forwardEventsBuilder(get_current_component());
      for (let context in contexts) {
        if (contexts.hasOwnProperty(context)) {
          setContext(context, contexts[context]);
        }
      }
      onDestroy(() => {
        for (const unsubscribe of smuiClassUnsubscribes) {
          unsubscribe();
        }
      });
      function getElement() {
        return element.getElement();
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.component === void 0 && $$bindings.component && component !== void 0)
        $$bindings.component(component);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `${validate_component(component || missing_component, "svelte:component").$$render($$result, Object_1$1.assign({ use: [forwardEvents, ...use] }, {
          class: classMap({
            [className]: true,
            [smuiClass]: true,
            ...smuiClassMap
          })
        }, props, $$restProps, { this: element }), {
          this: ($$value) => {
            element = $$value;
            $$settled = false;
          }
        }, {
          default: () => `${slots.default ? slots.default({}) : ``}`
        })}`;
      } while (!$$settled);
      return $$rendered;
    });
    defaults = Object.assign({}, internals);
    HelperLine = classAdderBuilder({
      class: "mdc-text-field-helper-line",
      component: Div
    });
    Prefix = classAdderBuilder({
      class: "mdc-text-field__affix mdc-text-field__affix--prefix",
      component: Span
    });
    Suffix = classAdderBuilder({
      class: "mdc-text-field__affix mdc-text-field__affix--suffix",
      component: Span
    });
    List = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "use",
        "class",
        "nonInteractive",
        "dense",
        "textualList",
        "avatarList",
        "iconList",
        "imageList",
        "thumbnailList",
        "videoList",
        "twoLine",
        "threeLine",
        "vertical",
        "wrapFocus",
        "singleSelection",
        "selectedIndex",
        "radioList",
        "checkList",
        "hasTypeahead",
        "component",
        "layout",
        "setEnabled",
        "getTypeaheadInProgress",
        "getSelectedIndex",
        "getFocusedItemIndex",
        "getElement"
      ]);
      var _a2;
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { nonInteractive = false } = $$props;
      let { dense = false } = $$props;
      let { textualList = false } = $$props;
      let { avatarList = false } = $$props;
      let { iconList = false } = $$props;
      let { imageList = false } = $$props;
      let { thumbnailList = false } = $$props;
      let { videoList = false } = $$props;
      let { twoLine = false } = $$props;
      let { threeLine = false } = $$props;
      let { vertical = true } = $$props;
      let { wrapFocus = (_a2 = getContext("SMUI:list:wrapFocus")) !== null && _a2 !== void 0 ? _a2 : false } = $$props;
      let { singleSelection = false } = $$props;
      let { selectedIndex = -1 } = $$props;
      let { radioList = false } = $$props;
      let { checkList = false } = $$props;
      let { hasTypeahead = false } = $$props;
      let element;
      let instance2;
      let role = getContext("SMUI:list:role");
      let nav = getContext("SMUI:list:nav");
      let selectionDialog = getContext("SMUI:dialog:selection");
      let addLayoutListener = getContext("SMUI:addLayoutListener");
      let removeLayoutListener;
      let { component = nav ? Nav : Ul } = $$props;
      setContext("SMUI:list:nonInteractive", nonInteractive);
      setContext("SMUI:separator:context", "list");
      if (!role) {
        if (singleSelection) {
          role = "listbox";
          setContext("SMUI:list:item:role", "option");
        } else if (radioList) {
          role = "radiogroup";
          setContext("SMUI:list:item:role", "radio");
        } else if (checkList) {
          role = "group";
          setContext("SMUI:list:item:role", "checkbox");
        } else {
          role = "list";
          setContext("SMUI:list:item:role", void 0);
        }
      }
      if (addLayoutListener) {
        removeLayoutListener = addLayoutListener(layout);
      }
      onDestroy(() => {
        if (removeLayoutListener) {
          removeLayoutListener();
        }
      });
      function layout() {
        return instance2.layout();
      }
      function setEnabled(itemIndex, isEnabled) {
        return instance2.setEnabled(itemIndex, isEnabled);
      }
      function getTypeaheadInProgress() {
        return instance2.isTypeaheadInProgress();
      }
      function getSelectedIndex() {
        return instance2.getSelectedIndex();
      }
      function getFocusedItemIndex() {
        return instance2.getFocusedItemIndex();
      }
      function getElement() {
        return element.getElement();
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.nonInteractive === void 0 && $$bindings.nonInteractive && nonInteractive !== void 0)
        $$bindings.nonInteractive(nonInteractive);
      if ($$props.dense === void 0 && $$bindings.dense && dense !== void 0)
        $$bindings.dense(dense);
      if ($$props.textualList === void 0 && $$bindings.textualList && textualList !== void 0)
        $$bindings.textualList(textualList);
      if ($$props.avatarList === void 0 && $$bindings.avatarList && avatarList !== void 0)
        $$bindings.avatarList(avatarList);
      if ($$props.iconList === void 0 && $$bindings.iconList && iconList !== void 0)
        $$bindings.iconList(iconList);
      if ($$props.imageList === void 0 && $$bindings.imageList && imageList !== void 0)
        $$bindings.imageList(imageList);
      if ($$props.thumbnailList === void 0 && $$bindings.thumbnailList && thumbnailList !== void 0)
        $$bindings.thumbnailList(thumbnailList);
      if ($$props.videoList === void 0 && $$bindings.videoList && videoList !== void 0)
        $$bindings.videoList(videoList);
      if ($$props.twoLine === void 0 && $$bindings.twoLine && twoLine !== void 0)
        $$bindings.twoLine(twoLine);
      if ($$props.threeLine === void 0 && $$bindings.threeLine && threeLine !== void 0)
        $$bindings.threeLine(threeLine);
      if ($$props.vertical === void 0 && $$bindings.vertical && vertical !== void 0)
        $$bindings.vertical(vertical);
      if ($$props.wrapFocus === void 0 && $$bindings.wrapFocus && wrapFocus !== void 0)
        $$bindings.wrapFocus(wrapFocus);
      if ($$props.singleSelection === void 0 && $$bindings.singleSelection && singleSelection !== void 0)
        $$bindings.singleSelection(singleSelection);
      if ($$props.selectedIndex === void 0 && $$bindings.selectedIndex && selectedIndex !== void 0)
        $$bindings.selectedIndex(selectedIndex);
      if ($$props.radioList === void 0 && $$bindings.radioList && radioList !== void 0)
        $$bindings.radioList(radioList);
      if ($$props.checkList === void 0 && $$bindings.checkList && checkList !== void 0)
        $$bindings.checkList(checkList);
      if ($$props.hasTypeahead === void 0 && $$bindings.hasTypeahead && hasTypeahead !== void 0)
        $$bindings.hasTypeahead(hasTypeahead);
      if ($$props.component === void 0 && $$bindings.component && component !== void 0)
        $$bindings.component(component);
      if ($$props.layout === void 0 && $$bindings.layout && layout !== void 0)
        $$bindings.layout(layout);
      if ($$props.setEnabled === void 0 && $$bindings.setEnabled && setEnabled !== void 0)
        $$bindings.setEnabled(setEnabled);
      if ($$props.getTypeaheadInProgress === void 0 && $$bindings.getTypeaheadInProgress && getTypeaheadInProgress !== void 0)
        $$bindings.getTypeaheadInProgress(getTypeaheadInProgress);
      if ($$props.getSelectedIndex === void 0 && $$bindings.getSelectedIndex && getSelectedIndex !== void 0)
        $$bindings.getSelectedIndex(getSelectedIndex);
      if ($$props.getFocusedItemIndex === void 0 && $$bindings.getFocusedItemIndex && getFocusedItemIndex !== void 0)
        $$bindings.getFocusedItemIndex(getFocusedItemIndex);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `${validate_component(component || missing_component, "svelte:component").$$render($$result, Object.assign({ use: [forwardEvents, ...use] }, {
          class: classMap({
            [className]: true,
            "mdc-deprecated-list": true,
            "mdc-deprecated-list--non-interactive": nonInteractive,
            "mdc-deprecated-list--dense": dense,
            "mdc-deprecated-list--textual-list": textualList,
            "mdc-deprecated-list--avatar-list": avatarList || selectionDialog,
            "mdc-deprecated-list--icon-list": iconList,
            "mdc-deprecated-list--image-list": imageList,
            "mdc-deprecated-list--thumbnail-list": thumbnailList,
            "mdc-deprecated-list--video-list": videoList,
            "mdc-deprecated-list--two-line": twoLine,
            "smui-list--three-line": threeLine && !twoLine
          })
        }, { role }, $$restProps, { this: element }), {
          this: ($$value) => {
            element = $$value;
            $$settled = false;
          }
        }, {
          default: () => `${slots.default ? slots.default({}) : ``}`
        })}`;
      } while (!$$settled);
      return $$rendered;
    });
    ({ Object: Object_1 } = globals);
    counter = 0;
    Item$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let tabindex;
      let $$restProps = compute_rest_props($$props, [
        "use",
        "class",
        "style",
        "color",
        "nonInteractive",
        "ripple",
        "activated",
        "role",
        "selected",
        "disabled",
        "skipRestoreFocus",
        "tabindex",
        "inputId",
        "href",
        "component",
        "action",
        "getPrimaryText",
        "getElement"
      ]);
      var _a2;
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let uninitializedValue = () => {
      };
      function isUninitializedValue(value) {
        return value === uninitializedValue;
      }
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { style = "" } = $$props;
      let { color = void 0 } = $$props;
      let { nonInteractive = (_a2 = getContext("SMUI:list:nonInteractive")) !== null && _a2 !== void 0 ? _a2 : false } = $$props;
      setContext("SMUI:list:nonInteractive", void 0);
      let { ripple = !nonInteractive } = $$props;
      let { activated = false } = $$props;
      let { role = getContext("SMUI:list:item:role") } = $$props;
      setContext("SMUI:list:item:role", void 0);
      let { selected = false } = $$props;
      let { disabled = false } = $$props;
      let { skipRestoreFocus = false } = $$props;
      let { tabindex: tabindexProp = uninitializedValue } = $$props;
      let { inputId = "SMUI-form-field-list-" + counter++ } = $$props;
      let { href = void 0 } = $$props;
      let element;
      let internalClasses = {};
      let internalStyles = {};
      let internalAttrs = {};
      let input;
      let nav = getContext("SMUI:list:item:nav");
      let { component = nav ? href ? A2 : Span : Li } = $$props;
      setContext("SMUI:generic:input:props", { id: inputId });
      setContext("SMUI:separator:context", void 0);
      onDestroy(() => {
      });
      function addClass(className2) {
        if (!internalClasses[className2]) {
          internalClasses[className2] = true;
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          internalClasses[className2] = false;
        }
      }
      function addStyle(name6, value) {
        if (internalStyles[name6] != value) {
          if (value === "" || value == null) {
            delete internalStyles[name6];
            internalStyles = internalStyles;
          } else {
            internalStyles[name6] = value;
          }
        }
      }
      function action(e) {
        if (!disabled) {
          dispatch(getElement(), "SMUI:action", e);
        }
      }
      function getPrimaryText() {
        var _a22, _b, _c2;
        const element2 = getElement();
        const primaryText = element2.querySelector(".mdc-deprecated-list-item__primary-text");
        if (primaryText) {
          return (_a22 = primaryText.textContent) !== null && _a22 !== void 0 ? _a22 : "";
        }
        const text = element2.querySelector(".mdc-deprecated-list-item__text");
        if (text) {
          return (_b = text.textContent) !== null && _b !== void 0 ? _b : "";
        }
        return (_c2 = element2.textContent) !== null && _c2 !== void 0 ? _c2 : "";
      }
      function getElement() {
        return element.getElement();
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.style === void 0 && $$bindings.style && style !== void 0)
        $$bindings.style(style);
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.nonInteractive === void 0 && $$bindings.nonInteractive && nonInteractive !== void 0)
        $$bindings.nonInteractive(nonInteractive);
      if ($$props.ripple === void 0 && $$bindings.ripple && ripple !== void 0)
        $$bindings.ripple(ripple);
      if ($$props.activated === void 0 && $$bindings.activated && activated !== void 0)
        $$bindings.activated(activated);
      if ($$props.role === void 0 && $$bindings.role && role !== void 0)
        $$bindings.role(role);
      if ($$props.selected === void 0 && $$bindings.selected && selected !== void 0)
        $$bindings.selected(selected);
      if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
        $$bindings.disabled(disabled);
      if ($$props.skipRestoreFocus === void 0 && $$bindings.skipRestoreFocus && skipRestoreFocus !== void 0)
        $$bindings.skipRestoreFocus(skipRestoreFocus);
      if ($$props.tabindex === void 0 && $$bindings.tabindex && tabindexProp !== void 0)
        $$bindings.tabindex(tabindexProp);
      if ($$props.inputId === void 0 && $$bindings.inputId && inputId !== void 0)
        $$bindings.inputId(inputId);
      if ($$props.href === void 0 && $$bindings.href && href !== void 0)
        $$bindings.href(href);
      if ($$props.component === void 0 && $$bindings.component && component !== void 0)
        $$bindings.component(component);
      if ($$props.action === void 0 && $$bindings.action && action !== void 0)
        $$bindings.action(action);
      if ($$props.getPrimaryText === void 0 && $$bindings.getPrimaryText && getPrimaryText !== void 0)
        $$bindings.getPrimaryText(getPrimaryText);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        tabindex = isUninitializedValue(tabindexProp) ? !nonInteractive && !disabled && (selected || input) ? 0 : -1 : tabindexProp;
        $$rendered = `${validate_component(component || missing_component, "svelte:component").$$render($$result, Object_1.assign({
          use: [
            ...nonInteractive ? [] : [
              [
                Ripple,
                {
                  ripple: !input,
                  unbounded: false,
                  color: (activated || selected) && color == null ? "primary" : color,
                  disabled,
                  addClass,
                  removeClass,
                  addStyle
                }
              ]
            ],
            forwardEvents,
            ...use
          ]
        }, {
          class: classMap({
            [className]: true,
            "mdc-deprecated-list-item": true,
            "mdc-deprecated-list-item--activated": activated,
            "mdc-deprecated-list-item--selected": selected,
            "mdc-deprecated-list-item--disabled": disabled,
            "mdc-menu-item--selected": !nav && role === "menuitem" && selected,
            "smui-menu-item--non-interactive": nonInteractive,
            ...internalClasses
          })
        }, {
          style: Object.entries(internalStyles).map(([name6, value]) => `${name6}: ${value};`).concat([style]).join(" ")
        }, nav && activated ? { "aria-current": "page" } : {}, !nav ? { role } : {}, !nav && role === "option" ? {
          "aria-selected": selected ? "true" : "false"
        } : {}, !nav && (role === "radio" || role === "checkbox") ? {
          "aria-checked": "false"
        } : {}, !nav ? {
          "aria-disabled": disabled ? "true" : "false"
        } : {}, {
          "data-menu-item-skip-restore-focus": skipRestoreFocus || void 0
        }, { tabindex }, { href }, internalAttrs, $$restProps, { this: element }), {
          this: ($$value) => {
            element = $$value;
            $$settled = false;
          }
        }, {
          default: () => `${ripple ? `<span class="${"mdc-deprecated-list-item__ripple"}"></span>` : ``}${slots.default ? slots.default({}) : ``}`
        })}`;
      } while (!$$settled);
      return $$rendered;
    });
    Text = classAdderBuilder({
      class: "mdc-deprecated-list-item__text",
      component: Span
    });
    classAdderBuilder({
      class: "mdc-deprecated-list-item__primary-text",
      component: Span
    });
    classAdderBuilder({
      class: "mdc-deprecated-list-item__secondary-text",
      component: Span
    });
    Graphic$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "class", "getElement"]);
      forwardEventsBuilder(get_current_component());
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let element;
      let menuSelectionGroup = getContext("SMUI:list:graphic:menu-selection-group");
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<span${spread([
        {
          class: escape_attribute_value(classMap({
            [className]: true,
            "mdc-deprecated-list-item__graphic": true,
            "mdc-menu__selection-group-icon": menuSelectionGroup
          }))
        },
        escape_object($$restProps)
      ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</span>`;
    });
    classAdderBuilder({
      class: "mdc-deprecated-list-item__meta",
      component: Span
    });
    classAdderBuilder({
      class: "mdc-deprecated-list-group",
      component: Div
    });
    classAdderBuilder({
      class: "mdc-deprecated-list-group__subheader",
      component: H3
    });
    Item = Item$1;
    Graphic = Graphic$1;
    classAdderBuilder({
      class: "mdc-menu__selection-group-icon",
      component: Graphic
    });
  }
});

// .svelte-kit/output/server/chunks/DoodleVideo.svelte_svelte_type_style_lang-1ac60caf.js
var Object_12, Button_1;
var init_DoodleVideo_svelte_svelte_type_style_lang_1ac60caf = __esm({
  ".svelte-kit/output/server/chunks/DoodleVideo.svelte_svelte_type_style_lang-1ac60caf.js"() {
    init_shims();
    init_app_dafecf1b();
    init_SelectionGroupIcon_51f30423();
    ({ Object: Object_12 } = globals);
    Button_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let actionProp;
      let defaultProp;
      let secondaryProp;
      let $$restProps = compute_rest_props($$props, [
        "use",
        "class",
        "style",
        "ripple",
        "color",
        "variant",
        "touch",
        "href",
        "action",
        "defaultAction",
        "secondary",
        "component",
        "getElement"
      ]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { style = "" } = $$props;
      let { ripple = true } = $$props;
      let { color = "primary" } = $$props;
      let { variant = "text" } = $$props;
      let { touch = false } = $$props;
      let { href = void 0 } = $$props;
      let { action = "close" } = $$props;
      let { defaultAction = false } = $$props;
      let { secondary = false } = $$props;
      let element;
      let internalClasses = {};
      let internalStyles = {};
      let context = getContext("SMUI:button:context");
      let { component = href == null ? Button : A2 } = $$props;
      setContext("SMUI:label:context", "button");
      setContext("SMUI:icon:context", "button");
      function addClass(className2) {
        if (!internalClasses[className2]) {
          internalClasses[className2] = true;
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          internalClasses[className2] = false;
        }
      }
      function addStyle(name6, value) {
        if (internalStyles[name6] != value) {
          if (value === "" || value == null) {
            delete internalStyles[name6];
            internalStyles = internalStyles;
          } else {
            internalStyles[name6] = value;
          }
        }
      }
      function getElement() {
        return element.getElement();
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.style === void 0 && $$bindings.style && style !== void 0)
        $$bindings.style(style);
      if ($$props.ripple === void 0 && $$bindings.ripple && ripple !== void 0)
        $$bindings.ripple(ripple);
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.variant === void 0 && $$bindings.variant && variant !== void 0)
        $$bindings.variant(variant);
      if ($$props.touch === void 0 && $$bindings.touch && touch !== void 0)
        $$bindings.touch(touch);
      if ($$props.href === void 0 && $$bindings.href && href !== void 0)
        $$bindings.href(href);
      if ($$props.action === void 0 && $$bindings.action && action !== void 0)
        $$bindings.action(action);
      if ($$props.defaultAction === void 0 && $$bindings.defaultAction && defaultAction !== void 0)
        $$bindings.defaultAction(defaultAction);
      if ($$props.secondary === void 0 && $$bindings.secondary && secondary !== void 0)
        $$bindings.secondary(secondary);
      if ($$props.component === void 0 && $$bindings.component && component !== void 0)
        $$bindings.component(component);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        actionProp = context === "dialog:action" && action != null ? { "data-mdc-dialog-action": action } : { action: $$props.action };
        defaultProp = context === "dialog:action" && defaultAction ? { "data-mdc-dialog-button-default": "" } : { default: $$props.default };
        secondaryProp = context === "banner" ? {} : { secondary: $$props.secondary };
        $$rendered = `${validate_component(component || missing_component, "svelte:component").$$render($$result, Object_12.assign({
          use: [
            [
              Ripple,
              {
                ripple,
                unbounded: false,
                color,
                disabled: !!$$restProps.disabled,
                addClass,
                removeClass,
                addStyle
              }
            ],
            forwardEvents,
            ...use
          ]
        }, {
          class: classMap({
            [className]: true,
            "mdc-button": true,
            "mdc-button--raised": variant === "raised",
            "mdc-button--unelevated": variant === "unelevated",
            "mdc-button--outlined": variant === "outlined",
            "smui-button--color-secondary": color === "secondary",
            "mdc-button--touch": touch,
            "mdc-card__action": context === "card:action",
            "mdc-card__action--button": context === "card:action",
            "mdc-dialog__button": context === "dialog:action",
            "mdc-top-app-bar__navigation-icon": context === "top-app-bar:navigation",
            "mdc-top-app-bar__action-item": context === "top-app-bar:action",
            "mdc-snackbar__action": context === "snackbar:actions",
            "mdc-banner__secondary-action": context === "banner" && secondary,
            "mdc-banner__primary-action": context === "banner" && !secondary,
            "mdc-tooltip__action": context === "tooltip:rich-actions",
            ...internalClasses
          })
        }, {
          style: Object.entries(internalStyles).map(([name6, value]) => `${name6}: ${value};`).concat([style]).join(" ")
        }, actionProp, defaultProp, secondaryProp, { href }, $$restProps, { this: element }), {
          this: ($$value) => {
            element = $$value;
            $$settled = false;
          }
        }, {
          default: () => `<div class="${"mdc-button__ripple"}"></div>
  ${slots.default ? slots.default({}) : ``}${touch ? `<div class="${"mdc-button__touch"}"></div>` : ``}`
        })}`;
      } while (!$$settled);
      return $$rendered;
    });
  }
});

// .svelte-kit/output/server/chunks/canvas-fb765f32.js
function calculateCanvasDimensions() {
  const appElement = document.getElementById("main-content");
  let availableHeight;
  let availableWidth;
  const aspectRatio = 4 / 3;
  if (appElement) {
    availableHeight = appElement.clientHeight;
    availableWidth = appElement.clientWidth;
  } else {
    availableHeight = window.innerHeight;
    availableWidth = window.innerWidth;
  }
  let dimensions = {};
  if (availableWidth * (1 / aspectRatio) < availableHeight) {
    dimensions.width = 0.95 * availableWidth;
    dimensions.height = dimensions.width * (1 / aspectRatio);
  } else {
    dimensions.height = 0.95 * availableHeight;
    dimensions.width = dimensions.height * aspectRatio;
  }
  return dimensions;
}
function calculateCanvasDimensions2() {
  const normalD = calculateCanvasDimensions();
  return { width: 0.9 * normalD.width, height: 0.9 * normalD.height };
}
var init_canvas_fb765f32 = __esm({
  ".svelte-kit/output/server/chunks/canvas-fb765f32.js"() {
    init_shims();
  }
});

// .svelte-kit/output/server/chunks/index-910f8a98.js
var index_910f8a98_exports = {};
__export(index_910f8a98_exports, {
  default: () => Routes
});
var import_node_fetch2, import_cookie3, css, phoneNumSegment1, phoneNumSegment2, phoneNumSegment3, Routes;
var init_index_910f8a98 = __esm({
  ".svelte-kit/output/server/chunks/index-910f8a98.js"() {
    init_shims();
    init_app_dafecf1b();
    init_index_c327074d_b42dfde1();
    init_store_85fd0788();
    import_node_fetch2 = __toModule(require_lib2());
    init_DoodleVideo_svelte_svelte_type_style_lang_1ac60caf();
    init_SelectionGroupIcon_51f30423();
    init_canvas_fb765f32();
    import_cookie3 = __toModule(require_cookie());
    init_dist();
    css = {
      code: `.room-title input{font-size:2rem}.question input{color:rgb(19, 145, 230) !important\r
}.copied-from-koa.svelte-ufphu6{font:26px/1.7 "Lucida Grande", "Lucida Sans Unicode", Helvetica, Arial, Verdana, sans-serif\r
}.copied-from-koa-2.svelte-ufphu6{font:18px/1.7 "Lucida Grande", "Lucida Sans Unicode", Helvetica, Arial, Verdana, sans-serif\r
}#logo.svelte-ufphu6{font:300px 'Italiana', sans-serif;text-transform:lowercase}`,
      map: null
    };
    phoneNumSegment1 = "";
    phoneNumSegment2 = "";
    phoneNumSegment3 = "";
    Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let isQuestionMode;
      let $user, $$unsubscribe_user;
      $$unsubscribe_user = subscribe(user, (value) => $user = value);
      let currentTime = 10;
      let titleValue = "Welcome!";
      let appVerifier;
      const print = console.log;
      let timer;
      function adjustContentDimensions() {
        const { width, height } = calculateCanvasDimensions2();
        canvasWidth.set(width);
        canvasHeight.set(height);
      }
      onDestroy(() => {
        window.removeEventListener("resize", adjustContentDimensions);
      });
      function signInWithPhone() {
        if (!window.recaptchaVerifier) {
          window.recaptchaVerifier = new RecaptchaVerifier("sign-in-button", {
            "size": "invisible",
            "callback": (response) => {
              console.log("reCAPTCHA solved =", response);
            }
          }, getAuth());
          appVerifier = window.recaptchaVerifier;
        }
        onSignInSubmit();
        function onSignInSubmit() {
          const phoneNumber = `+1 ${phoneNumSegment1}-${phoneNumSegment2}-${phoneNumSegment3}`;
          print(getAuth(), phoneNumber, appVerifier);
          signInWithPhoneNumber(getAuth()).then((confirmationResult) => {
            console.log("confirmation result =", confirmationResult);
            window.confirmationResult = confirmationResult;
          }).catch((error3) => {
            alert(error3);
            console.log("error =", error3);
            window.recaptchaVerifier.render().then(function(widgetId) {
              grecaptcha.reset(widgetId);
            });
          });
        }
      }
      $$result.css.add(css);
      isQuestionMode = titleValue.charAt(titleValue.length - 1) === "?";
      {
        if (isQuestionMode) {
          setTimeout(() => {
          }, 5e3);
        }
      }
      {
        if (currentTime.toFixed(0) === "0") {
          console.log("end of timer, currentTime =", currentTime);
          clearInterval(timer);
        }
      }
      {
        if (phoneNumSegment1.length === 3) {
          document.getElementById("phone-input-2").focus();
        }
      }
      {
        if (phoneNumSegment2.length === 3) {
          document.getElementById("phone-input-3").focus();
        }
      }
      {
        if (phoneNumSegment3.length === 4) {
          signInWithPhone();
        }
      }
      $$unsubscribe_user();
      return `${Object.keys($user).length === 0 ? `<section style="${"height: 100vh; border-bottom: 1px solid #eee;"}"><div style="${"height: 84vh; display: flex; justify-content: center; align-items: center;"}"><div style="${"padding-bottom: 90px;"}"><div style="${"display: flex; align-items: center; justify-content: center; height: 120px;"}"><img src="${"logo.png"}" width="${"120"}" height="${"108"}" style="${"margin-left: 0px;"}">
					<h1 id="${"logo"}" style="${"font-size: 6.5rem; color: rgb(0 0 0); padding-bottom: 16px; padding-left: 10px;"}" class="${"svelte-ufphu6"}">explain.mit.edu
					</h1></div>

				<div style="${"display: flex; justify-content: center;"}"><b style="${"color: grey; white-space: nowrap;"}" class="${"copied-from-koa svelte-ufphu6"}">Open-learning communities with lots of visual explanations</b></div>


				<div style="${"display: flex; justify-content: center; align-items: center; margin-top: 20px;"}"><div class="${"copied-from-koa-2 svelte-ufphu6"}" style="${"margin-right: 20px;"}">Who are you?</div>
					<div>${validate_component(Button_1, "Button").$$render($$result, { variant: "raised", color: "purple" }, {}, {
        default: () => `Student
						`
      })}
	
						${validate_component(Button_1, "Button").$$render($$result, {
        variant: "raised",
        color: "orange",
        style: "margin-left: 6px"
      }, {}, {
        default: () => `Teacher
						`
      })}</div>

					${validate_component(Button_1, "Button").$$render($$result, {
        variant: "raised",
        color: "orange",
        style: "margin-left: 6px"
      }, {}, {
        default: () => `Self-learner
					`
      })}	

					
					${validate_component(Button_1, "Button").$$render($$result, {
        variant: "raised",
        color: "orange",
        style: "margin-left: 6px"
      }, {}, {
        default: () => `Just curious
					`
      })}</div></div></div></section>

	` : ``}

	












`;
    });
  }
});

// .svelte-kit/output/server/chunks/RenderlessFetchStrokes-a2b1dd16.js
async function deleteAllStrokesFromDb({ boardPath, strokesArray }) {
  return new Promise(async (resolve2) => {
    const batchDeleteRequests = [];
    let currentBatch = Sh(Oa());
    let currentBatchSize = 0;
    for (const stroke of strokesArray) {
      if (currentBatchSize >= 500) {
        batchDeleteRequests.push(currentBatch.commit());
        currentBatch = Sh(Oa());
        currentBatchSize = 0;
      }
      const ref = va(Oa(), `${boardPath}/strokes/${stroke.id}`);
      currentBatch.delete(ref);
      currentBatchSize += 1;
    }
    batchDeleteRequests.push(currentBatch.commit());
    await Promise.all(batchDeleteRequests);
    strokesArray = [];
    resolve2();
  });
}
var css2, DoodleVideo, RenderlessListenToBoard, RenderlessFetchStrokes;
var init_RenderlessFetchStrokes_a2b1dd16 = __esm({
  ".svelte-kit/output/server/chunks/RenderlessFetchStrokes-a2b1dd16.js"() {
    init_shims();
    init_app_dafecf1b();
    init_store_85fd0788();
    init_DoodleVideo_svelte_svelte_type_style_lang_1ac60caf();
    css2 = {
      code: ".overlay-center.svelte-12w6n3q{position:absolute;width:20px;height:20px;top:0;left:0;right:0;bottom:0;margin:auto;color:white\r\n}",
      map: null
    };
    DoodleVideo = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $canvasHeight, $$unsubscribe_canvasHeight;
      let $canvasWidth, $$unsubscribe_canvasWidth;
      $$unsubscribe_canvasHeight = subscribe(canvasHeight, (value) => $canvasHeight = value);
      $$unsubscribe_canvasWidth = subscribe(canvasWidth, (value) => $canvasWidth = value);
      let { strokesArray } = $$props;
      let { audioDownloadURL } = $$props;
      let { backgroundImageDownloadURL } = $$props;
      let canvas;
      let bgCanvas;
      let AudioPlayer;
      onDestroy(() => {
      });
      if ($$props.strokesArray === void 0 && $$bindings.strokesArray && strokesArray !== void 0)
        $$bindings.strokesArray(strokesArray);
      if ($$props.audioDownloadURL === void 0 && $$bindings.audioDownloadURL && audioDownloadURL !== void 0)
        $$bindings.audioDownloadURL(audioDownloadURL);
      if ($$props.backgroundImageDownloadURL === void 0 && $$bindings.backgroundImageDownloadURL && backgroundImageDownloadURL !== void 0)
        $$bindings.backgroundImageDownloadURL(backgroundImageDownloadURL);
      $$result.css.add(css2);
      $$unsubscribe_canvasHeight();
      $$unsubscribe_canvasWidth();
      return `
<div style="${"position: absolute; right: 0; left: auto; top: 0; bottom: auto; display: flex; padding-top: 4px; padding-bottom: 4px; z-index: 5"}">${slots.default ? slots.default({}) : `

  `}</div>


${strokesArray ? `<span class="${"material-icons overlay-center svelte-12w6n3q"}" style="${"color: white; font-size: 6rem; width: 120px; height: 120px; z-index: 5"}">play_circle
  </span>` : ``}


<div style="${"position: relative"}"><canvas${add_attribute("style", `
      position: absolute; 
      z-index: 1; 
      margin-top: 0; 
      margin-left: 0; 
      width: ${$canvasWidth}px; 
      height: ${$canvasHeight}px; 
      background-color: transparent`, 0)}${add_attribute("this", canvas, 0)}></canvas>

  <canvas${add_attribute("style", `
      position: absolute;
      z-index: 0;
      top: 0;
      left: 0;
      display: block;
      width: ${$canvasWidth}px; 
      height: ${$canvasHeight}px;
      background-color: rgb(46, 49, 49);`, 0)}${add_attribute("this", bgCanvas, 0)}></canvas></div>

<div><audio${add_attribute("src", audioDownloadURL, 0)} controls${add_attribute("style", `width: ${$canvasWidth}px; height: 40px; position: absolute; bottom: 0; top: auto;`, 0)}${add_attribute("this", AudioPlayer, 0)}></audio>
</div>`;
    });
    RenderlessListenToBoard = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { dbPath } = $$props;
      let boardDoc;
      const boardRef = va(Oa(), dbPath);
      yh(boardRef, (snapshot) => {
        boardDoc = { id: snapshot.id, ...snapshot.data() };
      });
      if ($$props.dbPath === void 0 && $$bindings.dbPath && dbPath !== void 0)
        $$bindings.dbPath(dbPath);
      return `${slots.default ? slots.default({ boardDoc }) : `

`}`;
    });
    RenderlessFetchStrokes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { dbPath } = $$props;
      let { autoFetchStrokes = false } = $$props;
      let strokesArray;
      const strokesRef = ba(Oa(), `${dbPath}/strokes`);
      const strokesQuery = Mu(strokesRef, qu("timestamp"));
      if (autoFetchStrokes) {
        fetchStrokes();
      }
      async function fetchStrokes() {
        const strokesSnapshot = await lh(strokesQuery);
        const temp = [];
        for (const doc of strokesSnapshot.docs) {
          temp.push({ id: doc.id, ...doc.data() });
        }
        strokesArray = temp;
      }
      if ($$props.dbPath === void 0 && $$bindings.dbPath && dbPath !== void 0)
        $$bindings.dbPath(dbPath);
      if ($$props.autoFetchStrokes === void 0 && $$bindings.autoFetchStrokes && autoFetchStrokes !== void 0)
        $$bindings.autoFetchStrokes(autoFetchStrokes);
      return `${slots.default ? slots.default({
        fetchStrokes,
        strokesArray,
        deleteAllStrokesFromDb: () => deleteAllStrokesFromDb({ boardPath: dbPath, strokesArray })
      }) : `

`}`;
    });
  }
});

// .svelte-kit/output/server/chunks/explore-f3de6569.js
var explore_f3de6569_exports = {};
__export(explore_f3de6569_exports, {
  default: () => Explore
});
var import_node_fetch3, import_cookie4, css3, Explore;
var init_explore_f3de6569 = __esm({
  ".svelte-kit/output/server/chunks/explore-f3de6569.js"() {
    init_shims();
    init_app_dafecf1b();
    init_index_c327074d_b42dfde1();
    init_store_85fd0788();
    import_node_fetch3 = __toModule(require_lib2());
    init_DoodleVideo_svelte_svelte_type_style_lang_1ac60caf();
    init_SelectionGroupIcon_51f30423();
    init_canvas_fb765f32();
    init_RenderlessFetchStrokes_a2b1dd16();
    import_cookie4 = __toModule(require_cookie());
    init_dist();
    css3 = {
      code: ".room-title input{font-size:2rem}.question input{color:rgb(19, 145, 230) !important\r\n}.content.svelte-ejjzis{margin:0 auto;text-align:left}",
      map: null
    };
    Explore = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let isQuestionMode;
      let $user, $$unsubscribe_user;
      let $canvasWidth, $$unsubscribe_canvasWidth;
      let $canvasHeight, $$unsubscribe_canvasHeight;
      $$unsubscribe_user = subscribe(user, (value) => $user = value);
      $$unsubscribe_canvasWidth = subscribe(canvasWidth, (value) => $canvasWidth = value);
      $$unsubscribe_canvasHeight = subscribe(canvasHeight, (value) => $canvasHeight = value);
      let currentTime = 10;
      let titleValue = "Welcome!";
      let countryCode = "+1";
      let phoneNumSegment12 = "";
      let phoneNumSegment22 = "";
      let phoneNumSegment32 = "";
      let phoneConfirmationResult;
      let phoneConfirmCode = "";
      let appVerifier;
      const print = console.log;
      let timer;
      function adjustContentDimensions() {
        const { width, height } = calculateCanvasDimensions2();
        canvasWidth.set(width);
        canvasHeight.set(height);
      }
      onDestroy(() => {
        window.removeEventListener("resize", adjustContentDimensions);
      });
      function signInWithPhone() {
        if (!window.recaptchaVerifier) {
          window.recaptchaVerifier = new RecaptchaVerifier("sign-in-button", {
            "size": "invisible",
            "callback": (response) => {
              console.log("reCAPTCHA solved =", response);
            }
          }, getAuth());
          appVerifier = window.recaptchaVerifier;
        }
        onSignInSubmit();
        function onSignInSubmit() {
          const phoneNumber = `${countryCode} ${phoneNumSegment12}-${phoneNumSegment22}-${phoneNumSegment32}`;
          print(getAuth(), phoneNumber, appVerifier);
          signInWithPhoneNumber(getAuth()).then((confirmationResult) => {
            console.log("confirmation result =", confirmationResult);
            phoneConfirmationResult = confirmationResult;
            window.confirmationResult = confirmationResult;
          }).catch((error3) => {
            alert(error3);
            console.log("error =", error3);
            window.recaptchaVerifier.render().then(function(widgetId) {
              grecaptcha.reset(widgetId);
            });
          });
        }
      }
      $$result.css.add(css3);
      isQuestionMode = titleValue.charAt(titleValue.length - 1) === "?";
      {
        if (isQuestionMode) {
          setTimeout(() => {
          }, 5e3);
        }
      }
      {
        if (currentTime.toFixed(0) === "0") {
          clearInterval(timer);
        }
      }
      {
        if (phoneNumSegment12.length === 3) {
          document.getElementById("phone-input-2").focus();
        }
      }
      {
        if (phoneNumSegment22.length === 3) {
          document.getElementById("phone-input-3").focus();
        }
      }
      {
        if (phoneNumSegment32.length === 4) {
          signInWithPhone();
        }
      }
      $$unsubscribe_user();
      $$unsubscribe_canvasWidth();
      $$unsubscribe_canvasHeight();
      return `${Object.keys($user).length === 0 ? `<section style="${"background: #FDFDF8; height: 100%; padding-top: 100px; padding-bottom: 100px; border-bottom: 1px solid #eee;"}"><div class="${"content svelte-ejjzis"}" style="${"width: " + escape($canvasWidth) + "px"}"><h1 style="${"margin-top: 0; font: 35px/1.5 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">It&#39;s hard to understand properly with text messages
			</h1>

			<p style="${"font-size: 1.2rem; color: #33333d; font-weight: 300; font-family: 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Communities built around Discord, Piazza, Facebook etc. have a fundamental flaw - you can&#39;t draw on blackboards easily, so you need to explain everything in words. 
        It&#39;s almost a waste of time to learn anything complex without visuals. 
				<br>
				<br>     
        Times are changing: iPads are becoming more affordable, web apps becoming more powerful.
			</p>
			<br></div></section>

	<section style="${"height: " + escape($canvasHeight + 260) + "px; padding-top: 100px; padding-bottom: 100px; border-bottom: 1px solid #eee;"}"><div class="${"content svelte-ejjzis"}" style="${"width: " + escape($canvasWidth) + "px"}"><h1 style="${"margin-top: 0; font: 35px/1.5 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Blackboard-centric servers</h1>
			<p style="${"font-size: 1.2rem; color: #33333d; font-weight: 300; font-family: 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Explain = Discord (voice chat) + KhanAcademy (blackboards). Here, blackboard videos upload near-instantly, so explanations are <b style="${"color: #b22ab2;"}">easily re-usable.</b>
				<br>
				<br>
				Here&#39;s an example video that was recorded on this website: 
			</p></div>

		<div${add_attribute("style", `position: relative; width: ${$canvasWidth}px; height: ${$canvasHeight + 60}px; margin: auto;`, 0)} id="${"caleb-video-section"}">${validate_component(RenderlessListenToBoard, "RenderlessListenToBoard").$$render($$result, {
        dbPath: "/classes/AsUl1VWQ7zzxZsD5epL7/blackboards/AsUl1VWQ7zzxZsD5epL7"
      }, {}, {
        default: ({ boardDoc }) => `${validate_component(RenderlessFetchStrokes, "RenderlessFetchStrokes").$$render($$result, {
          dbPath: "/classes/AsUl1VWQ7zzxZsD5epL7/blackboards/AsUl1VWQ7zzxZsD5epL7",
          autoFetchStrokes: true
        }, {}, {
          default: ({ strokesArray }) => `${boardDoc ? `${validate_component(DoodleVideo, "DoodleVideo").$$render($$result, {
            strokesArray,
            audioDownloadURL: boardDoc.audioDownloadURL,
            backgroundImageDownloadURL: boardDoc.backgroundImageDownloadURL
          }, {}, {})}` : ``}`
        })}`
      })}</div></section>

	<section style="${"height: 100%; padding-top: 150px; padding-bottom: 150px; border-bottom: 1px solid #eee; background: #FDFDF8;"}"><div class="${"content svelte-ejjzis"}" style="${"width: " + escape($canvasWidth) + "px"}"><h1 style="${"margin-top: 0; font: 35px/1.5 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Get started
			</h1>

			<p style="${"font-size: 1.2rem; color: #33333d; font-weight: 300; font-family: 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Just sign up for a password-less account to join and create servers
			</p></div>

		<div id="${"sign-up-section"}" style="${"height: 100px"}">${!phoneConfirmationResult ? `<div style="${"display: flex; justify-content: center; align-items: center; margin-top: 24px;"}"><input type="${"tel"}" id="${"phone-country-code"}" minlength="${"2"}" maxlength="${"4"}" placeholder="${"+1"}" style="${"margin-left: 15px; width: 72px; height: 40px; font-size: 2rem; margin-right: 10px"}"${add_attribute("value", countryCode, 0)}>

					<input type="${"tel"}" id="${"phone-input-1"}" minlength="${"3"}" maxlength="${"3"}" placeholder="${"503"}" style="${"margin-left: 15px; width: 54px; height: 40px; font-size: 2rem; margin-right: 10px"}"${add_attribute("value", phoneNumSegment12, 0)}>

					<input type="${"tel"}" id="${"phone-input-2"}" minlength="${"3"}" maxlength="${"3"}" placeholder="${"250"}" style="${"width: 54px; height: 40px; font-size: 2rem; margin-right: 10px"}"${add_attribute("value", phoneNumSegment22, 0)}>

					<input type="${"tel"}" id="${"phone-input-3"}" minlength="${"4"}" maxlength="${"4"}" placeholder="${"3868"}" style="${"width: 76px; height: 40px; font-size: 2rem; margin-right: 10px"}"${add_attribute("value", phoneNumSegment32, 0)}>
					${validate_component(Button_1, "Button").$$render($$result, {
        id: "sign-in-button",
        style: "color: rgb(116 28 183); margin-bottom: 2px"
      }, {}, {
        default: () => `Sign Up
					`
      })}</div>` : `<div style="${"display: flex; justify-content: center; align-items: center; margin-top: 24px"}"><input minlength="${"6"}" maxlength="${"6"}" placeholder="${"123456"}" style="${"width: 111px; font-size: 2rem; margin-right: 10px"}"${add_attribute("value", phoneConfirmCode, 0)}>
					${validate_component(Button_1, "Button").$$render($$result, {
        style: "color: rgb(116 28 183); margin-bottom: 2px;"
      }, {}, { default: () => `Confirm code` })}</div>`}</div></section>` : ``}














`;
    });
  }
});

// .svelte-kit/output/server/chunks/learn-8f566fe1.js
var learn_8f566fe1_exports = {};
__export(learn_8f566fe1_exports, {
  default: () => Learn
});
var import_node_fetch4, import_cookie5, css4, Learn;
var init_learn_8f566fe1 = __esm({
  ".svelte-kit/output/server/chunks/learn-8f566fe1.js"() {
    init_shims();
    init_app_dafecf1b();
    init_index_c327074d_b42dfde1();
    init_store_85fd0788();
    import_node_fetch4 = __toModule(require_lib2());
    init_DoodleVideo_svelte_svelte_type_style_lang_1ac60caf();
    init_SelectionGroupIcon_51f30423();
    init_canvas_fb765f32();
    init_RenderlessFetchStrokes_a2b1dd16();
    import_cookie5 = __toModule(require_cookie());
    init_dist();
    css4 = {
      code: ".room-title input{font-size:2rem}.question input{color:rgb(19, 145, 230) !important\r\n}.content.svelte-ejjzis{margin:0 auto;text-align:left}li.svelte-ejjzis{margin-bottom:2px}",
      map: null
    };
    Learn = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let isQuestionMode;
      let $user, $$unsubscribe_user;
      let $canvasWidth, $$unsubscribe_canvasWidth;
      let $canvasHeight, $$unsubscribe_canvasHeight;
      $$unsubscribe_user = subscribe(user, (value) => $user = value);
      $$unsubscribe_canvasWidth = subscribe(canvasWidth, (value) => $canvasWidth = value);
      $$unsubscribe_canvasHeight = subscribe(canvasHeight, (value) => $canvasHeight = value);
      let currentTime = 10;
      let titleValue = "Welcome!";
      let phoneNumSegment12 = "";
      let phoneNumSegment22 = "";
      let phoneNumSegment32 = "";
      let phoneConfirmationResult;
      let phoneConfirmCode = "";
      let appVerifier;
      const print = console.log;
      let timer;
      function adjustContentDimensions() {
        const { width, height } = calculateCanvasDimensions2();
        canvasWidth.set(width);
        canvasHeight.set(height);
      }
      onDestroy(() => {
        window.removeEventListener("resize", adjustContentDimensions);
      });
      function signInWithPhone() {
        if (!window.recaptchaVerifier) {
          window.recaptchaVerifier = new RecaptchaVerifier("sign-in-button", {
            "size": "invisible",
            "callback": (response) => {
              console.log("reCAPTCHA solved =", response);
            }
          }, getAuth());
          appVerifier = window.recaptchaVerifier;
        }
        onSignInSubmit();
        function onSignInSubmit() {
          const phoneNumber = `+1 ${phoneNumSegment12}-${phoneNumSegment22}-${phoneNumSegment32}`;
          print(getAuth(), phoneNumber, appVerifier);
          signInWithPhoneNumber(getAuth()).then((confirmationResult) => {
            console.log("confirmation result =", confirmationResult);
            phoneConfirmationResult = confirmationResult;
            window.confirmationResult = confirmationResult;
          }).catch((error3) => {
            alert(error3);
            console.log("error =", error3);
            window.recaptchaVerifier.render().then(function(widgetId) {
              grecaptcha.reset(widgetId);
            });
          });
        }
      }
      $$result.css.add(css4);
      isQuestionMode = titleValue.charAt(titleValue.length - 1) === "?";
      {
        if (isQuestionMode) {
          setTimeout(() => {
          }, 5e3);
        }
      }
      {
        if (currentTime.toFixed(0) === "0") {
          console.log("end of timer, currentTime =", currentTime);
          clearInterval(timer);
        }
      }
      {
        if (phoneNumSegment12.length === 3) {
          document.getElementById("phone-input-2").focus();
        }
      }
      {
        if (phoneNumSegment22.length === 3) {
          document.getElementById("phone-input-3").focus();
        }
      }
      {
        if (phoneNumSegment32.length === 4) {
          signInWithPhone();
        }
      }
      $$unsubscribe_user();
      $$unsubscribe_canvasWidth();
      $$unsubscribe_canvasHeight();
      return `${Object.keys($user).length === 0 ? `<section style="${"background: #FDFDF8; height: 100%; padding-top: 100px; padding-bottom: 100px; border-bottom: 1px solid #eee;"}"><div class="${"content svelte-ejjzis"}" style="${"width: " + escape($canvasWidth) + "px"}"><h1 style="${"margin-top: 0; font: 35px/1.5 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">What we truly fear isn&#39;t failing classes...
			</h1>

			<p style="${"font-size: 1.2rem; color: #33333d; font-weight: 300; font-family: 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">We fear having to go through the day-to-day, waking up with a headache, seeing a grey sky, walking to lecture to a room full of everyone but friends, not understanding anything. 
				<br>
				<br>
				It&#39;s the fatigue and anxiety. It&#39;s the purposelessness. It&#39;s the isolation. 
				<br>
				<br>
				There are many reasons why we can fall behind classes. But the fact we can&#39;t <u>recover</u> is the problem. We especially visit Office Hours, only to wait 30 minutes for 5 minutes of &quot;hints&quot;.
				<br>
				<br>
				When night comes, either we&#39;re so burnt out that we can&#39;t do any work, or we try to sleep knowing that tomorrow will be just as bad. We&#39;re stuck in a vicious cycle of compounding inefficiencies. The suffering isn&#39;t extreme or intense, it&#39;s prolonged and pervasive. 
				<br>
				<br>	
				That&#39;s what keeps us up at night.
			</p>
			<br></div></section>

	<section style="${"height: " + escape(260) + "px; padding-top: 100px; padding-bottom: 100px; border-bottom: 1px solid #eee;"}"><div class="${"content svelte-ejjzis"}" style="${"width: " + escape($canvasWidth) + "px"}"><h1 style="${"margin-top: 0; font: 35px/1.5 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">College can be full of colors</h1>
			<p style="${"font-size: 1.2rem; color: #33333d; font-weight: 300; font-family: 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Imagine if the material was so good that, everything you need to know is clearly explained and re-watchable at your own pace. And suppose anything were to be missing, you can just ask for help efficiently without having to travel to campus, wait till the next Office Hours / for a Piazza response?
				<br>
				<br>
				Then, you can efficiently grasp the fundamentals and get up to speed.
			</p></div></section>

	<section style="${"height: " + escape($canvasHeight + 260) + "px; padding-top: 100px; padding-bottom: 100px; border-bottom: 1px solid #eee;"}"><div class="${"content svelte-ejjzis"}" style="${"width: " + escape($canvasWidth) + "px"}"><h1 style="${"margin-top: 0; font: 35px/1.5 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">How everything works</h1>
			<p style="${"font-size: 1.2rem; color: #33333d; font-weight: 300; font-family: 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Explain = Discord (voice chat) + KhanAcademy (blackboards). Here, blackboard videos upload near-instantly, so explanations are <b style="${"color: #b22ab2;"}">easily re-usable.</b>

				Explain changes 3 things: 
					<br>
					- Abundance of visual explanations: making and managing videos has always been inconvenient, but on this web app you just press one button...so teachers can do it much more
					<br>
					- Convenient way to get help: instead of waiting till Wednesday 5-7 pm, then having to travelling across campus, you can receive real-time help from your room, anytime.
					Traditional remote help has always been ineffective - it suffers the worst of both worlds - the limited availability and wait-times of Office Hours, and the lack of easy blackboard integration.
					Explain removes both.
					<br>
				  - Strong incentives: TAs are rewarded for actual impact; a TA who helped 100 people in a way 10x more helpful should get paid 1000x more than other TAs
				<br>
				<br>
				Here&#39;s an example video that was recorded on this website: 
			</p></div>

		<div${add_attribute("style", `position: relative; width: ${$canvasWidth}px; height: ${$canvasHeight + 60}px; margin: auto;`, 0)} id="${"caleb-video-section"}">${validate_component(RenderlessListenToBoard, "RenderlessListenToBoard").$$render($$result, {
        dbPath: "/classes/AsUl1VWQ7zzxZsD5epL7/blackboards/AsUl1VWQ7zzxZsD5epL7"
      }, {}, {
        default: ({ boardDoc }) => `${validate_component(RenderlessFetchStrokes, "RenderlessFetchStrokes").$$render($$result, {
          dbPath: "/classes/AsUl1VWQ7zzxZsD5epL7/blackboards/AsUl1VWQ7zzxZsD5epL7",
          autoFetchStrokes: true
        }, {}, {
          default: ({ strokesArray }) => `${boardDoc ? `${validate_component(DoodleVideo, "DoodleVideo").$$render($$result, {
            strokesArray,
            audioDownloadURL: boardDoc.audioDownloadURL,
            backgroundImageDownloadURL: boardDoc.backgroundImageDownloadURL
          }, {}, {})}` : ``}`
        })}`
      })}</div></section>

	

	<section style="${"height: 100%; padding-top: 150px; padding-bottom: 150px; border-bottom: 1px solid #eee; background: #FDFDF8;"}"><div class="${"content svelte-ejjzis"}" style="${"width: " + escape($canvasWidth) + "px"}"><h1 style="${"margin-top: 0; font: 35px/1.5 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Website preview
			</h1>

			<p style="${"font-size: 1.2rem; color: #33333d; font-weight: 300; font-family: 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">How it works:
				<li class="${"svelte-ejjzis"}">Everyone contributes $20/week to the class server</li>
				<li class="${"svelte-ejjzis"}">Tutor runs the server and helps you personally as you want</li>
				<li class="${"svelte-ejjzis"}">Many fundamental explanations are recorded, so your question benefits other server members, and vice versa.</li></p>

			<iframe style="${"display: block;"}"${add_attribute("width", $canvasWidth, 0)}${add_attribute("height", $canvasHeight, 0)} src="${"https://www.youtube.com/embed/kJSZYFEQ_8I"}" title="${"YouTube video player"}" frameborder="${"0"}" allow="${"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"}" allowfullscreen></iframe></div></section>

	<section style="${"height: 100%; padding-top: 150px; padding-bottom: 150px; border-bottom: 1px solid #eee;"}"><div class="${"content svelte-ejjzis"}" style="${"width: " + escape($canvasWidth) + "px"}"><h1 style="${"margin-top: 0; font: 35px/1.5 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Get started
			</h1>

			<p style="${"font-size: 1.2rem; color: #33333d; font-weight: 300; font-family: 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Any questions, email the organizer eltonlin@mit.edu or text 503 250 3868, I reply quickly
				<br>
				<br>
				<li class="${"svelte-ejjzis"}">Request a class by venmo&#39;ing $20 to elton-lin-2</li>
				<li class="${"svelte-ejjzis"}">I&#39;ll send you a confirmation, create a server and find your tutor within 24 hours</li>
				<li class="${"svelte-ejjzis"}">Refund anytime any reason</li></p></div>

		<div id="${"sign-up-section"}" style="${"height: 100px"}">${!phoneConfirmationResult ? `<div style="${"display: flex; justify-content: center; align-items: center; margin-top: 24px;"}">
					<input type="${"tel"}" id="${"phone-input-1"}" minlength="${"3"}" maxlength="${"3"}" placeholder="${"503"}" style="${"margin-left: 15px; width: 54px; height: 40px; font-size: 2rem; margin-right: 10px"}"${add_attribute("value", phoneNumSegment12, 0)}>

					<input type="${"tel"}" id="${"phone-input-2"}" minlength="${"3"}" maxlength="${"3"}" placeholder="${"250"}" style="${"width: 54px; height: 40px; font-size: 2rem; margin-right: 10px"}"${add_attribute("value", phoneNumSegment22, 0)}>

					<input type="${"tel"}" id="${"phone-input-3"}" minlength="${"4"}" maxlength="${"4"}" placeholder="${"3868"}" style="${"width: 76px; height: 40px; font-size: 2rem; margin-right: 10px"}"${add_attribute("value", phoneNumSegment32, 0)}>
					${validate_component(Button_1, "Button").$$render($$result, {
        id: "sign-in-button",
        style: "color: rgb(116 28 183); margin-bottom: 2px"
      }, {}, {
        default: () => `Sign Up
					`
      })}</div>` : `<div style="${"display: flex; justify-content: center; align-items: center; margin-top: 24px"}"><input minlength="${"6"}" maxlength="${"6"}" placeholder="${"123456"}" style="${"width: 111px; font-size: 2rem; margin-right: 10px"}"${add_attribute("value", phoneConfirmCode, 0)}>
					${validate_component(Button_1, "Button").$$render($$result, {
        style: "color: rgb(116 28 183); margin-bottom: 2px;"
      }, {}, { default: () => `Confirm code` })}</div>`}</div></section>` : ``}












`;
    });
  }
});

// .svelte-kit/output/server/chunks/teach-47c4046f.js
var teach_47c4046f_exports = {};
__export(teach_47c4046f_exports, {
  default: () => Teach
});
var import_node_fetch5, import_cookie6, css5, Teach;
var init_teach_47c4046f = __esm({
  ".svelte-kit/output/server/chunks/teach-47c4046f.js"() {
    init_shims();
    init_app_dafecf1b();
    init_index_c327074d_b42dfde1();
    init_store_85fd0788();
    import_node_fetch5 = __toModule(require_lib2());
    init_DoodleVideo_svelte_svelte_type_style_lang_1ac60caf();
    init_SelectionGroupIcon_51f30423();
    init_canvas_fb765f32();
    init_RenderlessFetchStrokes_a2b1dd16();
    import_cookie6 = __toModule(require_cookie());
    init_dist();
    css5 = {
      code: ".room-title input{font-size:2rem}.question input{color:rgb(19, 145, 230) !important\r\n}.content.svelte-ejjzis{margin:0 auto;text-align:left}li.svelte-ejjzis{margin-bottom:2px}",
      map: null
    };
    Teach = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let isQuestionMode;
      let $user, $$unsubscribe_user;
      let $canvasWidth, $$unsubscribe_canvasWidth;
      let $canvasHeight, $$unsubscribe_canvasHeight;
      $$unsubscribe_user = subscribe(user, (value) => $user = value);
      $$unsubscribe_canvasWidth = subscribe(canvasWidth, (value) => $canvasWidth = value);
      $$unsubscribe_canvasHeight = subscribe(canvasHeight, (value) => $canvasHeight = value);
      let currentTime = 10;
      let titleValue = "Welcome!";
      let phoneNumSegment12 = "";
      let phoneNumSegment22 = "";
      let phoneNumSegment32 = "";
      let phoneConfirmationResult;
      let phoneConfirmCode = "";
      let appVerifier;
      const print = console.log;
      let timer;
      function adjustContentDimensions() {
        const { width, height } = calculateCanvasDimensions2();
        canvasWidth.set(width);
        canvasHeight.set(height);
      }
      onDestroy(() => {
        window.removeEventListener("resize", adjustContentDimensions);
      });
      function signInWithPhone() {
        if (!window.recaptchaVerifier) {
          window.recaptchaVerifier = new RecaptchaVerifier("sign-in-button", {
            "size": "invisible",
            "callback": (response) => {
              console.log("reCAPTCHA solved =", response);
            }
          }, getAuth());
          appVerifier = window.recaptchaVerifier;
        }
        onSignInSubmit();
        function onSignInSubmit() {
          const phoneNumber = `+1 ${phoneNumSegment12}-${phoneNumSegment22}-${phoneNumSegment32}`;
          print(getAuth(), phoneNumber, appVerifier);
          signInWithPhoneNumber(getAuth()).then((confirmationResult) => {
            console.log("confirmation result =", confirmationResult);
            phoneConfirmationResult = confirmationResult;
            window.confirmationResult = confirmationResult;
          }).catch((error3) => {
            alert(error3);
            console.log("error =", error3);
            window.recaptchaVerifier.render().then(function(widgetId) {
              grecaptcha.reset(widgetId);
            });
          });
        }
      }
      $$result.css.add(css5);
      isQuestionMode = titleValue.charAt(titleValue.length - 1) === "?";
      {
        if (isQuestionMode) {
          setTimeout(() => {
          }, 5e3);
        }
      }
      {
        if (currentTime.toFixed(0) === "0") {
          console.log("end of timer, currentTime =", currentTime);
          clearInterval(timer);
        }
      }
      {
        if (phoneNumSegment12.length === 3) {
          document.getElementById("phone-input-2").focus();
        }
      }
      {
        if (phoneNumSegment22.length === 3) {
          document.getElementById("phone-input-3").focus();
        }
      }
      {
        if (phoneNumSegment32.length === 4) {
          signInWithPhone();
        }
      }
      $$unsubscribe_user();
      $$unsubscribe_canvasWidth();
      $$unsubscribe_canvasHeight();
      return `${Object.keys($user).length === 0 ? `<section style="${"background: #FDFDF8; height: 100%; padding-top: 100px; padding-bottom: 100px; border-bottom: 1px solid #eee;"}"><div class="${"content svelte-ejjzis"}" style="${"width: " + escape($canvasWidth) + "px"}"><h1 style="${"margin-top: 0; font: 35px/1.5 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Teaching has long hours and mediocre pay
			</h1>

			<p style="${"font-size: 1.2rem; color: #33333d; font-weight: 300; font-family: 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Students want more Office Hours, so now the class has 10 Office Hours throughtout the week. The queue is always 30-people, so you stay there for extra-long to help everyone.
				Oh by the way, you need to attend staff meetings, create pset problems, manage Piazza and email, etc...you have to fight to find time for research and the classes you&#39;re taking yourself. 
				<br>
				<br>
				Too many hours, too low pay, too many responsibilities outside of direct teaching. 
			</p>
			<br></div></section>

	<section style="${"height: " + escape(260) + "px; padding-top: 100px; padding-bottom: 100px; border-bottom: 1px solid #eee;"}"><div class="${"content svelte-ejjzis"}" style="${"width: " + escape($canvasWidth) + "px"}"><h1 style="${"margin-top: 0; font: 35px/1.5 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">How about high pay, short hours?</h1>
			<p style="${"font-size: 1.2rem; color: #33333d; font-weight: 300; font-family: 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Suppose you can make a great-living out of teaching, and it&#39;s no longer about hours spent, but instead effectiveness. So if you do a great job in 10 minutes, you&#39;re done. And you can get paid at the ball-park of $100/hour, without having to 
				handle class logistics etc.

				<br>
				<br></p></div></section>

	<section style="${"height: " + escape($canvasHeight + 800) + "px; padding-top: 100px; padding-bottom: 100px; border-bottom: 1px solid #eee;"}"><div class="${"content svelte-ejjzis"}" style="${"width: " + escape($canvasWidth) + "px"}"><h1 style="${"margin-top: 0; font: 35px/1.5 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">How teaching on Explain works</h1>
			<p style="${"font-size: 1.2rem; color: #33333d; font-weight: 300; font-family: 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Sal Khan&#39;s KhanAcademy videos, or 3Blue1Brown&#39;s videos...etc. have benefited millions of people. If you use recorded explanations whenever appropriate, it enables you to teach efficiently. 
				Explain is designed around the concept of, re-use explanations and of fundamental concepts and canonical problems whenever it is wise to do so, and then make up everything else with individual help.
				
			<br>
			<br>
				Recording explanations is painful. Recording videos on the internet has the technological barrier of heavy files, convoluted workflows and long upload times. But actually it&#39;s unrewarding - you don&#39;t have a live audience. Think what proportion of smart people you know have Youtube channels. 
				Recording lectures and recitations live are also painful - it&#39;s all the inconveniences previously mentioned, AND needing a camera crew. 
				<br>
			<br>
				Explain makes it rewarding and efficient to re-use explanations. How it works is, you decide to record your <b>live</b> explanations to students who asked you a question. Answering a question live to someone who wants your help is much more rewarding than recording an arbitrary video in isolation and not knowing if people will find it useful. 	
				Second, videos here are <b>light</b>. A 10GB video on YouTube will be around 100MB here - which means near-instant upload. That&#39;s because the website is optimized for blackboard videos, and blackboard videos can be crazy-optimized vs arbitrary general videos. 
				You can literally one-click upload explanations, and move them, edit them, like you would with text. It&#39;s blackboard-as-a-first-class-citizen experience.
			<br>
			<br>
				In summary, Explain = Discord (voice chat) + KhanAcademy (blackboards). Here, blackboard videos upload near-instantly, so explanations are <b style="${"color: #b22ab2;"}">easily re-usable.</b>
				<br>
				<br>
				Here&#39;s an example video that was recorded on this website: 
			</p></div>

		<div${add_attribute("style", `position: relative; width: ${$canvasWidth}px; height: ${$canvasHeight + 60}px; margin: auto;`, 0)} id="${"caleb-video-section"}">${validate_component(RenderlessListenToBoard, "RenderlessListenToBoard").$$render($$result, {
        dbPath: "/classes/AsUl1VWQ7zzxZsD5epL7/blackboards/AsUl1VWQ7zzxZsD5epL7"
      }, {}, {
        default: ({ boardDoc }) => `${validate_component(RenderlessFetchStrokes, "RenderlessFetchStrokes").$$render($$result, {
          dbPath: "/classes/AsUl1VWQ7zzxZsD5epL7/blackboards/AsUl1VWQ7zzxZsD5epL7",
          autoFetchStrokes: true
        }, {}, {
          default: ({ strokesArray }) => `${boardDoc ? `${validate_component(DoodleVideo, "DoodleVideo").$$render($$result, {
            strokesArray,
            audioDownloadURL: boardDoc.audioDownloadURL,
            backgroundImageDownloadURL: boardDoc.backgroundImageDownloadURL
          }, {}, {})}` : ``}`
        })}`
      })}</div></section>

	<section style="${"height: 100%; padding-top: 150px; padding-bottom: 150px; border-bottom: 1px solid #eee; background: #FDFDF8;"}"><div class="${"content svelte-ejjzis"}" style="${"width: " + escape($canvasWidth) + "px"}"><h1 style="${"margin-top: 0; font: 35px/1.5 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Get started
			</h1>

			<p style="${"font-size: 1.2rem; color: #33333d; font-weight: 300; font-family: 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">You teach a group of students on a Discord-like server. Every student contributes $20/week for you to help them.
				<br>
				<br>

				How it works:
				<li class="${"svelte-ejjzis"}">You teach a group of students on a Discord-like server</li>
				<li class="${"svelte-ejjzis"}">Students will request real-time help from you via voice chat and blackboard</li>
				<li class="${"svelte-ejjzis"}">Many fundamental explanations are recorded, so your visual explanations build up over time for everyone to reference</li>
				<li class="${"svelte-ejjzis"}">Each student pays $20/week, and you receive $18n/week. A 20-student server means $360/week, requiring around 5 hours commitment</li></p>

			<iframe style="${"display: block;"}"${add_attribute("width", $canvasWidth, 0)}${add_attribute("height", $canvasHeight, 0)} src="${"https://www.youtube.com/embed/kJSZYFEQ_8I"}" title="${"YouTube video player"}" frameborder="${"0"}" allow="${"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"}" allowfullscreen></iframe></div></section>

	<section style="${"height: 100%; padding-top: 150px; padding-bottom: 150px; border-bottom: 1px solid #eee;"}"><div class="${"content svelte-ejjzis"}" style="${"width: " + escape($canvasWidth) + "px"}"><h1 style="${"margin-top: 0; font: 35px/1.5 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">How to get started
			</h1>

			<p style="${"font-size: 1.2rem; color: #33333d; font-weight: 300; font-family: 'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif"}">Any questions, email the organizer eltonlin@mit.edu or text 503 250 3868, I reply quickly
			</p></div>

		<div id="${"sign-up-section"}" style="${"height: 100px"}">${!phoneConfirmationResult ? `<div style="${"display: flex; justify-content: center; align-items: center; margin-top: 24px;"}">
					<input type="${"tel"}" id="${"phone-input-1"}" minlength="${"3"}" maxlength="${"3"}" placeholder="${"503"}" style="${"margin-left: 15px; width: 54px; height: 40px; font-size: 2rem; margin-right: 10px"}"${add_attribute("value", phoneNumSegment12, 0)}>

					<input type="${"tel"}" id="${"phone-input-2"}" minlength="${"3"}" maxlength="${"3"}" placeholder="${"250"}" style="${"width: 54px; height: 40px; font-size: 2rem; margin-right: 10px"}"${add_attribute("value", phoneNumSegment22, 0)}>

					<input type="${"tel"}" id="${"phone-input-3"}" minlength="${"4"}" maxlength="${"4"}" placeholder="${"3868"}" style="${"width: 76px; height: 40px; font-size: 2rem; margin-right: 10px"}"${add_attribute("value", phoneNumSegment32, 0)}>
					${validate_component(Button_1, "Button").$$render($$result, {
        id: "sign-in-button",
        style: "color: rgb(116 28 183); margin-bottom: 2px"
      }, {}, {
        default: () => `Sign Up
					`
      })}</div>` : `<div style="${"display: flex; justify-content: center; align-items: center; margin-top: 24px"}"><input minlength="${"6"}" maxlength="${"6"}" placeholder="${"123456"}" style="${"width: 111px; font-size: 2rem; margin-right: 10px"}"${add_attribute("value", phoneConfirmCode, 0)}>
					${validate_component(Button_1, "Button").$$render($$result, {
        style: "color: rgb(116 28 183); margin-bottom: 2px;"
      }, {}, { default: () => `Confirm code` })}</div>`}</div></section>` : ``}






`;
    });
  }
});

// .svelte-kit/output/server/chunks/index.node.esm-4a860b07.js
function guard(name22) {
  return () => {
    throw new Error(`Cannot call ${name22}(...) on the server`);
  };
}
function exclude(obj, keys) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};
  for (let i = 0; i < names.length; i++) {
    const name22 = names[i];
    const cashIndex = name22.indexOf("$");
    if (cashIndex !== -1 && keys.indexOf(name22.substring(0, cashIndex + 1)) !== -1) {
      continue;
    }
    if (keys.indexOf(name22) !== -1) {
      continue;
    }
    newObj[name22] = obj[name22];
  }
  return newObj;
}
function prefixFilter(obj, prefix) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};
  for (let i = 0; i < names.length; i++) {
    const name22 = names[i];
    if (name22.substring(0, prefix.length) === prefix) {
      newObj[name22.substring(prefix.length)] = obj[name22];
    }
  }
  return newObj;
}
function prependCode(code) {
  return "storage/" + code;
}
function unknown() {
  const message2 = "An unknown error occurred, please check the error payload for server response.";
  return new StorageError("unknown", message2);
}
function retryLimitExceeded() {
  return new StorageError("retry-limit-exceeded", "Max retry time for operation exceeded, please try again.");
}
function canceled() {
  return new StorageError("canceled", "User canceled the upload/download.");
}
function invalidUrl(url2) {
  return new StorageError("invalid-url", "Invalid URL '" + url2 + "'.");
}
function invalidDefaultBucket(bucket) {
  return new StorageError("invalid-default-bucket", "Invalid default bucket '" + bucket + "'.");
}
function invalidArgument(message2) {
  return new StorageError("invalid-argument", message2);
}
function appDeleted() {
  return new StorageError("app-deleted", "The Firebase app was deleted.");
}
function invalidRootOperation(name22) {
  return new StorageError("invalid-root-operation", "The operation '" + name22 + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
}
function start(f, callback, timeout) {
  let waitSeconds = 1;
  let retryTimeoutId = null;
  let globalTimeoutId = null;
  let hitTimeout = false;
  let cancelState = 0;
  function canceled2() {
    return cancelState === 2;
  }
  let triggeredCallback = false;
  function triggerCallback(...args) {
    if (!triggeredCallback) {
      triggeredCallback = true;
      callback.apply(null, args);
    }
  }
  function callWithDelay(millis) {
    retryTimeoutId = setTimeout(() => {
      retryTimeoutId = null;
      f(handler, canceled2());
    }, millis);
  }
  function clearGlobalTimeout() {
    if (globalTimeoutId) {
      clearTimeout(globalTimeoutId);
    }
  }
  function handler(success, ...args) {
    if (triggeredCallback) {
      clearGlobalTimeout();
      return;
    }
    if (success) {
      clearGlobalTimeout();
      triggerCallback.call(null, success, ...args);
      return;
    }
    const mustStop = canceled2() || hitTimeout;
    if (mustStop) {
      clearGlobalTimeout();
      triggerCallback.call(null, success, ...args);
      return;
    }
    if (waitSeconds < 64) {
      waitSeconds *= 2;
    }
    let waitMillis;
    if (cancelState === 1) {
      cancelState = 2;
      waitMillis = 0;
    } else {
      waitMillis = (waitSeconds + Math.random()) * 1e3;
    }
    callWithDelay(waitMillis);
  }
  let stopped = false;
  function stop2(wasTimeout) {
    if (stopped) {
      return;
    }
    stopped = true;
    clearGlobalTimeout();
    if (triggeredCallback) {
      return;
    }
    if (retryTimeoutId !== null) {
      if (!wasTimeout) {
        cancelState = 2;
      }
      clearTimeout(retryTimeoutId);
      callWithDelay(0);
    } else {
      if (!wasTimeout) {
        cancelState = 1;
      }
    }
  }
  callWithDelay(0);
  globalTimeoutId = setTimeout(() => {
    hitTimeout = true;
    stop2(true);
  }, timeout);
  return stop2;
}
function stop(id2) {
  id2(false);
}
function isJustDef(p2) {
  return p2 !== void 0;
}
function validateNumber(argument, minValue, maxValue, value) {
  if (value < minValue) {
    throw invalidArgument(`Invalid value for '${argument}'. Expected ${minValue} or greater.`);
  }
  if (value > maxValue) {
    throw invalidArgument(`Invalid value for '${argument}'. Expected ${maxValue} or less.`);
  }
}
function makeQueryString(params) {
  const encode = encodeURIComponent;
  let queryPart = "?";
  for (const key in params) {
    if (params.hasOwnProperty(key)) {
      const nextPart = encode(key) + "=" + encode(params[key]);
      queryPart = queryPart + nextPart + "&";
    }
  }
  queryPart = queryPart.slice(0, -1);
  return queryPart;
}
function addAuthHeader_(headers2, authToken) {
  if (authToken !== null && authToken.length > 0) {
    headers2["Authorization"] = "Firebase " + authToken;
  }
}
function addVersionHeader_(headers2, firebaseVersion) {
  headers2["X-Firebase-Storage-Version"] = "webjs/" + (firebaseVersion !== null && firebaseVersion !== void 0 ? firebaseVersion : "AppManager");
}
function addGmpidHeader_(headers2, appId) {
  if (appId) {
    headers2["X-Firebase-GMPID"] = appId;
  }
}
function addAppCheckHeader_(headers2, appCheckToken) {
  if (appCheckToken !== null) {
    headers2["X-Firebase-AppCheck"] = appCheckToken;
  }
}
function makeRequest(requestInfo, appId, authToken, appCheckToken, requestFactory, firebaseVersion) {
  const queryPart = makeQueryString(requestInfo.urlParams);
  const url2 = requestInfo.url + queryPart;
  const headers2 = Object.assign({}, requestInfo.headers);
  addGmpidHeader_(headers2, appId);
  addAuthHeader_(headers2, authToken);
  addVersionHeader_(headers2, firebaseVersion);
  addAppCheckHeader_(headers2, appCheckToken);
  return new NetworkRequest(url2, requestInfo.method, headers2, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, requestFactory);
}
function parent(path) {
  if (path.length === 0) {
    return null;
  }
  const index = path.lastIndexOf("/");
  if (index === -1) {
    return "";
  }
  const newPath = path.slice(0, index);
  return newPath;
}
function lastComponent(path) {
  const index = path.lastIndexOf("/", path.length - 2);
  if (index === -1) {
    return path;
  } else {
    return path.slice(index + 1);
  }
}
function extractBucket(host, config) {
  const bucketString = config === null || config === void 0 ? void 0 : config[CONFIG_STORAGE_BUCKET_KEY];
  if (bucketString == null) {
    return null;
  }
  return Location.makeFromBucketSpec(bucketString, host);
}
function factory(container, { instanceIdentifier: url2 }) {
  const app = container.getProvider("app").getImmediate();
  const authProvider = container.getProvider("auth-internal");
  const appCheckProvider = container.getProvider("app-check-internal");
  return new FirebaseStorageImpl(app, authProvider, appCheckProvider, url2, SDK_VERSION);
}
function registerStorage() {
  _registerComponent(new Component(STORAGE_TYPE, factory, "PUBLIC").setMultipleInstances(true));
  registerVersion(name$12, version$12, "node");
  registerVersion(name$12, version$12, "esm2017");
}
function registerFunctions(fetchImpl2, variant) {
  const factory2 = (container, { instanceIdentifier: regionOrCustomDomain }) => {
    const app = container.getProvider("app").getImmediate();
    const authProvider = container.getProvider(AUTH_INTERNAL_NAME);
    const messagingProvider = container.getProvider(MESSAGING_INTERNAL_NAME);
    const appCheckProvider = container.getProvider(APP_CHECK_INTERNAL_NAME);
    return new FunctionsService(app, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain, fetchImpl2);
  };
  _registerComponent(new Component(FUNCTIONS_TYPE, factory2, "PUBLIC").setMultipleInstances(true));
  registerVersion(name4, version4, variant);
  registerVersion(name4, version4, "esm2017");
}
var import_node_fetch6, goto, ContextFragment, FloatingLabel, LineRipple, NotchedOutline, Input, Textarea, Object_13, Textfield, MenuSurface, Menu, Switch, DEFAULT_HOST, CONFIG_STORAGE_BUCKET_KEY, DEFAULT_MAX_OPERATION_RETRY_TIME, DEFAULT_MAX_UPLOAD_RETRY_TIME, StorageError, Location, FailRequest, ErrorCode2, NetworkRequest, RequestEndStatus, Reference, FirebaseStorageImpl, name$12, version$12, STORAGE_TYPE, FUNCTIONS_TYPE, ContextProvider, DEFAULT_REGION, FunctionsService, name4, version4, AUTH_INTERNAL_NAME, APP_CHECK_INTERNAL_NAME, MESSAGING_INTERNAL_NAME;
var init_index_node_esm_4a860b07 = __esm({
  ".svelte-kit/output/server/chunks/index.node.esm-4a860b07.js"() {
    init_shims();
    init_app_dafecf1b();
    init_SelectionGroupIcon_51f30423();
    init_store_85fd0788();
    import_node_fetch6 = __toModule(require_lib2());
    goto = guard("goto");
    ContextFragment = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $storeValue, $$unsubscribe_storeValue;
      let { key } = $$props;
      let { value } = $$props;
      const storeValue = writable(value);
      $$unsubscribe_storeValue = subscribe(storeValue, (value2) => $storeValue = value2);
      setContext(key, storeValue);
      onDestroy(() => {
        storeValue.set(void 0);
      });
      if ($$props.key === void 0 && $$bindings.key && key !== void 0)
        $$bindings.key(key);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      set_store_value(storeValue, $storeValue = value, $storeValue);
      $$unsubscribe_storeValue();
      return `${slots.default ? slots.default({}) : ``}`;
    });
    FloatingLabel = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "use",
        "class",
        "style",
        "for",
        "floatAbove",
        "required",
        "wrapped",
        "shake",
        "float",
        "setRequired",
        "getWidth",
        "getElement"
      ]);
      var _a2;
      forwardEventsBuilder(get_current_component());
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { style = "" } = $$props;
      let { for: forId = void 0 } = $$props;
      let { floatAbove = false } = $$props;
      let { required = false } = $$props;
      let { wrapped = false } = $$props;
      let element;
      let instance2;
      let internalClasses = {};
      let internalStyles = {};
      let inputProps = (_a2 = getContext("SMUI:generic:input:props")) !== null && _a2 !== void 0 ? _a2 : {};
      function shake(shouldShake) {
        instance2.shake(shouldShake);
      }
      function float(shouldFloat) {
        floatAbove = shouldFloat;
      }
      function setRequired(isRequired) {
        required = isRequired;
      }
      function getWidth() {
        return instance2.getWidth();
      }
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.style === void 0 && $$bindings.style && style !== void 0)
        $$bindings.style(style);
      if ($$props.for === void 0 && $$bindings.for && forId !== void 0)
        $$bindings.for(forId);
      if ($$props.floatAbove === void 0 && $$bindings.floatAbove && floatAbove !== void 0)
        $$bindings.floatAbove(floatAbove);
      if ($$props.required === void 0 && $$bindings.required && required !== void 0)
        $$bindings.required(required);
      if ($$props.wrapped === void 0 && $$bindings.wrapped && wrapped !== void 0)
        $$bindings.wrapped(wrapped);
      if ($$props.shake === void 0 && $$bindings.shake && shake !== void 0)
        $$bindings.shake(shake);
      if ($$props.float === void 0 && $$bindings.float && float !== void 0)
        $$bindings.float(float);
      if ($$props.setRequired === void 0 && $$bindings.setRequired && setRequired !== void 0)
        $$bindings.setRequired(setRequired);
      if ($$props.getWidth === void 0 && $$bindings.getWidth && getWidth !== void 0)
        $$bindings.getWidth(getWidth);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `${wrapped ? `<span${spread([
        {
          class: escape_attribute_value(classMap({
            [className]: true,
            "mdc-floating-label": true,
            "mdc-floating-label--float-above": floatAbove,
            "mdc-floating-label--required": required,
            ...internalClasses
          }))
        },
        {
          style: escape_attribute_value(Object.entries(internalStyles).map(([name22, value]) => `${name22}: ${value};`).concat([style]).join(" "))
        },
        escape_object($$restProps)
      ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</span>` : `<label${spread([
        {
          class: escape_attribute_value(classMap({
            [className]: true,
            "mdc-floating-label": true,
            "mdc-floating-label--float-above": floatAbove,
            "mdc-floating-label--required": required,
            ...internalClasses
          }))
        },
        {
          style: escape_attribute_value(Object.entries(internalStyles).map(([name22, value]) => `${name22}: ${value};`).concat([style]).join(" "))
        },
        {
          for: escape_attribute_value(forId || (inputProps ? inputProps.id : void 0))
        },
        escape_object($$restProps)
      ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</label>`}`;
    });
    LineRipple = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "use",
        "class",
        "style",
        "active",
        "activate",
        "deactivate",
        "setRippleCenter",
        "getElement"
      ]);
      forwardEventsBuilder(get_current_component());
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { style = "" } = $$props;
      let { active = false } = $$props;
      let element;
      let instance2;
      let internalClasses = {};
      let internalStyles = {};
      function activate() {
        instance2.activate();
      }
      function deactivate() {
        instance2.deactivate();
      }
      function setRippleCenter(xCoordinate) {
        instance2.setRippleCenter(xCoordinate);
      }
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.style === void 0 && $$bindings.style && style !== void 0)
        $$bindings.style(style);
      if ($$props.active === void 0 && $$bindings.active && active !== void 0)
        $$bindings.active(active);
      if ($$props.activate === void 0 && $$bindings.activate && activate !== void 0)
        $$bindings.activate(activate);
      if ($$props.deactivate === void 0 && $$bindings.deactivate && deactivate !== void 0)
        $$bindings.deactivate(deactivate);
      if ($$props.setRippleCenter === void 0 && $$bindings.setRippleCenter && setRippleCenter !== void 0)
        $$bindings.setRippleCenter(setRippleCenter);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<div${spread([
        {
          class: escape_attribute_value(classMap({
            [className]: true,
            "mdc-line-ripple": true,
            "mdc-line-ripple--active": active,
            ...internalClasses
          }))
        },
        {
          style: escape_attribute_value(Object.entries(internalStyles).map(([name22, value]) => `${name22}: ${value};`).concat([style]).join(" "))
        },
        escape_object($$restProps)
      ])}${add_attribute("this", element, 0)}></div>`;
    });
    NotchedOutline = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "class", "notched", "noLabel", "notch", "closeNotch", "getElement"]);
      forwardEventsBuilder(get_current_component());
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { notched = false } = $$props;
      let { noLabel = false } = $$props;
      let element;
      let instance2;
      let internalClasses = {};
      let notchStyles = {};
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          internalClasses[className2] = false;
        }
      }
      function notch(notchWidth) {
        instance2.notch(notchWidth);
      }
      function closeNotch() {
        instance2.closeNotch();
      }
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.notched === void 0 && $$bindings.notched && notched !== void 0)
        $$bindings.notched(notched);
      if ($$props.noLabel === void 0 && $$bindings.noLabel && noLabel !== void 0)
        $$bindings.noLabel(noLabel);
      if ($$props.notch === void 0 && $$bindings.notch && notch !== void 0)
        $$bindings.notch(notch);
      if ($$props.closeNotch === void 0 && $$bindings.closeNotch && closeNotch !== void 0)
        $$bindings.closeNotch(closeNotch);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      {
        {
          removeClass("mdc-notched-outline--upgraded");
        }
      }
      return `<div${spread([
        {
          class: escape_attribute_value(classMap({
            [className]: true,
            "mdc-notched-outline": true,
            "mdc-notched-outline--notched": notched,
            "mdc-notched-outline--no-label": noLabel,
            ...internalClasses
          }))
        },
        escape_object($$restProps)
      ])}${add_attribute("this", element, 0)}><div class="${"mdc-notched-outline__leading"}"></div>
  ${!noLabel ? `<div class="${"mdc-notched-outline__notch"}"${add_attribute("style", Object.entries(notchStyles).map(([name22, value]) => `${name22}: ${value};`).join(" "), 0)}>${slots.default ? slots.default({}) : ``}</div>` : ``}
  <div class="${"mdc-notched-outline__trailing"}"></div>
</div>`;
    });
    Input = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "use",
        "class",
        "type",
        "placeholder",
        "value",
        "files",
        "dirty",
        "invalid",
        "updateInvalid",
        "emptyValueNull",
        "emptyValueUndefined",
        "getAttr",
        "addAttr",
        "removeAttr",
        "focus",
        "blur",
        "getElement"
      ]);
      forwardEventsBuilder(get_current_component());
      let uninitializedValue = () => {
      };
      function isUninitializedValue(value2) {
        return value2 === uninitializedValue;
      }
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { type = "text" } = $$props;
      let { placeholder = " " } = $$props;
      let { value = uninitializedValue } = $$props;
      const valueUninitialized = isUninitializedValue(value);
      if (valueUninitialized) {
        value = "";
      }
      let { files = null } = $$props;
      let { dirty = false } = $$props;
      let { invalid = false } = $$props;
      let { updateInvalid = true } = $$props;
      let { emptyValueNull = value === null } = $$props;
      if (valueUninitialized && emptyValueNull) {
        value = null;
      }
      let { emptyValueUndefined = value === void 0 } = $$props;
      if (valueUninitialized && emptyValueUndefined) {
        value = void 0;
      }
      let element;
      let internalAttrs = {};
      let valueProp = {};
      function getAttr(name22) {
        var _a2;
        return name22 in internalAttrs ? (_a2 = internalAttrs[name22]) !== null && _a2 !== void 0 ? _a2 : null : getElement().getAttribute(name22);
      }
      function addAttr(name22, value2) {
        if (internalAttrs[name22] !== value2) {
          internalAttrs[name22] = value2;
        }
      }
      function removeAttr(name22) {
        if (!(name22 in internalAttrs) || internalAttrs[name22] != null) {
          internalAttrs[name22] = void 0;
        }
      }
      function focus() {
        getElement().focus();
      }
      function blur() {
        getElement().blur();
      }
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.type === void 0 && $$bindings.type && type !== void 0)
        $$bindings.type(type);
      if ($$props.placeholder === void 0 && $$bindings.placeholder && placeholder !== void 0)
        $$bindings.placeholder(placeholder);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      if ($$props.files === void 0 && $$bindings.files && files !== void 0)
        $$bindings.files(files);
      if ($$props.dirty === void 0 && $$bindings.dirty && dirty !== void 0)
        $$bindings.dirty(dirty);
      if ($$props.invalid === void 0 && $$bindings.invalid && invalid !== void 0)
        $$bindings.invalid(invalid);
      if ($$props.updateInvalid === void 0 && $$bindings.updateInvalid && updateInvalid !== void 0)
        $$bindings.updateInvalid(updateInvalid);
      if ($$props.emptyValueNull === void 0 && $$bindings.emptyValueNull && emptyValueNull !== void 0)
        $$bindings.emptyValueNull(emptyValueNull);
      if ($$props.emptyValueUndefined === void 0 && $$bindings.emptyValueUndefined && emptyValueUndefined !== void 0)
        $$bindings.emptyValueUndefined(emptyValueUndefined);
      if ($$props.getAttr === void 0 && $$bindings.getAttr && getAttr !== void 0)
        $$bindings.getAttr(getAttr);
      if ($$props.addAttr === void 0 && $$bindings.addAttr && addAttr !== void 0)
        $$bindings.addAttr(addAttr);
      if ($$props.removeAttr === void 0 && $$bindings.removeAttr && removeAttr !== void 0)
        $$bindings.removeAttr(removeAttr);
      if ($$props.focus === void 0 && $$bindings.focus && focus !== void 0)
        $$bindings.focus(focus);
      if ($$props.blur === void 0 && $$bindings.blur && blur !== void 0)
        $$bindings.blur(blur);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      {
        if (type === "file") {
          delete valueProp.value;
          valueProp = valueProp;
        } else {
          valueProp.value = value == null ? "" : value;
        }
      }
      return `<input${spread([
        {
          class: escape_attribute_value(classMap({
            [className]: true,
            "mdc-text-field__input": true
          }))
        },
        { type: escape_attribute_value(type) },
        {
          placeholder: escape_attribute_value(placeholder)
        },
        escape_object(valueProp),
        escape_object(internalAttrs),
        escape_object($$restProps)
      ])}${add_attribute("this", element, 0)}>`;
    });
    Textarea = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "use",
        "class",
        "style",
        "value",
        "dirty",
        "invalid",
        "updateInvalid",
        "resizable",
        "getAttr",
        "addAttr",
        "removeAttr",
        "focus",
        "blur",
        "getElement"
      ]);
      forwardEventsBuilder(get_current_component());
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { style = "" } = $$props;
      let { value = "" } = $$props;
      let { dirty = false } = $$props;
      let { invalid = false } = $$props;
      let { updateInvalid = true } = $$props;
      let { resizable = true } = $$props;
      let element;
      let internalAttrs = {};
      function getAttr(name22) {
        var _a2;
        return name22 in internalAttrs ? (_a2 = internalAttrs[name22]) !== null && _a2 !== void 0 ? _a2 : null : getElement().getAttribute(name22);
      }
      function addAttr(name22, value2) {
        if (internalAttrs[name22] !== value2) {
          internalAttrs[name22] = value2;
        }
      }
      function removeAttr(name22) {
        if (!(name22 in internalAttrs) || internalAttrs[name22] != null) {
          internalAttrs[name22] = void 0;
        }
      }
      function focus() {
        getElement().focus();
      }
      function blur() {
        getElement().blur();
      }
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.style === void 0 && $$bindings.style && style !== void 0)
        $$bindings.style(style);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      if ($$props.dirty === void 0 && $$bindings.dirty && dirty !== void 0)
        $$bindings.dirty(dirty);
      if ($$props.invalid === void 0 && $$bindings.invalid && invalid !== void 0)
        $$bindings.invalid(invalid);
      if ($$props.updateInvalid === void 0 && $$bindings.updateInvalid && updateInvalid !== void 0)
        $$bindings.updateInvalid(updateInvalid);
      if ($$props.resizable === void 0 && $$bindings.resizable && resizable !== void 0)
        $$bindings.resizable(resizable);
      if ($$props.getAttr === void 0 && $$bindings.getAttr && getAttr !== void 0)
        $$bindings.getAttr(getAttr);
      if ($$props.addAttr === void 0 && $$bindings.addAttr && addAttr !== void 0)
        $$bindings.addAttr(addAttr);
      if ($$props.removeAttr === void 0 && $$bindings.removeAttr && removeAttr !== void 0)
        $$bindings.removeAttr(removeAttr);
      if ($$props.focus === void 0 && $$bindings.focus && focus !== void 0)
        $$bindings.focus(focus);
      if ($$props.blur === void 0 && $$bindings.blur && blur !== void 0)
        $$bindings.blur(blur);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<textarea${spread([
        {
          class: escape_attribute_value(classMap({
            [className]: true,
            "mdc-text-field__input": true
          }))
        },
        {
          style: escape_attribute_value(`${resizable ? "" : "resize: none; "}${style}`)
        },
        escape_object(internalAttrs),
        escape_object($$restProps)
      ])}${add_attribute("this", element, 0)}>${value || ""}</textarea>`;
    });
    ({ Object: Object_13 } = globals);
    Textfield = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "use",
        "class",
        "style",
        "ripple",
        "disabled",
        "required",
        "textarea",
        "variant",
        "noLabel",
        "label",
        "type",
        "value",
        "files",
        "invalid",
        "updateInvalid",
        "dirty",
        "prefix",
        "suffix",
        "validateOnValueChange",
        "useNativeValidation",
        "withLeadingIcon",
        "withTrailingIcon",
        "input",
        "floatingLabel",
        "lineRipple",
        "notchedOutline",
        "focus",
        "blur",
        "layout",
        "getElement"
      ]);
      let $$slots = compute_slots(slots);
      forwardEventsBuilder(get_current_component());
      let uninitializedValue = () => {
      };
      function isUninitializedValue(value2) {
        return value2 === uninitializedValue;
      }
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { style = "" } = $$props;
      let { ripple = true } = $$props;
      let { disabled = false } = $$props;
      let { required = false } = $$props;
      let { textarea = false } = $$props;
      let { variant = textarea ? "outlined" : "standard" } = $$props;
      let { noLabel = false } = $$props;
      let { label = void 0 } = $$props;
      let { type = "text" } = $$props;
      let { value = $$restProps.input$emptyValueUndefined ? void 0 : uninitializedValue } = $$props;
      let { files = uninitializedValue } = $$props;
      const valued = !isUninitializedValue(value) || !isUninitializedValue(files);
      if (isUninitializedValue(value)) {
        value = void 0;
      }
      if (isUninitializedValue(files)) {
        files = null;
      }
      let { invalid = uninitializedValue } = $$props;
      let { updateInvalid = isUninitializedValue(invalid) } = $$props;
      if (isUninitializedValue(invalid)) {
        invalid = false;
      }
      let { dirty = false } = $$props;
      let { prefix = void 0 } = $$props;
      let { suffix = void 0 } = $$props;
      let { validateOnValueChange = updateInvalid } = $$props;
      let { useNativeValidation = updateInvalid } = $$props;
      let { withLeadingIcon = uninitializedValue } = $$props;
      let { withTrailingIcon = uninitializedValue } = $$props;
      let { input = void 0 } = $$props;
      let { floatingLabel = void 0 } = $$props;
      let { lineRipple = void 0 } = $$props;
      let { notchedOutline = void 0 } = $$props;
      let element;
      let internalClasses = {};
      let internalStyles = {};
      let helperId = void 0;
      let addLayoutListener = getContext("SMUI:addLayoutListener");
      let removeLayoutListener;
      new Promise((resolve2) => resolve2);
      if (addLayoutListener) {
        removeLayoutListener = addLayoutListener(layout);
      }
      onDestroy(() => {
        if (removeLayoutListener) {
          removeLayoutListener();
        }
      });
      function focus() {
        input === null || input === void 0 ? void 0 : input.focus();
      }
      function blur() {
        input === null || input === void 0 ? void 0 : input.blur();
      }
      function layout() {
      }
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.style === void 0 && $$bindings.style && style !== void 0)
        $$bindings.style(style);
      if ($$props.ripple === void 0 && $$bindings.ripple && ripple !== void 0)
        $$bindings.ripple(ripple);
      if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
        $$bindings.disabled(disabled);
      if ($$props.required === void 0 && $$bindings.required && required !== void 0)
        $$bindings.required(required);
      if ($$props.textarea === void 0 && $$bindings.textarea && textarea !== void 0)
        $$bindings.textarea(textarea);
      if ($$props.variant === void 0 && $$bindings.variant && variant !== void 0)
        $$bindings.variant(variant);
      if ($$props.noLabel === void 0 && $$bindings.noLabel && noLabel !== void 0)
        $$bindings.noLabel(noLabel);
      if ($$props.label === void 0 && $$bindings.label && label !== void 0)
        $$bindings.label(label);
      if ($$props.type === void 0 && $$bindings.type && type !== void 0)
        $$bindings.type(type);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      if ($$props.files === void 0 && $$bindings.files && files !== void 0)
        $$bindings.files(files);
      if ($$props.invalid === void 0 && $$bindings.invalid && invalid !== void 0)
        $$bindings.invalid(invalid);
      if ($$props.updateInvalid === void 0 && $$bindings.updateInvalid && updateInvalid !== void 0)
        $$bindings.updateInvalid(updateInvalid);
      if ($$props.dirty === void 0 && $$bindings.dirty && dirty !== void 0)
        $$bindings.dirty(dirty);
      if ($$props.prefix === void 0 && $$bindings.prefix && prefix !== void 0)
        $$bindings.prefix(prefix);
      if ($$props.suffix === void 0 && $$bindings.suffix && suffix !== void 0)
        $$bindings.suffix(suffix);
      if ($$props.validateOnValueChange === void 0 && $$bindings.validateOnValueChange && validateOnValueChange !== void 0)
        $$bindings.validateOnValueChange(validateOnValueChange);
      if ($$props.useNativeValidation === void 0 && $$bindings.useNativeValidation && useNativeValidation !== void 0)
        $$bindings.useNativeValidation(useNativeValidation);
      if ($$props.withLeadingIcon === void 0 && $$bindings.withLeadingIcon && withLeadingIcon !== void 0)
        $$bindings.withLeadingIcon(withLeadingIcon);
      if ($$props.withTrailingIcon === void 0 && $$bindings.withTrailingIcon && withTrailingIcon !== void 0)
        $$bindings.withTrailingIcon(withTrailingIcon);
      if ($$props.input === void 0 && $$bindings.input && input !== void 0)
        $$bindings.input(input);
      if ($$props.floatingLabel === void 0 && $$bindings.floatingLabel && floatingLabel !== void 0)
        $$bindings.floatingLabel(floatingLabel);
      if ($$props.lineRipple === void 0 && $$bindings.lineRipple && lineRipple !== void 0)
        $$bindings.lineRipple(lineRipple);
      if ($$props.notchedOutline === void 0 && $$bindings.notchedOutline && notchedOutline !== void 0)
        $$bindings.notchedOutline(notchedOutline);
      if ($$props.focus === void 0 && $$bindings.focus && focus !== void 0)
        $$bindings.focus(focus);
      if ($$props.blur === void 0 && $$bindings.blur && blur !== void 0)
        $$bindings.blur(blur);
      if ($$props.layout === void 0 && $$bindings.layout && layout !== void 0)
        $$bindings.layout(layout);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        input && input.getElement();
        $$rendered = `${valued ? `<label${spread([
          {
            class: escape_attribute_value(classMap({
              [className]: true,
              "mdc-text-field": true,
              "mdc-text-field--disabled": disabled,
              "mdc-text-field--textarea": textarea,
              "mdc-text-field--filled": variant === "filled",
              "mdc-text-field--outlined": variant === "outlined",
              "smui-text-field--standard": variant === "standard" && !textarea,
              "mdc-text-field--no-label": noLabel || label == null && !$$slots.label,
              "mdc-text-field--label-floating": value != null && value !== "",
              "mdc-text-field--with-leading-icon": isUninitializedValue(withLeadingIcon) ? $$slots.leadingIcon : withLeadingIcon,
              "mdc-text-field--with-trailing-icon": isUninitializedValue(withTrailingIcon) ? $$slots.trailingIcon : withTrailingIcon,
              "mdc-text-field--with-internal-counter": textarea && $$slots.internalCounter,
              "mdc-text-field--invalid": invalid,
              ...internalClasses
            }))
          },
          {
            style: escape_attribute_value(Object.entries(internalStyles).map(([name22, value2]) => `${name22}: ${value2};`).concat([style]).join(" "))
          },
          {
            for: escape_attribute_value(void 0)
          },
          escape_object(exclude($$restProps, ["input$", "label$", "ripple$", "outline$", "helperLine$"]))
        ])}${add_attribute("this", element, 0)}>${!textarea && variant !== "outlined" ? `${variant === "filled" ? `<span class="${"mdc-text-field__ripple"}"></span>` : ``}
      ${!noLabel && (label != null || $$slots.label) ? `${validate_component(FloatingLabel, "FloatingLabel").$$render($$result, Object_13.assign({
          floatAbove: value != null && value !== ""
        }, { required }, { wrapped: true }, prefixFilter($$restProps, "label$"), { this: floatingLabel }), {
          this: ($$value) => {
            floatingLabel = $$value;
            $$settled = false;
          }
        }, {
          default: () => `${escape(label == null ? "" : label)}${slots.label ? slots.label({}) : ``}`
        })}` : ``}` : ``}
    ${textarea || variant === "outlined" ? `${validate_component(NotchedOutline, "NotchedOutline").$$render($$result, Object_13.assign({
          noLabel: noLabel || label == null && !$$slots.label
        }, prefixFilter($$restProps, "outline$"), { this: notchedOutline }), {
          this: ($$value) => {
            notchedOutline = $$value;
            $$settled = false;
          }
        }, {
          default: () => `${!noLabel && (label != null || $$slots.label) ? `${validate_component(FloatingLabel, "FloatingLabel").$$render($$result, Object_13.assign({
            floatAbove: value != null && value !== ""
          }, { required }, { wrapped: true }, prefixFilter($$restProps, "label$"), { this: floatingLabel }), {
            this: ($$value) => {
              floatingLabel = $$value;
              $$settled = false;
            }
          }, {
            default: () => `${escape(label == null ? "" : label)}${slots.label ? slots.label({}) : ``}`
          })}` : ``}`
        })}` : ``}
    ${validate_component(ContextFragment, "ContextFragment").$$render($$result, {
          key: "SMUI:textfield:icon:leading",
          value: true
        }, {}, {
          default: () => `${slots.leadingIcon ? slots.leadingIcon({}) : ``}`
        })}
    ${slots.default ? slots.default({}) : ``}
    ${textarea && typeof value === "string" ? `<span${add_attribute("class", classMap({
          "mdc-text-field__resizer": !("input$resizable" in $$restProps) || $$restProps.input$resizable
        }), 0)}>${validate_component(Textarea, "Textarea").$$render($$result, Object_13.assign({ disabled }, { required }, { updateInvalid }, { "aria-controls": helperId }, { "aria-describedby": helperId }, prefixFilter($$restProps, "input$"), { this: input }, { value }, { dirty }, { invalid }), {
          this: ($$value) => {
            input = $$value;
            $$settled = false;
          },
          value: ($$value) => {
            value = $$value;
            $$settled = false;
          },
          dirty: ($$value) => {
            dirty = $$value;
            $$settled = false;
          },
          invalid: ($$value) => {
            invalid = $$value;
            $$settled = false;
          }
        }, {})}
        ${slots.internalCounter ? slots.internalCounter({}) : ``}</span>` : `${slots.prefix ? slots.prefix({}) : ``}
      ${prefix != null ? `${validate_component(Prefix, "Prefix").$$render($$result, {}, {}, { default: () => `${escape(prefix)}` })}` : ``}
      ${validate_component(Input, "Input").$$render($$result, Object_13.assign({ type }, { disabled }, { required }, { updateInvalid }, { "aria-controls": helperId }, { "aria-describedby": helperId }, noLabel && label != null ? { placeholder: label } : {}, prefixFilter($$restProps, "input$"), { this: input }, { value }, { files }, { dirty }, { invalid }), {
          this: ($$value) => {
            input = $$value;
            $$settled = false;
          },
          value: ($$value) => {
            value = $$value;
            $$settled = false;
          },
          files: ($$value) => {
            files = $$value;
            $$settled = false;
          },
          dirty: ($$value) => {
            dirty = $$value;
            $$settled = false;
          },
          invalid: ($$value) => {
            invalid = $$value;
            $$settled = false;
          }
        }, {})}
      ${suffix != null ? `${validate_component(Suffix, "Suffix").$$render($$result, {}, {}, { default: () => `${escape(suffix)}` })}` : ``}
      ${slots.suffix ? slots.suffix({}) : ``}`}
    ${validate_component(ContextFragment, "ContextFragment").$$render($$result, {
          key: "SMUI:textfield:icon:leading",
          value: false
        }, {}, {
          default: () => `${slots.trailingIcon ? slots.trailingIcon({}) : ``}`
        })}
    ${!textarea && variant !== "outlined" && ripple ? `${validate_component(LineRipple, "LineRipple").$$render($$result, Object_13.assign(prefixFilter($$restProps, "ripple$"), { this: lineRipple }), {
          this: ($$value) => {
            lineRipple = $$value;
            $$settled = false;
          }
        }, {})}` : ``}</label>` : `<div${spread([
          {
            class: escape_attribute_value(classMap({
              [className]: true,
              "mdc-text-field": true,
              "mdc-text-field--disabled": disabled,
              "mdc-text-field--textarea": textarea,
              "mdc-text-field--filled": variant === "filled",
              "mdc-text-field--outlined": variant === "outlined",
              "smui-text-field--standard": variant === "standard" && !textarea,
              "mdc-text-field--no-label": noLabel || !$$slots.label,
              "mdc-text-field--with-leading-icon": $$slots.leadingIcon,
              "mdc-text-field--with-trailing-icon": $$slots.trailingIcon,
              "mdc-text-field--invalid": invalid,
              ...internalClasses
            }))
          },
          {
            style: escape_attribute_value(Object.entries(internalStyles).map(([name22, value2]) => `${name22}: ${value2};`).concat([style]).join(" "))
          },
          escape_object(exclude($$restProps, ["input$", "label$", "ripple$", "outline$", "helperLine$"]))
        ])}${add_attribute("this", element, 0)}>${slots.label ? slots.label({}) : ``}
    ${validate_component(ContextFragment, "ContextFragment").$$render($$result, {
          key: "SMUI:textfield:icon:leading",
          value: true
        }, {}, {
          default: () => `${slots.leadingIcon ? slots.leadingIcon({}) : ``}`
        })}
    ${slots.default ? slots.default({}) : ``}
    ${validate_component(ContextFragment, "ContextFragment").$$render($$result, {
          key: "SMUI:textfield:icon:leading",
          value: false
        }, {}, {
          default: () => `${slots.trailingIcon ? slots.trailingIcon({}) : ``}`
        })}
    ${slots.ripple ? slots.ripple({}) : ``}</div>`}
${$$slots.helper ? `${validate_component(HelperLine, "HelperLine").$$render($$result, Object_13.assign(prefixFilter($$restProps, "helperLine$")), {}, {
          default: () => `${slots.helper ? slots.helper({}) : ``}`
        })}` : ``}`;
      } while (!$$settled);
      return $$rendered;
    });
    MenuSurface = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "use",
        "class",
        "style",
        "static",
        "anchor",
        "fixed",
        "open",
        "managed",
        "fullWidth",
        "quickOpen",
        "anchorElement",
        "anchorCorner",
        "anchorMargin",
        "maxHeight",
        "horizontallyCenteredOnViewport",
        "isOpen",
        "setOpen",
        "setAbsolutePosition",
        "setIsHoisted",
        "isFixed",
        "getElement"
      ]);
      forwardEventsBuilder(get_current_component());
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { style = "" } = $$props;
      let { static: isStatic = false } = $$props;
      let { anchor = true } = $$props;
      let { fixed = false } = $$props;
      let { open = isStatic } = $$props;
      let { managed = false } = $$props;
      let { fullWidth = false } = $$props;
      let { quickOpen = false } = $$props;
      let { anchorElement = void 0 } = $$props;
      let { anchorCorner = void 0 } = $$props;
      let { anchorMargin = { top: 0, right: 0, bottom: 0, left: 0 } } = $$props;
      let { maxHeight = 0 } = $$props;
      let { horizontallyCenteredOnViewport = false } = $$props;
      let element;
      let instance2;
      let internalClasses = {};
      let internalStyles = {};
      setContext("SMUI:list:role", "menu");
      setContext("SMUI:list:item:role", "menuitem");
      onDestroy(() => {
      });
      function isOpen() {
        return open;
      }
      function setOpen(value) {
        open = value;
      }
      function setAbsolutePosition(x2, y2) {
        return instance2.setAbsolutePosition(x2, y2);
      }
      function setIsHoisted(isHoisted) {
        return instance2.setIsHoisted(isHoisted);
      }
      function isFixed() {
        return instance2.isFixed();
      }
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.style === void 0 && $$bindings.style && style !== void 0)
        $$bindings.style(style);
      if ($$props.static === void 0 && $$bindings.static && isStatic !== void 0)
        $$bindings.static(isStatic);
      if ($$props.anchor === void 0 && $$bindings.anchor && anchor !== void 0)
        $$bindings.anchor(anchor);
      if ($$props.fixed === void 0 && $$bindings.fixed && fixed !== void 0)
        $$bindings.fixed(fixed);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      if ($$props.managed === void 0 && $$bindings.managed && managed !== void 0)
        $$bindings.managed(managed);
      if ($$props.fullWidth === void 0 && $$bindings.fullWidth && fullWidth !== void 0)
        $$bindings.fullWidth(fullWidth);
      if ($$props.quickOpen === void 0 && $$bindings.quickOpen && quickOpen !== void 0)
        $$bindings.quickOpen(quickOpen);
      if ($$props.anchorElement === void 0 && $$bindings.anchorElement && anchorElement !== void 0)
        $$bindings.anchorElement(anchorElement);
      if ($$props.anchorCorner === void 0 && $$bindings.anchorCorner && anchorCorner !== void 0)
        $$bindings.anchorCorner(anchorCorner);
      if ($$props.anchorMargin === void 0 && $$bindings.anchorMargin && anchorMargin !== void 0)
        $$bindings.anchorMargin(anchorMargin);
      if ($$props.maxHeight === void 0 && $$bindings.maxHeight && maxHeight !== void 0)
        $$bindings.maxHeight(maxHeight);
      if ($$props.horizontallyCenteredOnViewport === void 0 && $$bindings.horizontallyCenteredOnViewport && horizontallyCenteredOnViewport !== void 0)
        $$bindings.horizontallyCenteredOnViewport(horizontallyCenteredOnViewport);
      if ($$props.isOpen === void 0 && $$bindings.isOpen && isOpen !== void 0)
        $$bindings.isOpen(isOpen);
      if ($$props.setOpen === void 0 && $$bindings.setOpen && setOpen !== void 0)
        $$bindings.setOpen(setOpen);
      if ($$props.setAbsolutePosition === void 0 && $$bindings.setAbsolutePosition && setAbsolutePosition !== void 0)
        $$bindings.setAbsolutePosition(setAbsolutePosition);
      if ($$props.setIsHoisted === void 0 && $$bindings.setIsHoisted && setIsHoisted !== void 0)
        $$bindings.setIsHoisted(setIsHoisted);
      if ($$props.isFixed === void 0 && $$bindings.isFixed && isFixed !== void 0)
        $$bindings.isFixed(isFixed);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `

<div${spread([
        {
          class: escape_attribute_value(classMap({
            [className]: true,
            "mdc-menu-surface": true,
            "mdc-menu-surface--fixed": fixed,
            "mdc-menu-surface--open": isStatic,
            "smui-menu-surface--static": isStatic,
            "mdc-menu-surface--fullwidth": fullWidth,
            ...internalClasses
          }))
        },
        {
          style: escape_attribute_value(Object.entries(internalStyles).map(([name22, value]) => `${name22}: ${value};`).concat([style]).join(" "))
        },
        escape_object($$restProps)
      ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</div>`;
    });
    Menu = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let usePass;
      let $$restProps = compute_rest_props($$props, [
        "use",
        "class",
        "open",
        "isOpen",
        "setOpen",
        "setDefaultFocusState",
        "getSelectedIndex",
        "getElement"
      ]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { open = false } = $$props;
      let element;
      let instance2;
      function isOpen() {
        return open;
      }
      function setOpen(value) {
        open = value;
      }
      function setDefaultFocusState(focusState) {
        instance2.setDefaultFocusState(focusState);
      }
      function getSelectedIndex() {
        return instance2.getSelectedIndex();
      }
      function getElement() {
        return element.getElement();
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      if ($$props.isOpen === void 0 && $$bindings.isOpen && isOpen !== void 0)
        $$bindings.isOpen(isOpen);
      if ($$props.setOpen === void 0 && $$bindings.setOpen && setOpen !== void 0)
        $$bindings.setOpen(setOpen);
      if ($$props.setDefaultFocusState === void 0 && $$bindings.setDefaultFocusState && setDefaultFocusState !== void 0)
        $$bindings.setDefaultFocusState(setDefaultFocusState);
      if ($$props.getSelectedIndex === void 0 && $$bindings.getSelectedIndex && getSelectedIndex !== void 0)
        $$bindings.getSelectedIndex(getSelectedIndex);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        usePass = [forwardEvents, ...use];
        $$rendered = `${validate_component(MenuSurface, "MenuSurface").$$render($$result, Object.assign({ use: usePass }, {
          class: classMap({ [className]: true, "mdc-menu": true })
        }, $$restProps, { this: element }, { open }), {
          this: ($$value) => {
            element = $$value;
            $$settled = false;
          },
          open: ($$value) => {
            open = $$value;
            $$settled = false;
          }
        }, {
          default: () => `${slots.default ? slots.default({}) : ``}`
        })}`;
      } while (!$$settled);
      return $$rendered;
    });
    Switch = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "use",
        "class",
        "disabled",
        "color",
        "group",
        "checked",
        "value",
        "processing",
        "icons",
        "icons$use",
        "icons$class",
        "getId",
        "getElement"
      ]);
      var _a2;
      forwardEventsBuilder(get_current_component());
      let uninitializedValue = () => {
      };
      function isUninitializedValue(value2) {
        return value2 === uninitializedValue;
      }
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { disabled = false } = $$props;
      let { color = "primary" } = $$props;
      let { group = uninitializedValue } = $$props;
      let { checked = uninitializedValue } = $$props;
      let { value = null } = $$props;
      let { processing = false } = $$props;
      let { icons = true } = $$props;
      let { icons$use = [] } = $$props;
      let { icons$class = "" } = $$props;
      let element;
      let internalClasses = {};
      let rippleElement;
      let inputProps = (_a2 = getContext("SMUI:generic:input:props")) !== null && _a2 !== void 0 ? _a2 : {};
      let selected = isUninitializedValue(group) ? isUninitializedValue(checked) ? false : checked : group.indexOf(value) !== -1;
      let state = {
        get disabled() {
          return disabled;
        },
        set disabled(value2) {
          disabled = value2;
        },
        get processing() {
          return processing;
        },
        set processing(value2) {
          processing = value2;
        },
        get selected() {
          return selected;
        },
        set selected(value2) {
          selected = value2;
        }
      };
      let previousChecked = checked;
      let previousGroup = isUninitializedValue(group) ? [] : [...group];
      let previousSelected = selected;
      function getId() {
        return inputProps && inputProps.id;
      }
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
        $$bindings.disabled(disabled);
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.group === void 0 && $$bindings.group && group !== void 0)
        $$bindings.group(group);
      if ($$props.checked === void 0 && $$bindings.checked && checked !== void 0)
        $$bindings.checked(checked);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      if ($$props.processing === void 0 && $$bindings.processing && processing !== void 0)
        $$bindings.processing(processing);
      if ($$props.icons === void 0 && $$bindings.icons && icons !== void 0)
        $$bindings.icons(icons);
      if ($$props.icons$use === void 0 && $$bindings.icons$use && icons$use !== void 0)
        $$bindings.icons$use(icons$use);
      if ($$props.icons$class === void 0 && $$bindings.icons$class && icons$class !== void 0)
        $$bindings.icons$class(icons$class);
      if ($$props.getId === void 0 && $$bindings.getId && getId !== void 0)
        $$bindings.getId(getId);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      {
        {
          let notifyChange = false;
          if (!isUninitializedValue(group)) {
            if (previousSelected !== selected) {
              const idx = group.indexOf(value);
              if (selected && idx === -1) {
                group.push(value);
                group = group;
              } else if (!selected && idx !== -1) {
                group.splice(idx, 1);
                group = group;
              }
              notifyChange = true;
            } else {
              const idxPrev = previousGroup.indexOf(value);
              const idx = group.indexOf(value);
              if (idxPrev > -1 && idx === -1) {
                state.selected = false;
              } else if (idx > -1 && idxPrev === -1) {
                state.selected = true;
              }
            }
          }
          if (isUninitializedValue(checked)) {
            if (previousSelected !== selected) {
              notifyChange = true;
            }
          } else if (checked !== selected) {
            if (checked === previousChecked) {
              checked = selected;
              notifyChange = true;
            } else {
              state.selected = checked;
            }
          }
          previousChecked = checked;
          previousGroup = isUninitializedValue(group) ? [] : [...group];
          previousSelected = selected;
          if (notifyChange && element) {
            dispatch(element, "SMUISwitch:change", { selected, value });
          }
        }
      }
      return `<button${spread([
        {
          class: escape_attribute_value(classMap({
            [className]: true,
            "mdc-switch": true,
            "mdc-switch--unselected": !selected,
            "mdc-switch--selected": selected,
            "mdc-switch--processing": processing,
            "smui-switch--color-secondary": color === "secondary",
            ...internalClasses
          }))
        },
        { type: "button" },
        { role: "switch" },
        {
          "aria-checked": escape_attribute_value(selected ? "true" : "false")
        },
        { disabled: disabled || null },
        escape_object(inputProps),
        escape_object(exclude($$restProps, ["icons$"]))
      ])}${add_attribute("this", element, 0)}><div class="${"mdc-switch__track"}"></div>
  <div class="${"mdc-switch__handle-track"}"><div class="${"mdc-switch__handle"}"><div class="${"mdc-switch__shadow"}"><div class="${"mdc-elevation-overlay"}"></div></div>
      <div class="${"mdc-switch__ripple"}"${add_attribute("this", rippleElement, 0)}></div>
      ${icons ? `<div${spread([
        {
          class: escape_attribute_value(classMap({
            [icons$class]: true,
            "mdc-switch__icons": true
          }))
        },
        escape_object(prefixFilter($$restProps, "icons$"))
      ])}><svg class="${"mdc-switch__icon mdc-switch__icon--on"}" viewBox="${"0 0 24 24"}"><path d="${"M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z"}"></path></svg>
          <svg class="${"mdc-switch__icon mdc-switch__icon--off"}" viewBox="${"0 0 24 24"}"><path d="${"M20 13H4v-2h16v2z"}"></path></svg></div>` : ``}</div></div>
</button>`;
    });
    DEFAULT_HOST = "firebasestorage.googleapis.com";
    CONFIG_STORAGE_BUCKET_KEY = "storageBucket";
    DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1e3;
    DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1e3;
    StorageError = class extends FirebaseError {
      constructor(code, message2) {
        super(prependCode(code), `Firebase Storage: ${message2} (${prependCode(code)})`);
        this.customData = { serverResponse: null };
        this._baseMessage = this.message;
        Object.setPrototypeOf(this, StorageError.prototype);
      }
      _codeEquals(code) {
        return prependCode(code) === this.code;
      }
      get serverResponse() {
        return this.customData.serverResponse;
      }
      set serverResponse(serverResponse) {
        this.customData.serverResponse = serverResponse;
        if (this.customData.serverResponse) {
          this.message = `${this._baseMessage}
${this.customData.serverResponse}`;
        } else {
          this.message = this._baseMessage;
        }
      }
    };
    Location = class {
      constructor(bucket, path) {
        this.bucket = bucket;
        this.path_ = path;
      }
      get path() {
        return this.path_;
      }
      get isRoot() {
        return this.path.length === 0;
      }
      fullServerUrl() {
        const encode = encodeURIComponent;
        return "/b/" + encode(this.bucket) + "/o/" + encode(this.path);
      }
      bucketOnlyServerUrl() {
        const encode = encodeURIComponent;
        return "/b/" + encode(this.bucket) + "/o";
      }
      static makeFromBucketSpec(bucketString, host) {
        let bucketLocation;
        try {
          bucketLocation = Location.makeFromUrl(bucketString, host);
        } catch (e) {
          return new Location(bucketString, "");
        }
        if (bucketLocation.path === "") {
          return bucketLocation;
        } else {
          throw invalidDefaultBucket(bucketString);
        }
      }
      static makeFromUrl(url2, host) {
        let location2 = null;
        const bucketDomain = "([A-Za-z0-9.\\-_]+)";
        function gsModify(loc) {
          if (loc.path.charAt(loc.path.length - 1) === "/") {
            loc.path_ = loc.path_.slice(0, -1);
          }
        }
        const gsPath = "(/(.*))?$";
        const gsRegex = new RegExp("^gs://" + bucketDomain + gsPath, "i");
        const gsIndices = { bucket: 1, path: 3 };
        function httpModify(loc) {
          loc.path_ = decodeURIComponent(loc.path);
        }
        const version22 = "v[A-Za-z0-9_]+";
        const firebaseStorageHost = host.replace(/[.]/g, "\\.");
        const firebaseStoragePath = "(/([^?#]*).*)?$";
        const firebaseStorageRegExp = new RegExp(`^https?://${firebaseStorageHost}/${version22}/b/${bucketDomain}/o${firebaseStoragePath}`, "i");
        const firebaseStorageIndices = { bucket: 1, path: 3 };
        const cloudStorageHost = host === DEFAULT_HOST ? "(?:storage.googleapis.com|storage.cloud.google.com)" : host;
        const cloudStoragePath = "([^?#]*)";
        const cloudStorageRegExp = new RegExp(`^https?://${cloudStorageHost}/${bucketDomain}/${cloudStoragePath}`, "i");
        const cloudStorageIndices = { bucket: 1, path: 2 };
        const groups = [
          { regex: gsRegex, indices: gsIndices, postModify: gsModify },
          {
            regex: firebaseStorageRegExp,
            indices: firebaseStorageIndices,
            postModify: httpModify
          },
          {
            regex: cloudStorageRegExp,
            indices: cloudStorageIndices,
            postModify: httpModify
          }
        ];
        for (let i = 0; i < groups.length; i++) {
          const group = groups[i];
          const captures = group.regex.exec(url2);
          if (captures) {
            const bucketValue = captures[group.indices.bucket];
            let pathValue = captures[group.indices.path];
            if (!pathValue) {
              pathValue = "";
            }
            location2 = new Location(bucketValue, pathValue);
            group.postModify(location2);
            break;
          }
        }
        if (location2 == null) {
          throw invalidUrl(url2);
        }
        return location2;
      }
    };
    FailRequest = class {
      constructor(error3) {
        this.promise_ = Promise.reject(error3);
      }
      getPromise() {
        return this.promise_;
      }
      cancel(_appDelete = false) {
      }
    };
    (function(ErrorCode22) {
      ErrorCode22[ErrorCode22["NO_ERROR"] = 0] = "NO_ERROR";
      ErrorCode22[ErrorCode22["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
      ErrorCode22[ErrorCode22["ABORT"] = 2] = "ABORT";
    })(ErrorCode2 || (ErrorCode2 = {}));
    NetworkRequest = class {
      constructor(url_, method_, headers_, body_, successCodes_, additionalRetryCodes_, callback_, errorCallback_, timeout_, progressCallback_, connectionFactory_) {
        this.url_ = url_;
        this.method_ = method_;
        this.headers_ = headers_;
        this.body_ = body_;
        this.successCodes_ = successCodes_;
        this.additionalRetryCodes_ = additionalRetryCodes_;
        this.callback_ = callback_;
        this.errorCallback_ = errorCallback_;
        this.timeout_ = timeout_;
        this.progressCallback_ = progressCallback_;
        this.connectionFactory_ = connectionFactory_;
        this.pendingConnection_ = null;
        this.backoffId_ = null;
        this.canceled_ = false;
        this.appDelete_ = false;
        this.promise_ = new Promise((resolve2, reject2) => {
          this.resolve_ = resolve2;
          this.reject_ = reject2;
          this.start_();
        });
      }
      start_() {
        const doTheRequest = (backoffCallback, canceled2) => {
          if (canceled2) {
            backoffCallback(false, new RequestEndStatus(false, null, true));
            return;
          }
          const connection = this.connectionFactory_();
          this.pendingConnection_ = connection;
          const progressListener = (progressEvent) => {
            const loaded = progressEvent.loaded;
            const total = progressEvent.lengthComputable ? progressEvent.total : -1;
            if (this.progressCallback_ !== null) {
              this.progressCallback_(loaded, total);
            }
          };
          if (this.progressCallback_ !== null) {
            connection.addUploadProgressListener(progressListener);
          }
          connection.send(this.url_, this.method_, this.body_, this.headers_).then(() => {
            if (this.progressCallback_ !== null) {
              connection.removeUploadProgressListener(progressListener);
            }
            this.pendingConnection_ = null;
            const hitServer = connection.getErrorCode() === ErrorCode2.NO_ERROR;
            const status = connection.getStatus();
            if (!hitServer || this.isRetryStatusCode_(status)) {
              const wasCanceled = connection.getErrorCode() === ErrorCode2.ABORT;
              backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
              return;
            }
            const successCode = this.successCodes_.indexOf(status) !== -1;
            backoffCallback(true, new RequestEndStatus(successCode, connection));
          });
        };
        const backoffDone = (requestWentThrough, status) => {
          const resolve2 = this.resolve_;
          const reject2 = this.reject_;
          const connection = status.connection;
          if (status.wasSuccessCode) {
            try {
              const result = this.callback_(connection, connection.getResponse());
              if (isJustDef(result)) {
                resolve2(result);
              } else {
                resolve2();
              }
            } catch (e) {
              reject2(e);
            }
          } else {
            if (connection !== null) {
              const err = unknown();
              err.serverResponse = connection.getErrorText();
              if (this.errorCallback_) {
                reject2(this.errorCallback_(connection, err));
              } else {
                reject2(err);
              }
            } else {
              if (status.canceled) {
                const err = this.appDelete_ ? appDeleted() : canceled();
                reject2(err);
              } else {
                const err = retryLimitExceeded();
                reject2(err);
              }
            }
          }
        };
        if (this.canceled_) {
          backoffDone(false, new RequestEndStatus(false, null, true));
        } else {
          this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);
        }
      }
      getPromise() {
        return this.promise_;
      }
      cancel(appDelete) {
        this.canceled_ = true;
        this.appDelete_ = appDelete || false;
        if (this.backoffId_ !== null) {
          stop(this.backoffId_);
        }
        if (this.pendingConnection_ !== null) {
          this.pendingConnection_.abort();
        }
      }
      isRetryStatusCode_(status) {
        const isFiveHundredCode = status >= 500 && status < 600;
        const extraRetryCodes = [
          408,
          429
        ];
        const isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;
        const isRequestSpecificRetryCode = this.additionalRetryCodes_.indexOf(status) !== -1;
        return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;
      }
    };
    RequestEndStatus = class {
      constructor(wasSuccessCode, connection, canceled2) {
        this.wasSuccessCode = wasSuccessCode;
        this.connection = connection;
        this.canceled = !!canceled2;
      }
    };
    Reference = class {
      constructor(_service, location2) {
        this._service = _service;
        if (location2 instanceof Location) {
          this._location = location2;
        } else {
          this._location = Location.makeFromUrl(location2, _service.host);
        }
      }
      toString() {
        return "gs://" + this._location.bucket + "/" + this._location.path;
      }
      _newRef(service, location2) {
        return new Reference(service, location2);
      }
      get root() {
        const location2 = new Location(this._location.bucket, "");
        return this._newRef(this._service, location2);
      }
      get bucket() {
        return this._location.bucket;
      }
      get fullPath() {
        return this._location.path;
      }
      get name() {
        return lastComponent(this._location.path);
      }
      get storage() {
        return this._service;
      }
      get parent() {
        const newPath = parent(this._location.path);
        if (newPath === null) {
          return null;
        }
        const location2 = new Location(this._location.bucket, newPath);
        return new Reference(this._service, location2);
      }
      _throwIfRoot(name22) {
        if (this._location.path === "") {
          throw invalidRootOperation(name22);
        }
      }
    };
    FirebaseStorageImpl = class {
      constructor(app, _authProvider, _appCheckProvider, _url, _firebaseVersion) {
        this.app = app;
        this._authProvider = _authProvider;
        this._appCheckProvider = _appCheckProvider;
        this._url = _url;
        this._firebaseVersion = _firebaseVersion;
        this._bucket = null;
        this._host = DEFAULT_HOST;
        this._protocol = "https";
        this._appId = null;
        this._deleted = false;
        this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;
        this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;
        this._requests = new Set();
        if (_url != null) {
          this._bucket = Location.makeFromBucketSpec(_url, this._host);
        } else {
          this._bucket = extractBucket(this._host, this.app.options);
        }
      }
      get host() {
        return this._host;
      }
      set host(host) {
        this._host = host;
        if (this._url != null) {
          this._bucket = Location.makeFromBucketSpec(this._url, host);
        } else {
          this._bucket = extractBucket(host, this.app.options);
        }
      }
      get maxUploadRetryTime() {
        return this._maxUploadRetryTime;
      }
      set maxUploadRetryTime(time) {
        validateNumber("time", 0, Number.POSITIVE_INFINITY, time);
        this._maxUploadRetryTime = time;
      }
      get maxOperationRetryTime() {
        return this._maxOperationRetryTime;
      }
      set maxOperationRetryTime(time) {
        validateNumber("time", 0, Number.POSITIVE_INFINITY, time);
        this._maxOperationRetryTime = time;
      }
      async _getAuthToken() {
        if (this._overrideAuthToken) {
          return this._overrideAuthToken;
        }
        const auth = this._authProvider.getImmediate({ optional: true });
        if (auth) {
          const tokenData = await auth.getToken();
          if (tokenData !== null) {
            return tokenData.accessToken;
          }
        }
        return null;
      }
      async _getAppCheckToken() {
        const appCheck = this._appCheckProvider.getImmediate({ optional: true });
        if (appCheck) {
          const result = await appCheck.getToken();
          return result.token;
        }
        return null;
      }
      _delete() {
        if (!this._deleted) {
          this._deleted = true;
          this._requests.forEach((request) => request.cancel());
          this._requests.clear();
        }
        return Promise.resolve();
      }
      _makeStorageReference(loc) {
        return new Reference(this, loc);
      }
      _makeRequest(requestInfo, requestFactory, authToken, appCheckToken) {
        if (!this._deleted) {
          const request = makeRequest(requestInfo, this._appId, authToken, appCheckToken, requestFactory, this._firebaseVersion);
          this._requests.add(request);
          request.getPromise().then(() => this._requests.delete(request), () => this._requests.delete(request));
          return request;
        } else {
          return new FailRequest(appDeleted());
        }
      }
      async makeRequestWithTokens(requestInfo, requestFactory) {
        const [authToken, appCheckToken] = await Promise.all([
          this._getAuthToken(),
          this._getAppCheckToken()
        ]);
        return this._makeRequest(requestInfo, requestFactory, authToken, appCheckToken).getPromise();
      }
    };
    name$12 = "@firebase/storage";
    version$12 = "0.9.0";
    STORAGE_TYPE = "storage";
    registerStorage();
    FUNCTIONS_TYPE = "functions";
    ContextProvider = class {
      constructor(authProvider, messagingProvider, appCheckProvider) {
        this.auth = null;
        this.messaging = null;
        this.appCheck = null;
        this.auth = authProvider.getImmediate({ optional: true });
        this.messaging = messagingProvider.getImmediate({
          optional: true
        });
        if (!this.auth) {
          authProvider.get().then((auth) => this.auth = auth, () => {
          });
        }
        if (!this.messaging) {
          messagingProvider.get().then((messaging) => this.messaging = messaging, () => {
          });
        }
        if (!this.appCheck) {
          appCheckProvider.get().then((appCheck) => this.appCheck = appCheck, () => {
          });
        }
      }
      async getAuthToken() {
        if (!this.auth) {
          return void 0;
        }
        try {
          const token = await this.auth.getToken();
          return token === null || token === void 0 ? void 0 : token.accessToken;
        } catch (e) {
          return void 0;
        }
      }
      async getMessagingToken() {
        if (!this.messaging || !("Notification" in self) || Notification.permission !== "granted") {
          return void 0;
        }
        try {
          return await this.messaging.getToken();
        } catch (e) {
          return void 0;
        }
      }
      async getAppCheckToken() {
        if (this.appCheck) {
          const result = await this.appCheck.getToken();
          if (result.error) {
            return null;
          }
          return result.token;
        }
        return null;
      }
      async getContext() {
        const authToken = await this.getAuthToken();
        const messagingToken = await this.getMessagingToken();
        const appCheckToken = await this.getAppCheckToken();
        return { authToken, messagingToken, appCheckToken };
      }
    };
    DEFAULT_REGION = "us-central1";
    FunctionsService = class {
      constructor(app, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain = DEFAULT_REGION, fetchImpl2) {
        this.app = app;
        this.fetchImpl = fetchImpl2;
        this.emulatorOrigin = null;
        this.contextProvider = new ContextProvider(authProvider, messagingProvider, appCheckProvider);
        this.cancelAllRequests = new Promise((resolve2) => {
          this.deleteService = () => {
            return Promise.resolve(resolve2());
          };
        });
        try {
          const url2 = new URL(regionOrCustomDomain);
          this.customDomain = url2.origin;
          this.region = DEFAULT_REGION;
        } catch (e) {
          this.customDomain = null;
          this.region = regionOrCustomDomain;
        }
      }
      _delete() {
        return this.deleteService();
      }
      _url(name22) {
        const projectId = this.app.options.projectId;
        if (this.emulatorOrigin !== null) {
          const origin = this.emulatorOrigin;
          return `${origin}/${projectId}/${this.region}/${name22}`;
        }
        if (this.customDomain !== null) {
          return `${this.customDomain}/${name22}`;
        }
        return `https://${this.region}-${projectId}.cloudfunctions.net/${name22}`;
      }
    };
    name4 = "@firebase/functions";
    version4 = "0.7.6";
    AUTH_INTERNAL_NAME = "auth-internal";
    APP_CHECK_INTERNAL_NAME = "app-check-internal";
    MESSAGING_INTERNAL_NAME = "messaging-internal";
    registerFunctions(import_node_fetch6.default, "node");
  }
});

// node_modules/@daily-co/daily-js/dist/daily-iframe.js
var require_daily_iframe = __commonJS({
  "node_modules/@daily-co/daily-js/dist/daily-iframe.js"(exports, module2) {
    init_shims();
    !function(e, t2) {
      typeof exports == "object" && typeof module2 == "object" ? module2.exports = t2() : typeof define == "function" && define.amd ? define([], t2) : typeof exports == "object" ? exports.DailyIframe = t2() : e.DailyIframe = t2();
    }(exports, function() {
      return function(e) {
        var t2 = {};
        function r(n) {
          if (t2[n])
            return t2[n].exports;
          var i = t2[n] = { i: n, l: false, exports: {} };
          return e[n].call(i.exports, i, i.exports, r), i.l = true, i.exports;
        }
        return r.m = e, r.c = t2, r.d = function(e2, t3, n) {
          r.o(e2, t3) || Object.defineProperty(e2, t3, { enumerable: true, get: n });
        }, r.r = function(e2) {
          typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        }, r.t = function(e2, t3) {
          if (1 & t3 && (e2 = r(e2)), 8 & t3)
            return e2;
          if (4 & t3 && typeof e2 == "object" && e2 && e2.__esModule)
            return e2;
          var n = Object.create(null);
          if (r.r(n), Object.defineProperty(n, "default", { enumerable: true, value: e2 }), 2 & t3 && typeof e2 != "string")
            for (var i in e2)
              r.d(n, i, function(t4) {
                return e2[t4];
              }.bind(null, i));
          return n;
        }, r.n = function(e2) {
          var t3 = e2 && e2.__esModule ? function() {
            return e2.default;
          } : function() {
            return e2;
          };
          return r.d(t3, "a", t3), t3;
        }, r.o = function(e2, t3) {
          return Object.prototype.hasOwnProperty.call(e2, t3);
        }, r.p = "", r(r.s = 65);
      }([function(e, t2, r) {
        e.exports = r(72);
      }, function(e, t2) {
        function r(e2, t3, r2, n, i, a, o) {
          try {
            var s2 = e2[a](o), c = s2.value;
          } catch (e3) {
            return void r2(e3);
          }
          s2.done ? t3(c) : Promise.resolve(c).then(n, i);
        }
        e.exports = function(e2) {
          return function() {
            var t3 = this, n = arguments;
            return new Promise(function(i, a) {
              var o = e2.apply(t3, n);
              function s2(e3) {
                r(o, i, a, s2, c, "next", e3);
              }
              function c(e3) {
                r(o, i, a, s2, c, "throw", e3);
              }
              s2(void 0);
            });
          };
        };
      }, function(e, t2, r) {
        "use strict";
        function n() {
          return !i() && typeof window != "undefined" && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : "";
        }
        function i() {
          return typeof navigator != "undefined" && navigator.product && navigator.product === "ReactNative";
        }
        function a() {
          return navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
        }
        function o() {
          return !!(navigator && navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) && function(e2, t3) {
            if (!e2 || !t3)
              return true;
            switch (e2) {
              case "Chrome":
                return t3.major >= 75;
              case "Safari":
                return RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection") && !(t3.major === 13 && t3.minor === 0 && t3.point === 0);
              case "Firefox":
                return t3.major >= 67;
            }
            return true;
          }(f(), function() {
            switch (f()) {
              case "Chrome":
                return p2();
              case "Safari":
                return v2();
              case "Firefox":
                return m();
              case "Edge":
                return function() {
                  var e2 = 0, t3 = 0;
                  if (typeof window != "undefined") {
                    var r2 = n().match(/Edge\/(\d+).(\d+)/);
                    if (r2)
                      try {
                        e2 = parseInt(r2[1]), t3 = parseInt(r2[2]);
                      } catch (e3) {
                      }
                  }
                  return { major: e2, minor: t3 };
                }();
            }
          }());
        }
        function s2() {
          if (i())
            return false;
          if (!document)
            return false;
          var e2 = document.createElement("iframe");
          return !!e2.requestFullscreen || !!e2.webkitRequestFullscreen;
        }
        r.d(t2, "b", function() {
          return n;
        }), r.d(t2, "d", function() {
          return i;
        }), r.d(t2, "e", function() {
          return o;
        }), r.d(t2, "c", function() {
          return s2;
        }), r.d(t2, "g", function() {
          return u;
        }), r.d(t2, "f", function() {
          return l2;
        }), r.d(t2, "a", function() {
          return d2;
        });
        var c = ["Chrome", "Firefox"];
        function u() {
          return !i() && (!function() {
            var e2 = n();
            if (e2.match(/Mobi/) || e2.match(/Android/))
              return true;
            if (n().match(/DailyAnd\//))
              return true;
          }() && c.includes(f()));
        }
        function l2() {
          return !!i() || d2();
        }
        function d2() {
          return a() && !function() {
            var e2, t3 = f();
            if (!n())
              return true;
            switch (t3) {
              case "Chrome":
                return (e2 = p2()).major && e2.major > 0 && e2.major < 61;
              case "Firefox":
                return (e2 = m()).major < 78;
              case "Safari":
                return (e2 = v2()).major < 12;
              default:
                return true;
            }
          }();
        }
        function f() {
          if (typeof window != "undefined") {
            var e2 = n();
            return h() ? "Safari" : e2.indexOf("Edge") > -1 ? "Edge" : e2.match(/Chrome\//) ? "Chrome" : e2.indexOf("Safari") > -1 ? "Safari" : e2.indexOf("Firefox") > -1 ? "Firefox" : e2.indexOf("MSIE") > -1 || e2.indexOf(".NET") > -1 ? "IE" : "Unknown Browser";
          }
        }
        function p2() {
          var e2 = 0, t3 = 0, r2 = 0, i2 = 0, a2 = false;
          if (typeof window != "undefined") {
            var o2 = n(), s3 = o2.match(/Chrome\/(\d+).(\d+).(\d+).(\d+)/);
            if (s3)
              try {
                e2 = parseInt(s3[1]), t3 = parseInt(s3[2]), r2 = parseInt(s3[3]), i2 = parseInt(s3[4]), a2 = o2.indexOf("OPR/") > -1;
              } catch (e3) {
              }
          }
          return { major: e2, minor: t3, build: r2, patch: i2, opera: a2 };
        }
        function h() {
          return !!n().match(/iPad|iPhone|iPod/i) && a();
        }
        function v2() {
          var e2 = 0, t3 = 0, r2 = 0;
          if (typeof window != "undefined") {
            var i2 = n().match(/Version\/(\d+).(\d+)(.(\d+))?/);
            if (i2)
              try {
                e2 = parseInt(i2[1]), t3 = parseInt(i2[2]), r2 = parseInt(i2[4]);
              } catch (e3) {
              }
            else
              h() && (e2 = 14, t3 = 0, r2 = 3);
          }
          return { major: e2, minor: t3, point: r2 };
        }
        function m() {
          var e2 = 0, t3 = 0;
          if (typeof window != "undefined") {
            var r2 = n().match(/Firefox\/(\d+).(\d+)/);
            if (r2)
              try {
                e2 = parseInt(r2[1]), t3 = parseInt(r2[2]);
              } catch (e3) {
              }
          }
          return { major: e2, minor: t3 };
        }
      }, function(e, t2, r) {
        "use strict";
        r.d(t2, "c", function() {
          return i;
        }), r.d(t2, "b", function() {
          return a;
        }), r.d(t2, "a", function() {
          return o;
        }), r.d(t2, "d", function() {
          return s2;
        });
        var n = r(2);
        function i() {
          return Date.now() + Math.random().toString();
        }
        function a() {
          throw new Error("Method must be implemented in subclass");
        }
        function o(e2) {
          var t3 = e2 ? new URL(e2).origin : null;
          return !t3 || t3.match(/https:\/\/[^.]+\.daily\.co/) ? Object(n.f)() ? "https://c.daily.co/static/call-machine-object-bundle.js" : "https://c.daily.co/static/call-machine-object-nosfu-bundle.js" : (t3 || (console.warn("No baseUrl provided for call object bundle. Defaulting to production CDN..."), t3 = "https://c.daily.co"), Object(n.f)() ? "".concat(t3, "/static/call-machine-object-bundle.js") : "".concat(t3, "/static/call-machine-object-nosfu-bundle.js"));
        }
        function s2(e2) {
          try {
            new URL(e2);
          } catch (e3) {
            return false;
          }
          return true;
        }
      }, function(e, t2) {
        function r(t3) {
          return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? e.exports = r = function(e2) {
            return typeof e2;
          } : e.exports = r = function(e2) {
            return e2 && typeof Symbol == "function" && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
          }, r(t3);
        }
        e.exports = r;
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          if (!(e2 instanceof t3))
            throw new TypeError("Cannot call a class as a function");
        };
      }, function(e, t2) {
        function r(e2, t3) {
          for (var r2 = 0; r2 < t3.length; r2++) {
            var n = t3[r2];
            n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e2, n.key, n);
          }
        }
        e.exports = function(e2, t3, n) {
          return t3 && r(e2.prototype, t3), n && r(e2, n), e2;
        };
      }, function(e, t2) {
        function r(t3) {
          return e.exports = r = Object.setPrototypeOf ? Object.getPrototypeOf : function(e2) {
            return e2.__proto__ || Object.getPrototypeOf(e2);
          }, r(t3);
        }
        e.exports = r;
      }, function(e, t2) {
        e.exports = function(e2, t3, r) {
          return t3 in e2 ? Object.defineProperty(e2, t3, { value: r, enumerable: true, configurable: true, writable: true }) : e2[t3] = r, e2;
        };
      }, function(e, t2) {
        e.exports = function(e2) {
          if (e2 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e2;
        };
      }, function(e, t2) {
        var r = Array.isArray;
        e.exports = r;
      }, function(e, t2, r) {
        var n = r(42), i = typeof self == "object" && self && self.Object === Object && self, a = n || i || Function("return this")();
        e.exports = a;
      }, function(e, t2, r) {
        var n = r(28);
        e.exports = function(e2, t3) {
          if (typeof t3 != "function" && t3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          e2.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e2, writable: true, configurable: true } }), t3 && n(e2, t3);
        };
      }, function(e, t2, r) {
        var n = r(4), i = r(9);
        e.exports = function(e2, t3) {
          return !t3 || n(t3) !== "object" && typeof t3 != "function" ? i(e2) : t3;
        };
      }, function(e, t2, r) {
        "use strict";
        var n, i = typeof Reflect == "object" ? Reflect : null, a = i && typeof i.apply == "function" ? i.apply : function(e2, t3, r2) {
          return Function.prototype.apply.call(e2, t3, r2);
        };
        n = i && typeof i.ownKeys == "function" ? i.ownKeys : Object.getOwnPropertySymbols ? function(e2) {
          return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
        } : function(e2) {
          return Object.getOwnPropertyNames(e2);
        };
        var o = Number.isNaN || function(e2) {
          return e2 != e2;
        };
        function s2() {
          s2.init.call(this);
        }
        e.exports = s2, s2.EventEmitter = s2, s2.prototype._events = void 0, s2.prototype._eventsCount = 0, s2.prototype._maxListeners = void 0;
        var c = 10;
        function u(e2) {
          if (typeof e2 != "function")
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
        }
        function l2(e2) {
          return e2._maxListeners === void 0 ? s2.defaultMaxListeners : e2._maxListeners;
        }
        function d2(e2, t3, r2, n2) {
          var i2, a2, o2, s3;
          if (u(r2), (a2 = e2._events) === void 0 ? (a2 = e2._events = Object.create(null), e2._eventsCount = 0) : (a2.newListener !== void 0 && (e2.emit("newListener", t3, r2.listener ? r2.listener : r2), a2 = e2._events), o2 = a2[t3]), o2 === void 0)
            o2 = a2[t3] = r2, ++e2._eventsCount;
          else if (typeof o2 == "function" ? o2 = a2[t3] = n2 ? [r2, o2] : [o2, r2] : n2 ? o2.unshift(r2) : o2.push(r2), (i2 = l2(e2)) > 0 && o2.length > i2 && !o2.warned) {
            o2.warned = true;
            var c2 = new Error("Possible EventEmitter memory leak detected. " + o2.length + " " + String(t3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            c2.name = "MaxListenersExceededWarning", c2.emitter = e2, c2.type = t3, c2.count = o2.length, s3 = c2, console && console.warn && console.warn(s3);
          }
          return e2;
        }
        function f() {
          if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function p2(e2, t3, r2) {
          var n2 = { fired: false, wrapFn: void 0, target: e2, type: t3, listener: r2 }, i2 = f.bind(n2);
          return i2.listener = r2, n2.wrapFn = i2, i2;
        }
        function h(e2, t3, r2) {
          var n2 = e2._events;
          if (n2 === void 0)
            return [];
          var i2 = n2[t3];
          return i2 === void 0 ? [] : typeof i2 == "function" ? r2 ? [i2.listener || i2] : [i2] : r2 ? function(e3) {
            for (var t4 = new Array(e3.length), r3 = 0; r3 < t4.length; ++r3)
              t4[r3] = e3[r3].listener || e3[r3];
            return t4;
          }(i2) : m(i2, i2.length);
        }
        function v2(e2) {
          var t3 = this._events;
          if (t3 !== void 0) {
            var r2 = t3[e2];
            if (typeof r2 == "function")
              return 1;
            if (r2 !== void 0)
              return r2.length;
          }
          return 0;
        }
        function m(e2, t3) {
          for (var r2 = new Array(t3), n2 = 0; n2 < t3; ++n2)
            r2[n2] = e2[n2];
          return r2;
        }
        Object.defineProperty(s2, "defaultMaxListeners", { enumerable: true, get: function() {
          return c;
        }, set: function(e2) {
          if (typeof e2 != "number" || e2 < 0 || o(e2))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          c = e2;
        } }), s2.init = function() {
          this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, s2.prototype.setMaxListeners = function(e2) {
          if (typeof e2 != "number" || e2 < 0 || o(e2))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          return this._maxListeners = e2, this;
        }, s2.prototype.getMaxListeners = function() {
          return l2(this);
        }, s2.prototype.emit = function(e2) {
          for (var t3 = [], r2 = 1; r2 < arguments.length; r2++)
            t3.push(arguments[r2]);
          var n2 = e2 === "error", i2 = this._events;
          if (i2 !== void 0)
            n2 = n2 && i2.error === void 0;
          else if (!n2)
            return false;
          if (n2) {
            var o2;
            if (t3.length > 0 && (o2 = t3[0]), o2 instanceof Error)
              throw o2;
            var s3 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
            throw s3.context = o2, s3;
          }
          var c2 = i2[e2];
          if (c2 === void 0)
            return false;
          if (typeof c2 == "function")
            a(c2, this, t3);
          else {
            var u2 = c2.length, l3 = m(c2, u2);
            for (r2 = 0; r2 < u2; ++r2)
              a(l3[r2], this, t3);
          }
          return true;
        }, s2.prototype.addListener = function(e2, t3) {
          return d2(this, e2, t3, false);
        }, s2.prototype.on = s2.prototype.addListener, s2.prototype.prependListener = function(e2, t3) {
          return d2(this, e2, t3, true);
        }, s2.prototype.once = function(e2, t3) {
          return u(t3), this.on(e2, p2(this, e2, t3)), this;
        }, s2.prototype.prependOnceListener = function(e2, t3) {
          return u(t3), this.prependListener(e2, p2(this, e2, t3)), this;
        }, s2.prototype.removeListener = function(e2, t3) {
          var r2, n2, i2, a2, o2;
          if (u(t3), (n2 = this._events) === void 0)
            return this;
          if ((r2 = n2[e2]) === void 0)
            return this;
          if (r2 === t3 || r2.listener === t3)
            --this._eventsCount == 0 ? this._events = Object.create(null) : (delete n2[e2], n2.removeListener && this.emit("removeListener", e2, r2.listener || t3));
          else if (typeof r2 != "function") {
            for (i2 = -1, a2 = r2.length - 1; a2 >= 0; a2--)
              if (r2[a2] === t3 || r2[a2].listener === t3) {
                o2 = r2[a2].listener, i2 = a2;
                break;
              }
            if (i2 < 0)
              return this;
            i2 === 0 ? r2.shift() : function(e3, t4) {
              for (; t4 + 1 < e3.length; t4++)
                e3[t4] = e3[t4 + 1];
              e3.pop();
            }(r2, i2), r2.length === 1 && (n2[e2] = r2[0]), n2.removeListener !== void 0 && this.emit("removeListener", e2, o2 || t3);
          }
          return this;
        }, s2.prototype.off = s2.prototype.removeListener, s2.prototype.removeAllListeners = function(e2) {
          var t3, r2, n2;
          if ((r2 = this._events) === void 0)
            return this;
          if (r2.removeListener === void 0)
            return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r2[e2] !== void 0 && (--this._eventsCount == 0 ? this._events = Object.create(null) : delete r2[e2]), this;
          if (arguments.length === 0) {
            var i2, a2 = Object.keys(r2);
            for (n2 = 0; n2 < a2.length; ++n2)
              (i2 = a2[n2]) !== "removeListener" && this.removeAllListeners(i2);
            return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
          }
          if (typeof (t3 = r2[e2]) == "function")
            this.removeListener(e2, t3);
          else if (t3 !== void 0)
            for (n2 = t3.length - 1; n2 >= 0; n2--)
              this.removeListener(e2, t3[n2]);
          return this;
        }, s2.prototype.listeners = function(e2) {
          return h(this, e2, true);
        }, s2.prototype.rawListeners = function(e2) {
          return h(this, e2, false);
        }, s2.listenerCount = function(e2, t3) {
          return typeof e2.listenerCount == "function" ? e2.listenerCount(t3) : v2.call(e2, t3);
        }, s2.prototype.listenerCount = v2, s2.prototype.eventNames = function() {
          return this._eventsCount > 0 ? n(this._events) : [];
        };
      }, function(e, t2, r) {
        var n = r(105), i = r(108);
        e.exports = function(e2, t3) {
          var r2 = i(e2, t3);
          return n(r2) ? r2 : void 0;
        };
      }, function(e, t2, r) {
        !function(e2) {
          "use strict";
          var t3 = typeof Map == "function", r2 = typeof Set == "function", n = typeof WeakSet == "function", i = Object.keys, a = function(e3, t4) {
            return e3 && typeof e3 == "object" && t4.add(e3);
          }, o = function(e3, t4, r3, n2) {
            for (var i2, a2 = 0; a2 < e3.length; a2++)
              if (r3((i2 = e3[a2])[0], t4[0], n2) && r3(i2[1], t4[1], n2))
                return true;
            return false;
          }, s2 = function(e3, t4, r3, n2) {
            for (var i2 = 0; i2 < e3.length; i2++)
              if (r3(e3[i2], t4, n2))
                return true;
            return false;
          }, c = function(e3, t4) {
            return e3 === t4 || e3 != e3 && t4 != t4;
          }, u = function(e3) {
            return e3.constructor === Object;
          }, l2 = function(e3) {
            return typeof e3.then == "function";
          }, d2 = function(e3) {
            return !(!e3.$$typeof || !e3._store);
          }, f = function(e3) {
            return function(t4) {
              var r3 = e3 || t4;
              return function(e4, t5, i2) {
                i2 === void 0 && (i2 = n ? new WeakSet() : Object.create({ _values: [], add: function(e5) {
                  this._values.push(e5);
                }, has: function(e5) {
                  return !!~this._values.indexOf(e5);
                } }));
                var o2 = i2.has(e4), s3 = i2.has(t5);
                return o2 || s3 ? o2 && s3 : (a(e4, i2), a(t5, i2), r3(e4, t5, i2));
              };
            };
          }, p2 = function(e3) {
            var t4 = [];
            return e3.forEach(function(e4, r3) {
              return t4.push([r3, e4]);
            }), t4;
          }, h = function(e3) {
            var t4 = [];
            return e3.forEach(function(e4) {
              return t4.push(e4);
            }), t4;
          }, v2 = function(e3, t4, r3, n2) {
            var a2, o2 = i(e3), u2 = i(t4);
            if (o2.length !== u2.length)
              return false;
            for (var l3 = 0; l3 < o2.length; l3++) {
              if (a2 = o2[l3], !s2(u2, a2, c))
                return false;
              if (!(a2 === "_owner" && d2(e3) && d2(t4) || r3(e3[a2], t4[a2], n2)))
                return false;
            }
            return true;
          }, m = Array.isArray, g = function(e3) {
            var n2 = typeof e3 == "function" ? e3(i2) : i2;
            function i2(e4, i3, a2) {
              if (c(e4, i3))
                return true;
              var d3 = typeof e4;
              if (d3 !== typeof i3 || d3 !== "object" || !e4 || !i3)
                return false;
              if (u(e4) && u(i3))
                return v2(e4, i3, n2, a2);
              var f2 = m(e4), g2 = m(i3);
              if (f2 || g2)
                return f2 === g2 && function(e5, t4, r3, n3) {
                  if (e5.length !== t4.length)
                    return false;
                  for (var i4 = 0; i4 < e5.length; i4++)
                    if (!r3(e5[i4], t4[i4], n3))
                      return false;
                  return true;
                }(e4, i3, n2, a2);
              var y3 = e4 instanceof Date, b2 = i3 instanceof Date;
              if (y3 || b2)
                return y3 === b2 && c(e4.getTime(), i3.getTime());
              var _2, w3, k3 = e4 instanceof RegExp, M2 = i3 instanceof RegExp;
              if (k3 || M2)
                return k3 === M2 && (w3 = i3, (_2 = e4).source === w3.source && _2.global === w3.global && _2.ignoreCase === w3.ignoreCase && _2.multiline === w3.multiline && _2.unicode === w3.unicode && _2.sticky === w3.sticky && _2.lastIndex === w3.lastIndex);
              if (l2(e4) || l2(i3))
                return e4 === i3;
              if (t3) {
                var S2 = e4 instanceof Map, E2 = i3 instanceof Map;
                if (S2 || E2)
                  return S2 === E2 && function(e5, t4, r3, n3) {
                    if (e5.size !== t4.size)
                      return false;
                    for (var i4 = p2(e5), a3 = p2(t4), s3 = 0; s3 < i4.length; s3++)
                      if (!o(a3, i4[s3], r3, n3) || !o(i4, a3[s3], r3, n3))
                        return false;
                    return true;
                  }(e4, i3, n2, a2);
              }
              if (r2) {
                var T2 = e4 instanceof Set, A3 = i3 instanceof Set;
                if (T2 || A3)
                  return T2 === A3 && function(e5, t4, r3, n3) {
                    if (e5.size !== t4.size)
                      return false;
                    for (var i4 = h(e5), a3 = h(t4), o2 = 0; o2 < i4.length; o2++)
                      if (!s2(a3, i4[o2], r3, n3) || !s2(i4, a3[o2], r3, n3))
                        return false;
                    return true;
                  }(e4, i3, n2, a2);
              }
              return v2(e4, i3, n2, a2);
            }
            return i2;
          }, y2 = g(f()), b = g(f(c)), _ = g(), w2 = g(function() {
            return c;
          }), k2 = { circularDeep: y2, circularShallow: b, createCustom: g, deep: _, sameValueZero: c, shallow: w2 };
          e2.circularDeepEqual = y2, e2.circularShallowEqual = b, e2.createCustomEqual = g, e2.deepEqual = _, e2.default = k2, e2.sameValueZeroEqual = c, e2.shallowEqual = w2, Object.defineProperty(e2, "__esModule", { value: true });
        }(t2);
      }, function(e, t2, r) {
        var n = r(19), i = r(83), a = r(84), o = n ? n.toStringTag : void 0;
        e.exports = function(e2) {
          return e2 == null ? e2 === void 0 ? "[object Undefined]" : "[object Null]" : o && o in Object(e2) ? i(e2) : a(e2);
        };
      }, function(e, t2) {
        e.exports = function(e2) {
          return e2 != null && typeof e2 == "object";
        };
      }, function(e, t2, r) {
        var n = r(11).Symbol;
        e.exports = n;
      }, function(e, t2, r) {
        var n = r(95), i = r(96), a = r(97), o = r(98), s2 = r(99);
        function c(e2) {
          var t3 = -1, r2 = e2 == null ? 0 : e2.length;
          for (this.clear(); ++t3 < r2; ) {
            var n2 = e2[t3];
            this.set(n2[0], n2[1]);
          }
        }
        c.prototype.clear = n, c.prototype.delete = i, c.prototype.get = a, c.prototype.has = o, c.prototype.set = s2, e.exports = c;
      }, function(e, t2, r) {
        var n = r(51);
        e.exports = function(e2, t3) {
          for (var r2 = e2.length; r2--; )
            if (n(e2[r2][0], t3))
              return r2;
          return -1;
        };
      }, function(e, t2, r) {
        var n = r(15)(Object, "create");
        e.exports = n;
      }, function(e, t2, r) {
        var n = r(117);
        e.exports = function(e2, t3) {
          var r2 = e2.__data__;
          return n(t3) ? r2[typeof t3 == "string" ? "string" : "hash"] : r2.map;
        };
      }, function(e, t2, r) {
        var n = r(17), i = r(18);
        e.exports = function(e2) {
          return typeof e2 == "symbol" || i(e2) && n(e2) == "[object Symbol]";
        };
      }, function(e, t2, r) {
        var n = r(24);
        e.exports = function(e2) {
          if (typeof e2 == "string" || n(e2))
            return e2;
          var t3 = e2 + "";
          return t3 == "0" && 1 / e2 == -1 / 0 ? "-0" : t3;
        };
      }, function(e, t2, r) {
        "use strict";
        r.d(t2, "a", function() {
          return c;
        });
        var n = r(5), i = r.n(n), a = r(6), o = r.n(a), s2 = r(3), c = function() {
          function e2() {
            i()(this, e2);
          }
          return o()(e2, [{ key: "addListenerForMessagesFromCallMachine", value: function(e3, t3, r2) {
            Object(s2.b)();
          } }, { key: "addListenerForMessagesFromDailyJs", value: function(e3, t3, r2) {
            Object(s2.b)();
          } }, { key: "sendMessageToCallMachine", value: function(e3, t3, r2, n2) {
            Object(s2.b)();
          } }, { key: "sendMessageToDailyJs", value: function(e3, t3, r2) {
            Object(s2.b)();
          } }, { key: "removeListener", value: function(e3) {
            Object(s2.b)();
          } }]), e2;
        }();
      }, function(e, t2, r) {
        var n = r(66), i = r(67), a = r(68), o = r(70);
        e.exports = function(e2, t3) {
          return n(e2) || i(e2, t3) || a(e2, t3) || o();
        };
      }, function(e, t2) {
        function r(t3, n) {
          return e.exports = r = Object.setPrototypeOf || function(e2, t4) {
            return e2.__proto__ = t4, e2;
          }, r(t3, n);
        }
        e.exports = r;
      }, function(e, t2, r) {
        var n = r(80), i = r(88), a = r(31);
        e.exports = function(e2) {
          return a(e2) ? n(e2) : i(e2);
        };
      }, function(e, t2) {
        e.exports = function(e2) {
          return typeof e2 == "number" && e2 > -1 && e2 % 1 == 0 && e2 <= 9007199254740991;
        };
      }, function(e, t2, r) {
        var n = r(48), i = r(30);
        e.exports = function(e2) {
          return e2 != null && i(e2.length) && !n(e2);
        };
      }, function(e, t2) {
        e.exports = function(e2) {
          var t3 = typeof e2;
          return e2 != null && (t3 == "object" || t3 == "function");
        };
      }, function(e, t2, r) {
        var n = r(15)(r(11), "Map");
        e.exports = n;
      }, function(e, t2, r) {
        var n = r(109), i = r(116), a = r(118), o = r(119), s2 = r(120);
        function c(e2) {
          var t3 = -1, r2 = e2 == null ? 0 : e2.length;
          for (this.clear(); ++t3 < r2; ) {
            var n2 = e2[t3];
            this.set(n2[0], n2[1]);
          }
        }
        c.prototype.clear = n, c.prototype.delete = i, c.prototype.get = a, c.prototype.has = o, c.prototype.set = s2, e.exports = c;
      }, function(e, t2, r) {
        var n = r(10), i = r(24), a = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, o = /^\w*$/;
        e.exports = function(e2, t3) {
          if (n(e2))
            return false;
          var r2 = typeof e2;
          return !(r2 != "number" && r2 != "symbol" && r2 != "boolean" && e2 != null && !i(e2)) || (o.test(e2) || !a.test(e2) || t3 != null && e2 in Object(t3));
        };
      }, function(e, t2, r) {
        var n = r(39), i = r(76), a = r(49), o = r(10);
        e.exports = function(e2, t3) {
          return (o(e2) ? n : i)(e2, a(t3, 3));
        };
      }, function(e, t2, r) {
        var n = r(156), i = r(10);
        e.exports = function(e2, t3, r2, a) {
          return e2 == null ? [] : (i(t3) || (t3 = t3 == null ? [] : [t3]), i(r2 = a ? void 0 : r2) || (r2 = r2 == null ? [] : [r2]), n(e2, t3, r2));
        };
      }, function(e, t2) {
        var r;
        r = function() {
          return this;
        }();
        try {
          r = r || new Function("return this")();
        } catch (e2) {
          typeof window == "object" && (r = window);
        }
        e.exports = r;
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          for (var r = -1, n = e2 == null ? 0 : e2.length, i = 0, a = []; ++r < n; ) {
            var o = e2[r];
            t3(o, r, e2) && (a[i++] = o);
          }
          return a;
        };
      }, function(e, t2, r) {
        var n = r(77), i = r(92)(n);
        e.exports = i;
      }, function(e, t2, r) {
        var n = r(82), i = r(18), a = Object.prototype, o = a.hasOwnProperty, s2 = a.propertyIsEnumerable, c = n(function() {
          return arguments;
        }()) ? n : function(e2) {
          return i(e2) && o.call(e2, "callee") && !s2.call(e2, "callee");
        };
        e.exports = c;
      }, function(e, t2, r) {
        (function(t3) {
          var r2 = typeof t3 == "object" && t3 && t3.Object === Object && t3;
          e.exports = r2;
        }).call(this, r(38));
      }, function(e, t2, r) {
        (function(e2) {
          var n = r(11), i = r(85), a = t2 && !t2.nodeType && t2, o = a && typeof e2 == "object" && e2 && !e2.nodeType && e2, s2 = o && o.exports === a ? n.Buffer : void 0, c = (s2 ? s2.isBuffer : void 0) || i;
          e2.exports = c;
        }).call(this, r(44)(e));
      }, function(e, t2) {
        e.exports = function(e2) {
          return e2.webpackPolyfill || (e2.deprecate = function() {
          }, e2.paths = [], e2.children || (e2.children = []), Object.defineProperty(e2, "loaded", { enumerable: true, get: function() {
            return e2.l;
          } }), Object.defineProperty(e2, "id", { enumerable: true, get: function() {
            return e2.i;
          } }), e2.webpackPolyfill = 1), e2;
        };
      }, function(e, t2) {
        var r = /^(?:0|[1-9]\d*)$/;
        e.exports = function(e2, t3) {
          var n = typeof e2;
          return !!(t3 = t3 == null ? 9007199254740991 : t3) && (n == "number" || n != "symbol" && r.test(e2)) && e2 > -1 && e2 % 1 == 0 && e2 < t3;
        };
      }, function(e, t2, r) {
        var n = r(86), i = r(47), a = r(87), o = a && a.isTypedArray, s2 = o ? i(o) : n;
        e.exports = s2;
      }, function(e, t2) {
        e.exports = function(e2) {
          return function(t3) {
            return e2(t3);
          };
        };
      }, function(e, t2, r) {
        var n = r(17), i = r(32);
        e.exports = function(e2) {
          if (!i(e2))
            return false;
          var t3 = n(e2);
          return t3 == "[object Function]" || t3 == "[object GeneratorFunction]" || t3 == "[object AsyncFunction]" || t3 == "[object Proxy]";
        };
      }, function(e, t2, r) {
        var n = r(93), i = r(143), a = r(60), o = r(10), s2 = r(153);
        e.exports = function(e2) {
          return typeof e2 == "function" ? e2 : e2 == null ? a : typeof e2 == "object" ? o(e2) ? i(e2[0], e2[1]) : n(e2) : s2(e2);
        };
      }, function(e, t2, r) {
        var n = r(20), i = r(100), a = r(101), o = r(102), s2 = r(103), c = r(104);
        function u(e2) {
          var t3 = this.__data__ = new n(e2);
          this.size = t3.size;
        }
        u.prototype.clear = i, u.prototype.delete = a, u.prototype.get = o, u.prototype.has = s2, u.prototype.set = c, e.exports = u;
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          return e2 === t3 || e2 != e2 && t3 != t3;
        };
      }, function(e, t2) {
        var r = Function.prototype.toString;
        e.exports = function(e2) {
          if (e2 != null) {
            try {
              return r.call(e2);
            } catch (e3) {
            }
            try {
              return e2 + "";
            } catch (e3) {
            }
          }
          return "";
        };
      }, function(e, t2, r) {
        var n = r(121), i = r(18);
        e.exports = function e2(t3, r2, a, o, s2) {
          return t3 === r2 || (t3 == null || r2 == null || !i(t3) && !i(r2) ? t3 != t3 && r2 != r2 : n(t3, r2, a, o, e2, s2));
        };
      }, function(e, t2, r) {
        var n = r(122), i = r(125), a = r(126);
        e.exports = function(e2, t3, r2, o, s2, c) {
          var u = 1 & r2, l2 = e2.length, d2 = t3.length;
          if (l2 != d2 && !(u && d2 > l2))
            return false;
          var f = c.get(e2);
          if (f && c.get(t3))
            return f == t3;
          var p2 = -1, h = true, v2 = 2 & r2 ? new n() : void 0;
          for (c.set(e2, t3), c.set(t3, e2); ++p2 < l2; ) {
            var m = e2[p2], g = t3[p2];
            if (o)
              var y2 = u ? o(g, m, p2, t3, e2, c) : o(m, g, p2, e2, t3, c);
            if (y2 !== void 0) {
              if (y2)
                continue;
              h = false;
              break;
            }
            if (v2) {
              if (!i(t3, function(e3, t4) {
                if (!a(v2, t4) && (m === e3 || s2(m, e3, r2, o, c)))
                  return v2.push(t4);
              })) {
                h = false;
                break;
              }
            } else if (m !== g && !s2(m, g, r2, o, c)) {
              h = false;
              break;
            }
          }
          return c.delete(e2), c.delete(t3), h;
        };
      }, function(e, t2, r) {
        var n = r(32);
        e.exports = function(e2) {
          return e2 == e2 && !n(e2);
        };
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          return function(r) {
            return r != null && (r[e2] === t3 && (t3 !== void 0 || e2 in Object(r)));
          };
        };
      }, function(e, t2, r) {
        var n = r(58), i = r(25);
        e.exports = function(e2, t3) {
          for (var r2 = 0, a = (t3 = n(t3, e2)).length; e2 != null && r2 < a; )
            e2 = e2[i(t3[r2++])];
          return r2 && r2 == a ? e2 : void 0;
        };
      }, function(e, t2, r) {
        var n = r(10), i = r(35), a = r(145), o = r(148);
        e.exports = function(e2, t3) {
          return n(e2) ? e2 : i(e2, t3) ? [e2] : a(o(e2));
        };
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          for (var r = -1, n = e2 == null ? 0 : e2.length, i = Array(n); ++r < n; )
            i[r] = t3(e2[r], r, e2);
          return i;
        };
      }, function(e, t2) {
        e.exports = function(e2) {
          return e2;
        };
      }, function(e, t2, r) {
        var n = r(71);
        e.exports = function(e2, t3) {
          if (e2 == null)
            return {};
          var r2, i, a = n(e2, t3);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e2);
            for (i = 0; i < o.length; i++)
              r2 = o[i], t3.indexOf(r2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, r2) && (a[r2] = e2[r2]);
          }
          return a;
        };
      }, function(e, t2, r) {
        e.exports = function(e2) {
          var t3 = {};
          function r2(n) {
            if (t3[n])
              return t3[n].exports;
            var i = t3[n] = { i: n, l: false, exports: {} };
            return e2[n].call(i.exports, i, i.exports, r2), i.l = true, i.exports;
          }
          return r2.m = e2, r2.c = t3, r2.d = function(e3, t4, n) {
            r2.o(e3, t4) || Object.defineProperty(e3, t4, { enumerable: true, get: n });
          }, r2.r = function(e3) {
            typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
          }, r2.t = function(e3, t4) {
            if (1 & t4 && (e3 = r2(e3)), 8 & t4)
              return e3;
            if (4 & t4 && typeof e3 == "object" && e3 && e3.__esModule)
              return e3;
            var n = Object.create(null);
            if (r2.r(n), Object.defineProperty(n, "default", { enumerable: true, value: e3 }), 2 & t4 && typeof e3 != "string")
              for (var i in e3)
                r2.d(n, i, function(t5) {
                  return e3[t5];
                }.bind(null, i));
            return n;
          }, r2.n = function(e3) {
            var t4 = e3 && e3.__esModule ? function() {
              return e3.default;
            } : function() {
              return e3;
            };
            return r2.d(t4, "a", t4), t4;
          }, r2.o = function(e3, t4) {
            return Object.prototype.hasOwnProperty.call(e3, t4);
          }, r2.p = "", r2(r2.s = 90);
        }({ 17: function(e2, t3, r2) {
          "use strict";
          t3.__esModule = true, t3.default = void 0;
          var n = r2(18), i = function() {
            function e3() {
            }
            return e3.getFirstMatch = function(e4, t4) {
              var r3 = t4.match(e4);
              return r3 && r3.length > 0 && r3[1] || "";
            }, e3.getSecondMatch = function(e4, t4) {
              var r3 = t4.match(e4);
              return r3 && r3.length > 1 && r3[2] || "";
            }, e3.matchAndReturnConst = function(e4, t4, r3) {
              if (e4.test(t4))
                return r3;
            }, e3.getWindowsVersionName = function(e4) {
              switch (e4) {
                case "NT":
                  return "NT";
                case "XP":
                  return "XP";
                case "NT 5.0":
                  return "2000";
                case "NT 5.1":
                  return "XP";
                case "NT 5.2":
                  return "2003";
                case "NT 6.0":
                  return "Vista";
                case "NT 6.1":
                  return "7";
                case "NT 6.2":
                  return "8";
                case "NT 6.3":
                  return "8.1";
                case "NT 10.0":
                  return "10";
                default:
                  return;
              }
            }, e3.getMacOSVersionName = function(e4) {
              var t4 = e4.split(".").splice(0, 2).map(function(e5) {
                return parseInt(e5, 10) || 0;
              });
              if (t4.push(0), t4[0] === 10)
                switch (t4[1]) {
                  case 5:
                    return "Leopard";
                  case 6:
                    return "Snow Leopard";
                  case 7:
                    return "Lion";
                  case 8:
                    return "Mountain Lion";
                  case 9:
                    return "Mavericks";
                  case 10:
                    return "Yosemite";
                  case 11:
                    return "El Capitan";
                  case 12:
                    return "Sierra";
                  case 13:
                    return "High Sierra";
                  case 14:
                    return "Mojave";
                  case 15:
                    return "Catalina";
                  default:
                    return;
                }
            }, e3.getAndroidVersionName = function(e4) {
              var t4 = e4.split(".").splice(0, 2).map(function(e5) {
                return parseInt(e5, 10) || 0;
              });
              if (t4.push(0), !(t4[0] === 1 && t4[1] < 5))
                return t4[0] === 1 && t4[1] < 6 ? "Cupcake" : t4[0] === 1 && t4[1] >= 6 ? "Donut" : t4[0] === 2 && t4[1] < 2 ? "Eclair" : t4[0] === 2 && t4[1] === 2 ? "Froyo" : t4[0] === 2 && t4[1] > 2 ? "Gingerbread" : t4[0] === 3 ? "Honeycomb" : t4[0] === 4 && t4[1] < 1 ? "Ice Cream Sandwich" : t4[0] === 4 && t4[1] < 4 ? "Jelly Bean" : t4[0] === 4 && t4[1] >= 4 ? "KitKat" : t4[0] === 5 ? "Lollipop" : t4[0] === 6 ? "Marshmallow" : t4[0] === 7 ? "Nougat" : t4[0] === 8 ? "Oreo" : t4[0] === 9 ? "Pie" : void 0;
            }, e3.getVersionPrecision = function(e4) {
              return e4.split(".").length;
            }, e3.compareVersions = function(t4, r3, n2) {
              n2 === void 0 && (n2 = false);
              var i2 = e3.getVersionPrecision(t4), a = e3.getVersionPrecision(r3), o = Math.max(i2, a), s2 = 0, c = e3.map([t4, r3], function(t5) {
                var r4 = o - e3.getVersionPrecision(t5), n3 = t5 + new Array(r4 + 1).join(".0");
                return e3.map(n3.split("."), function(e4) {
                  return new Array(20 - e4.length).join("0") + e4;
                }).reverse();
              });
              for (n2 && (s2 = o - Math.min(i2, a)), o -= 1; o >= s2; ) {
                if (c[0][o] > c[1][o])
                  return 1;
                if (c[0][o] === c[1][o]) {
                  if (o === s2)
                    return 0;
                  o -= 1;
                } else if (c[0][o] < c[1][o])
                  return -1;
              }
            }, e3.map = function(e4, t4) {
              var r3, n2 = [];
              if (Array.prototype.map)
                return Array.prototype.map.call(e4, t4);
              for (r3 = 0; r3 < e4.length; r3 += 1)
                n2.push(t4(e4[r3]));
              return n2;
            }, e3.find = function(e4, t4) {
              var r3, n2;
              if (Array.prototype.find)
                return Array.prototype.find.call(e4, t4);
              for (r3 = 0, n2 = e4.length; r3 < n2; r3 += 1) {
                var i2 = e4[r3];
                if (t4(i2, r3))
                  return i2;
              }
            }, e3.assign = function(e4) {
              for (var t4, r3, n2 = e4, i2 = arguments.length, a = new Array(i2 > 1 ? i2 - 1 : 0), o = 1; o < i2; o++)
                a[o - 1] = arguments[o];
              if (Object.assign)
                return Object.assign.apply(Object, [e4].concat(a));
              var s2 = function() {
                var e5 = a[t4];
                typeof e5 == "object" && e5 !== null && Object.keys(e5).forEach(function(t5) {
                  n2[t5] = e5[t5];
                });
              };
              for (t4 = 0, r3 = a.length; t4 < r3; t4 += 1)
                s2();
              return e4;
            }, e3.getBrowserAlias = function(e4) {
              return n.BROWSER_ALIASES_MAP[e4];
            }, e3.getBrowserTypeByAlias = function(e4) {
              return n.BROWSER_MAP[e4] || "";
            }, e3;
          }();
          t3.default = i, e2.exports = t3.default;
        }, 18: function(e2, t3, r2) {
          "use strict";
          t3.__esModule = true, t3.ENGINE_MAP = t3.OS_MAP = t3.PLATFORMS_MAP = t3.BROWSER_MAP = t3.BROWSER_ALIASES_MAP = void 0, t3.BROWSER_ALIASES_MAP = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" }, t3.BROWSER_MAP = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" }, t3.PLATFORMS_MAP = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" }, t3.OS_MAP = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" }, t3.ENGINE_MAP = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
        }, 90: function(e2, t3, r2) {
          "use strict";
          t3.__esModule = true, t3.default = void 0;
          var n, i = (n = r2(91)) && n.__esModule ? n : { default: n }, a = r2(18);
          function o(e3, t4) {
            for (var r3 = 0; r3 < t4.length; r3++) {
              var n2 = t4[r3];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
            }
          }
          var s2 = function() {
            function e3() {
            }
            var t4, r3;
            return e3.getParser = function(e4, t5) {
              if (t5 === void 0 && (t5 = false), typeof e4 != "string")
                throw new Error("UserAgent should be a string");
              return new i.default(e4, t5);
            }, e3.parse = function(e4) {
              return new i.default(e4).getResult();
            }, t4 = e3, (r3 = [{ key: "BROWSER_MAP", get: function() {
              return a.BROWSER_MAP;
            } }, { key: "ENGINE_MAP", get: function() {
              return a.ENGINE_MAP;
            } }, { key: "OS_MAP", get: function() {
              return a.OS_MAP;
            } }, { key: "PLATFORMS_MAP", get: function() {
              return a.PLATFORMS_MAP;
            } }]) && o(t4, r3), e3;
          }();
          t3.default = s2, e2.exports = t3.default;
        }, 91: function(e2, t3, r2) {
          "use strict";
          t3.__esModule = true, t3.default = void 0;
          var n = c(r2(92)), i = c(r2(93)), a = c(r2(94)), o = c(r2(95)), s2 = c(r2(17));
          function c(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }
          var u = function() {
            function e3(e4, t5) {
              if (t5 === void 0 && (t5 = false), e4 == null || e4 === "")
                throw new Error("UserAgent parameter can't be empty");
              this._ua = e4, this.parsedResult = {}, t5 !== true && this.parse();
            }
            var t4 = e3.prototype;
            return t4.getUA = function() {
              return this._ua;
            }, t4.test = function(e4) {
              return e4.test(this._ua);
            }, t4.parseBrowser = function() {
              var e4 = this;
              this.parsedResult.browser = {};
              var t5 = s2.default.find(n.default, function(t6) {
                if (typeof t6.test == "function")
                  return t6.test(e4);
                if (t6.test instanceof Array)
                  return t6.test.some(function(t7) {
                    return e4.test(t7);
                  });
                throw new Error("Browser's test function is not valid");
              });
              return t5 && (this.parsedResult.browser = t5.describe(this.getUA())), this.parsedResult.browser;
            }, t4.getBrowser = function() {
              return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
            }, t4.getBrowserName = function(e4) {
              return e4 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
            }, t4.getBrowserVersion = function() {
              return this.getBrowser().version;
            }, t4.getOS = function() {
              return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
            }, t4.parseOS = function() {
              var e4 = this;
              this.parsedResult.os = {};
              var t5 = s2.default.find(i.default, function(t6) {
                if (typeof t6.test == "function")
                  return t6.test(e4);
                if (t6.test instanceof Array)
                  return t6.test.some(function(t7) {
                    return e4.test(t7);
                  });
                throw new Error("Browser's test function is not valid");
              });
              return t5 && (this.parsedResult.os = t5.describe(this.getUA())), this.parsedResult.os;
            }, t4.getOSName = function(e4) {
              var t5 = this.getOS().name;
              return e4 ? String(t5).toLowerCase() || "" : t5 || "";
            }, t4.getOSVersion = function() {
              return this.getOS().version;
            }, t4.getPlatform = function() {
              return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
            }, t4.getPlatformType = function(e4) {
              e4 === void 0 && (e4 = false);
              var t5 = this.getPlatform().type;
              return e4 ? String(t5).toLowerCase() || "" : t5 || "";
            }, t4.parsePlatform = function() {
              var e4 = this;
              this.parsedResult.platform = {};
              var t5 = s2.default.find(a.default, function(t6) {
                if (typeof t6.test == "function")
                  return t6.test(e4);
                if (t6.test instanceof Array)
                  return t6.test.some(function(t7) {
                    return e4.test(t7);
                  });
                throw new Error("Browser's test function is not valid");
              });
              return t5 && (this.parsedResult.platform = t5.describe(this.getUA())), this.parsedResult.platform;
            }, t4.getEngine = function() {
              return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
            }, t4.getEngineName = function(e4) {
              return e4 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
            }, t4.parseEngine = function() {
              var e4 = this;
              this.parsedResult.engine = {};
              var t5 = s2.default.find(o.default, function(t6) {
                if (typeof t6.test == "function")
                  return t6.test(e4);
                if (t6.test instanceof Array)
                  return t6.test.some(function(t7) {
                    return e4.test(t7);
                  });
                throw new Error("Browser's test function is not valid");
              });
              return t5 && (this.parsedResult.engine = t5.describe(this.getUA())), this.parsedResult.engine;
            }, t4.parse = function() {
              return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
            }, t4.getResult = function() {
              return s2.default.assign({}, this.parsedResult);
            }, t4.satisfies = function(e4) {
              var t5 = this, r3 = {}, n2 = 0, i2 = {}, a2 = 0;
              if (Object.keys(e4).forEach(function(t6) {
                var o3 = e4[t6];
                typeof o3 == "string" ? (i2[t6] = o3, a2 += 1) : typeof o3 == "object" && (r3[t6] = o3, n2 += 1);
              }), n2 > 0) {
                var o2 = Object.keys(r3), c2 = s2.default.find(o2, function(e5) {
                  return t5.isOS(e5);
                });
                if (c2) {
                  var u2 = this.satisfies(r3[c2]);
                  if (u2 !== void 0)
                    return u2;
                }
                var l2 = s2.default.find(o2, function(e5) {
                  return t5.isPlatform(e5);
                });
                if (l2) {
                  var d2 = this.satisfies(r3[l2]);
                  if (d2 !== void 0)
                    return d2;
                }
              }
              if (a2 > 0) {
                var f = Object.keys(i2), p2 = s2.default.find(f, function(e5) {
                  return t5.isBrowser(e5, true);
                });
                if (p2 !== void 0)
                  return this.compareVersion(i2[p2]);
              }
            }, t4.isBrowser = function(e4, t5) {
              t5 === void 0 && (t5 = false);
              var r3 = this.getBrowserName().toLowerCase(), n2 = e4.toLowerCase(), i2 = s2.default.getBrowserTypeByAlias(n2);
              return t5 && i2 && (n2 = i2.toLowerCase()), n2 === r3;
            }, t4.compareVersion = function(e4) {
              var t5 = [0], r3 = e4, n2 = false, i2 = this.getBrowserVersion();
              if (typeof i2 == "string")
                return e4[0] === ">" || e4[0] === "<" ? (r3 = e4.substr(1), e4[1] === "=" ? (n2 = true, r3 = e4.substr(2)) : t5 = [], e4[0] === ">" ? t5.push(1) : t5.push(-1)) : e4[0] === "=" ? r3 = e4.substr(1) : e4[0] === "~" && (n2 = true, r3 = e4.substr(1)), t5.indexOf(s2.default.compareVersions(i2, r3, n2)) > -1;
            }, t4.isOS = function(e4) {
              return this.getOSName(true) === String(e4).toLowerCase();
            }, t4.isPlatform = function(e4) {
              return this.getPlatformType(true) === String(e4).toLowerCase();
            }, t4.isEngine = function(e4) {
              return this.getEngineName(true) === String(e4).toLowerCase();
            }, t4.is = function(e4) {
              return this.isBrowser(e4) || this.isOS(e4) || this.isPlatform(e4);
            }, t4.some = function(e4) {
              var t5 = this;
              return e4 === void 0 && (e4 = []), e4.some(function(e5) {
                return t5.is(e5);
              });
            }, e3;
          }();
          t3.default = u, e2.exports = t3.default;
        }, 92: function(e2, t3, r2) {
          "use strict";
          t3.__esModule = true, t3.default = void 0;
          var n, i = (n = r2(17)) && n.__esModule ? n : { default: n }, a = /version\/(\d+(\.?_?\d+)+)/i, o = [{ test: [/googlebot/i], describe: function(e3) {
            var t4 = { name: "Googlebot" }, r3 = i.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e3) || i.default.getFirstMatch(a, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/opera/i], describe: function(e3) {
            var t4 = { name: "Opera" }, r3 = i.default.getFirstMatch(a, e3) || i.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/opr\/|opios/i], describe: function(e3) {
            var t4 = { name: "Opera" }, r3 = i.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e3) || i.default.getFirstMatch(a, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/SamsungBrowser/i], describe: function(e3) {
            var t4 = { name: "Samsung Internet for Android" }, r3 = i.default.getFirstMatch(a, e3) || i.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/Whale/i], describe: function(e3) {
            var t4 = { name: "NAVER Whale Browser" }, r3 = i.default.getFirstMatch(a, e3) || i.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/MZBrowser/i], describe: function(e3) {
            var t4 = { name: "MZ Browser" }, r3 = i.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e3) || i.default.getFirstMatch(a, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/focus/i], describe: function(e3) {
            var t4 = { name: "Focus" }, r3 = i.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e3) || i.default.getFirstMatch(a, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/swing/i], describe: function(e3) {
            var t4 = { name: "Swing" }, r3 = i.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e3) || i.default.getFirstMatch(a, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/coast/i], describe: function(e3) {
            var t4 = { name: "Opera Coast" }, r3 = i.default.getFirstMatch(a, e3) || i.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/yabrowser/i], describe: function(e3) {
            var t4 = { name: "Yandex Browser" }, r3 = i.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e3) || i.default.getFirstMatch(a, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/ucbrowser/i], describe: function(e3) {
            var t4 = { name: "UC Browser" }, r3 = i.default.getFirstMatch(a, e3) || i.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/Maxthon|mxios/i], describe: function(e3) {
            var t4 = { name: "Maxthon" }, r3 = i.default.getFirstMatch(a, e3) || i.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/epiphany/i], describe: function(e3) {
            var t4 = { name: "Epiphany" }, r3 = i.default.getFirstMatch(a, e3) || i.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/puffin/i], describe: function(e3) {
            var t4 = { name: "Puffin" }, r3 = i.default.getFirstMatch(a, e3) || i.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/sleipnir/i], describe: function(e3) {
            var t4 = { name: "Sleipnir" }, r3 = i.default.getFirstMatch(a, e3) || i.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/k-meleon/i], describe: function(e3) {
            var t4 = { name: "K-Meleon" }, r3 = i.default.getFirstMatch(a, e3) || i.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/micromessenger/i], describe: function(e3) {
            var t4 = { name: "WeChat" }, r3 = i.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e3) || i.default.getFirstMatch(a, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/qqbrowser/i], describe: function(e3) {
            var t4 = { name: /qqbrowserlite/i.test(e3) ? "QQ Browser Lite" : "QQ Browser" }, r3 = i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e3) || i.default.getFirstMatch(a, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/msie|trident/i], describe: function(e3) {
            var t4 = { name: "Internet Explorer" }, r3 = i.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/\sedg\//i], describe: function(e3) {
            var t4 = { name: "Microsoft Edge" }, r3 = i.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/edg([ea]|ios)/i], describe: function(e3) {
            var t4 = { name: "Microsoft Edge" }, r3 = i.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/vivaldi/i], describe: function(e3) {
            var t4 = { name: "Vivaldi" }, r3 = i.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/seamonkey/i], describe: function(e3) {
            var t4 = { name: "SeaMonkey" }, r3 = i.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/sailfish/i], describe: function(e3) {
            var t4 = { name: "Sailfish" }, r3 = i.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/silk/i], describe: function(e3) {
            var t4 = { name: "Amazon Silk" }, r3 = i.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/phantom/i], describe: function(e3) {
            var t4 = { name: "PhantomJS" }, r3 = i.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/slimerjs/i], describe: function(e3) {
            var t4 = { name: "SlimerJS" }, r3 = i.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e3) {
            var t4 = { name: "BlackBerry" }, r3 = i.default.getFirstMatch(a, e3) || i.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/(web|hpw)[o0]s/i], describe: function(e3) {
            var t4 = { name: "WebOS Browser" }, r3 = i.default.getFirstMatch(a, e3) || i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/bada/i], describe: function(e3) {
            var t4 = { name: "Bada" }, r3 = i.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/tizen/i], describe: function(e3) {
            var t4 = { name: "Tizen" }, r3 = i.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e3) || i.default.getFirstMatch(a, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/qupzilla/i], describe: function(e3) {
            var t4 = { name: "QupZilla" }, r3 = i.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e3) || i.default.getFirstMatch(a, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/firefox|iceweasel|fxios/i], describe: function(e3) {
            var t4 = { name: "Firefox" }, r3 = i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/electron/i], describe: function(e3) {
            var t4 = { name: "Electron" }, r3 = i.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/chromium/i], describe: function(e3) {
            var t4 = { name: "Chromium" }, r3 = i.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e3) || i.default.getFirstMatch(a, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/chrome|crios|crmo/i], describe: function(e3) {
            var t4 = { name: "Chrome" }, r3 = i.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/GSA/i], describe: function(e3) {
            var t4 = { name: "Google Search" }, r3 = i.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: function(e3) {
            var t4 = !e3.test(/like android/i), r3 = e3.test(/android/i);
            return t4 && r3;
          }, describe: function(e3) {
            var t4 = { name: "Android Browser" }, r3 = i.default.getFirstMatch(a, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/playstation 4/i], describe: function(e3) {
            var t4 = { name: "PlayStation 4" }, r3 = i.default.getFirstMatch(a, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/safari|applewebkit/i], describe: function(e3) {
            var t4 = { name: "Safari" }, r3 = i.default.getFirstMatch(a, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/.*/i], describe: function(e3) {
            var t4 = e3.search("\\(") !== -1 ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
            return { name: i.default.getFirstMatch(t4, e3), version: i.default.getSecondMatch(t4, e3) };
          } }];
          t3.default = o, e2.exports = t3.default;
        }, 93: function(e2, t3, r2) {
          "use strict";
          t3.__esModule = true, t3.default = void 0;
          var n, i = (n = r2(17)) && n.__esModule ? n : { default: n }, a = r2(18), o = [{ test: [/Roku\/DVP/], describe: function(e3) {
            var t4 = i.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e3);
            return { name: a.OS_MAP.Roku, version: t4 };
          } }, { test: [/windows phone/i], describe: function(e3) {
            var t4 = i.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e3);
            return { name: a.OS_MAP.WindowsPhone, version: t4 };
          } }, { test: [/windows /i], describe: function(e3) {
            var t4 = i.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e3), r3 = i.default.getWindowsVersionName(t4);
            return { name: a.OS_MAP.Windows, version: t4, versionName: r3 };
          } }, { test: [/Macintosh(.*?) FxiOS(.*?) Version\//], describe: function(e3) {
            var t4 = i.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e3);
            return { name: a.OS_MAP.iOS, version: t4 };
          } }, { test: [/macintosh/i], describe: function(e3) {
            var t4 = i.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e3).replace(/[_\s]/g, "."), r3 = i.default.getMacOSVersionName(t4), n2 = { name: a.OS_MAP.MacOS, version: t4 };
            return r3 && (n2.versionName = r3), n2;
          } }, { test: [/(ipod|iphone|ipad)/i], describe: function(e3) {
            var t4 = i.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e3).replace(/[_\s]/g, ".");
            return { name: a.OS_MAP.iOS, version: t4 };
          } }, { test: function(e3) {
            var t4 = !e3.test(/like android/i), r3 = e3.test(/android/i);
            return t4 && r3;
          }, describe: function(e3) {
            var t4 = i.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e3), r3 = i.default.getAndroidVersionName(t4), n2 = { name: a.OS_MAP.Android, version: t4 };
            return r3 && (n2.versionName = r3), n2;
          } }, { test: [/(web|hpw)[o0]s/i], describe: function(e3) {
            var t4 = i.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e3), r3 = { name: a.OS_MAP.WebOS };
            return t4 && t4.length && (r3.version = t4), r3;
          } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e3) {
            var t4 = i.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e3) || i.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e3) || i.default.getFirstMatch(/\bbb(\d+)/i, e3);
            return { name: a.OS_MAP.BlackBerry, version: t4 };
          } }, { test: [/bada/i], describe: function(e3) {
            var t4 = i.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e3);
            return { name: a.OS_MAP.Bada, version: t4 };
          } }, { test: [/tizen/i], describe: function(e3) {
            var t4 = i.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e3);
            return { name: a.OS_MAP.Tizen, version: t4 };
          } }, { test: [/linux/i], describe: function() {
            return { name: a.OS_MAP.Linux };
          } }, { test: [/CrOS/], describe: function() {
            return { name: a.OS_MAP.ChromeOS };
          } }, { test: [/PlayStation 4/], describe: function(e3) {
            var t4 = i.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e3);
            return { name: a.OS_MAP.PlayStation4, version: t4 };
          } }];
          t3.default = o, e2.exports = t3.default;
        }, 94: function(e2, t3, r2) {
          "use strict";
          t3.__esModule = true, t3.default = void 0;
          var n, i = (n = r2(17)) && n.__esModule ? n : { default: n }, a = r2(18), o = [{ test: [/googlebot/i], describe: function() {
            return { type: "bot", vendor: "Google" };
          } }, { test: [/huawei/i], describe: function(e3) {
            var t4 = i.default.getFirstMatch(/(can-l01)/i, e3) && "Nova", r3 = { type: a.PLATFORMS_MAP.mobile, vendor: "Huawei" };
            return t4 && (r3.model = t4), r3;
          } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() {
            return { type: a.PLATFORMS_MAP.tablet, vendor: "Nexus" };
          } }, { test: [/ipad/i], describe: function() {
            return { type: a.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
          } }, { test: [/Macintosh(.*?) FxiOS(.*?) Version\//], describe: function() {
            return { type: a.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
          } }, { test: [/kftt build/i], describe: function() {
            return { type: a.PLATFORMS_MAP.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
          } }, { test: [/silk/i], describe: function() {
            return { type: a.PLATFORMS_MAP.tablet, vendor: "Amazon" };
          } }, { test: [/tablet(?! pc)/i], describe: function() {
            return { type: a.PLATFORMS_MAP.tablet };
          } }, { test: function(e3) {
            var t4 = e3.test(/ipod|iphone/i), r3 = e3.test(/like (ipod|iphone)/i);
            return t4 && !r3;
          }, describe: function(e3) {
            var t4 = i.default.getFirstMatch(/(ipod|iphone)/i, e3);
            return { type: a.PLATFORMS_MAP.mobile, vendor: "Apple", model: t4 };
          } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() {
            return { type: a.PLATFORMS_MAP.mobile, vendor: "Nexus" };
          } }, { test: [/[^-]mobi/i], describe: function() {
            return { type: a.PLATFORMS_MAP.mobile };
          } }, { test: function(e3) {
            return e3.getBrowserName(true) === "blackberry";
          }, describe: function() {
            return { type: a.PLATFORMS_MAP.mobile, vendor: "BlackBerry" };
          } }, { test: function(e3) {
            return e3.getBrowserName(true) === "bada";
          }, describe: function() {
            return { type: a.PLATFORMS_MAP.mobile };
          } }, { test: function(e3) {
            return e3.getBrowserName() === "windows phone";
          }, describe: function() {
            return { type: a.PLATFORMS_MAP.mobile, vendor: "Microsoft" };
          } }, { test: function(e3) {
            var t4 = Number(String(e3.getOSVersion()).split(".")[0]);
            return e3.getOSName(true) === "android" && t4 >= 3;
          }, describe: function() {
            return { type: a.PLATFORMS_MAP.tablet };
          } }, { test: function(e3) {
            return e3.getOSName(true) === "android";
          }, describe: function() {
            return { type: a.PLATFORMS_MAP.mobile };
          } }, { test: function(e3) {
            return e3.getOSName(true) === "macos";
          }, describe: function() {
            return { type: a.PLATFORMS_MAP.desktop, vendor: "Apple" };
          } }, { test: function(e3) {
            return e3.getOSName(true) === "windows";
          }, describe: function() {
            return { type: a.PLATFORMS_MAP.desktop };
          } }, { test: function(e3) {
            return e3.getOSName(true) === "linux";
          }, describe: function() {
            return { type: a.PLATFORMS_MAP.desktop };
          } }, { test: function(e3) {
            return e3.getOSName(true) === "playstation 4";
          }, describe: function() {
            return { type: a.PLATFORMS_MAP.tv };
          } }, { test: function(e3) {
            return e3.getOSName(true) === "roku";
          }, describe: function() {
            return { type: a.PLATFORMS_MAP.tv };
          } }];
          t3.default = o, e2.exports = t3.default;
        }, 95: function(e2, t3, r2) {
          "use strict";
          t3.__esModule = true, t3.default = void 0;
          var n, i = (n = r2(17)) && n.__esModule ? n : { default: n }, a = r2(18), o = [{ test: function(e3) {
            return e3.getBrowserName(true) === "microsoft edge";
          }, describe: function(e3) {
            if (/\sedg\//i.test(e3))
              return { name: a.ENGINE_MAP.Blink };
            var t4 = i.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e3);
            return { name: a.ENGINE_MAP.EdgeHTML, version: t4 };
          } }, { test: [/trident/i], describe: function(e3) {
            var t4 = { name: a.ENGINE_MAP.Trident }, r3 = i.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: function(e3) {
            return e3.test(/presto/i);
          }, describe: function(e3) {
            var t4 = { name: a.ENGINE_MAP.Presto }, r3 = i.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: function(e3) {
            var t4 = e3.test(/gecko/i), r3 = e3.test(/like gecko/i);
            return t4 && !r3;
          }, describe: function(e3) {
            var t4 = { name: a.ENGINE_MAP.Gecko }, r3 = i.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() {
            return { name: a.ENGINE_MAP.Blink };
          } }, { test: [/(apple)?webkit/i], describe: function(e3) {
            var t4 = { name: a.ENGINE_MAP.WebKit }, r3 = i.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e3);
            return r3 && (t4.version = r3), t4;
          } }];
          t3.default = o, e2.exports = t3.default;
        } });
      }, function(e, t2, r) {
        "use strict";
        (function(e2) {
          r.d(t2, "a", function() {
            return g;
          });
          var n = r(5), i = r.n(n), a = r(6), o = r.n(a), s2 = r(12), c = r.n(s2), u = r(13), l2 = r.n(u), d2 = r(7), f = r.n(d2), p2 = r(26), h = r(14), v2 = r(3);
          function m(e3) {
            var t3 = function() {
              if (typeof Reflect == "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy == "function")
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (e4) {
                return false;
              }
            }();
            return function() {
              var r2, n2 = f()(e3);
              if (t3) {
                var i2 = f()(this).constructor;
                r2 = Reflect.construct(n2, arguments, i2);
              } else
                r2 = n2.apply(this, arguments);
              return l2()(this, r2);
            };
          }
          e2.callMachineToDailyJsEmitter = e2.callMachineToDailyJsEmitter || new h.EventEmitter(), e2.dailyJsToCallMachineEmitter = e2.dailyJsToCallMachineEmitter || new h.EventEmitter();
          var g = function(t3) {
            c()(n2, t3);
            var r2 = m(n2);
            function n2() {
              var e3;
              return i()(this, n2), (e3 = r2.call(this))._wrappedListeners = {}, e3._messageCallbacks = {}, e3;
            }
            return o()(n2, [{ key: "addListenerForMessagesFromCallMachine", value: function(t4, r3, n3) {
              this._addListener(t4, e2.callMachineToDailyJsEmitter, n3, "received call machine message");
            } }, { key: "addListenerForMessagesFromDailyJs", value: function(t4, r3, n3) {
              this._addListener(t4, e2.dailyJsToCallMachineEmitter, n3, "received daily-js message");
            } }, { key: "sendMessageToCallMachine", value: function(t4, r3) {
              this._sendMessage(t4, e2.dailyJsToCallMachineEmitter, "sending message to call machine", r3);
            } }, { key: "sendMessageToDailyJs", value: function(t4) {
              this._sendMessage(t4, e2.callMachineToDailyJsEmitter, "sending message to daily-js");
            } }, { key: "removeListener", value: function(t4) {
              var r3 = this._wrappedListeners[t4];
              r3 && (e2.callMachineToDailyJsEmitter.removeListener("message", r3), e2.dailyJsToCallMachineEmitter.removeListener("message", r3), delete this._wrappedListeners[t4]);
            } }, { key: "_addListener", value: function(e3, t4, r3, n3) {
              var i2 = this, a2 = function(t5) {
                if (t5.callbackStamp && i2._messageCallbacks[t5.callbackStamp]) {
                  var n4 = t5.callbackStamp;
                  i2._messageCallbacks[n4].call(r3, t5), delete i2._messageCallbacks[n4];
                }
                e3.call(r3, t5);
              };
              this._wrappedListeners[e3] = a2, t4.addListener("message", a2);
            } }, { key: "_sendMessage", value: function(e3, t4, r3, n3) {
              if (n3) {
                var i2 = Object(v2.c)();
                this._messageCallbacks[i2] = n3, e3.callbackStamp = i2;
              }
              t4.emit("message", e3);
            } }]), n2;
          }(p2.a);
        }).call(this, r(38));
      }, function(e, t2, r) {
        var n = r(7), i = r(28), a = r(73), o = r(74);
        function s2(t3) {
          var r2 = typeof Map == "function" ? new Map() : void 0;
          return e.exports = s2 = function(e2) {
            if (e2 === null || !a(e2))
              return e2;
            if (typeof e2 != "function")
              throw new TypeError("Super expression must either be null or a function");
            if (r2 !== void 0) {
              if (r2.has(e2))
                return r2.get(e2);
              r2.set(e2, t4);
            }
            function t4() {
              return o(e2, arguments, n(this).constructor);
            }
            return t4.prototype = Object.create(e2.prototype, { constructor: { value: t4, enumerable: false, writable: true, configurable: true } }), i(t4, e2);
          }, s2(t3);
        }
        e.exports = s2;
      }, function(e, t2, r) {
        var n = r(161);
        e.exports = n.default;
      }, function(e, t2) {
        e.exports = function(e2) {
          if (Array.isArray(e2))
            return e2;
        };
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          if (typeof Symbol != "undefined" && Symbol.iterator in Object(e2)) {
            var r = [], n = true, i = false, a = void 0;
            try {
              for (var o, s2 = e2[Symbol.iterator](); !(n = (o = s2.next()).done) && (r.push(o.value), !t3 || r.length !== t3); n = true)
                ;
            } catch (e3) {
              i = true, a = e3;
            } finally {
              try {
                n || s2.return == null || s2.return();
              } finally {
                if (i)
                  throw a;
              }
            }
            return r;
          }
        };
      }, function(e, t2, r) {
        var n = r(69);
        e.exports = function(e2, t3) {
          if (e2) {
            if (typeof e2 == "string")
              return n(e2, t3);
            var r2 = Object.prototype.toString.call(e2).slice(8, -1);
            return r2 === "Object" && e2.constructor && (r2 = e2.constructor.name), r2 === "Map" || r2 === "Set" ? Array.from(e2) : r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? n(e2, t3) : void 0;
          }
        };
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          (t3 == null || t3 > e2.length) && (t3 = e2.length);
          for (var r = 0, n = new Array(t3); r < t3; r++)
            n[r] = e2[r];
          return n;
        };
      }, function(e, t2) {
        e.exports = function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        };
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          if (e2 == null)
            return {};
          var r, n, i = {}, a = Object.keys(e2);
          for (n = 0; n < a.length; n++)
            r = a[n], t3.indexOf(r) >= 0 || (i[r] = e2[r]);
          return i;
        };
      }, function(e, t2, r) {
        var n = function(e2) {
          "use strict";
          var t3 = Object.prototype, r2 = t3.hasOwnProperty, n2 = typeof Symbol == "function" ? Symbol : {}, i = n2.iterator || "@@iterator", a = n2.asyncIterator || "@@asyncIterator", o = n2.toStringTag || "@@toStringTag";
          function s2(e3, t4, r3) {
            return Object.defineProperty(e3, t4, { value: r3, enumerable: true, configurable: true, writable: true }), e3[t4];
          }
          try {
            s2({}, "");
          } catch (e3) {
            s2 = function(e4, t4, r3) {
              return e4[t4] = r3;
            };
          }
          function c(e3, t4, r3, n3) {
            var i2 = t4 && t4.prototype instanceof d2 ? t4 : d2, a2 = Object.create(i2.prototype), o2 = new M2(n3 || []);
            return a2._invoke = function(e4, t5, r4) {
              var n4 = "suspendedStart";
              return function(i3, a3) {
                if (n4 === "executing")
                  throw new Error("Generator is already running");
                if (n4 === "completed") {
                  if (i3 === "throw")
                    throw a3;
                  return E2();
                }
                for (r4.method = i3, r4.arg = a3; ; ) {
                  var o3 = r4.delegate;
                  if (o3) {
                    var s3 = _(o3, r4);
                    if (s3) {
                      if (s3 === l2)
                        continue;
                      return s3;
                    }
                  }
                  if (r4.method === "next")
                    r4.sent = r4._sent = r4.arg;
                  else if (r4.method === "throw") {
                    if (n4 === "suspendedStart")
                      throw n4 = "completed", r4.arg;
                    r4.dispatchException(r4.arg);
                  } else
                    r4.method === "return" && r4.abrupt("return", r4.arg);
                  n4 = "executing";
                  var c2 = u(e4, t5, r4);
                  if (c2.type === "normal") {
                    if (n4 = r4.done ? "completed" : "suspendedYield", c2.arg === l2)
                      continue;
                    return { value: c2.arg, done: r4.done };
                  }
                  c2.type === "throw" && (n4 = "completed", r4.method = "throw", r4.arg = c2.arg);
                }
              };
            }(e3, r3, o2), a2;
          }
          function u(e3, t4, r3) {
            try {
              return { type: "normal", arg: e3.call(t4, r3) };
            } catch (e4) {
              return { type: "throw", arg: e4 };
            }
          }
          e2.wrap = c;
          var l2 = {};
          function d2() {
          }
          function f() {
          }
          function p2() {
          }
          var h = {};
          h[i] = function() {
            return this;
          };
          var v2 = Object.getPrototypeOf, m = v2 && v2(v2(S2([])));
          m && m !== t3 && r2.call(m, i) && (h = m);
          var g = p2.prototype = d2.prototype = Object.create(h);
          function y2(e3) {
            ["next", "throw", "return"].forEach(function(t4) {
              s2(e3, t4, function(e4) {
                return this._invoke(t4, e4);
              });
            });
          }
          function b(e3, t4) {
            var n3;
            this._invoke = function(i2, a2) {
              function o2() {
                return new t4(function(n4, o3) {
                  !function n5(i3, a3, o4, s3) {
                    var c2 = u(e3[i3], e3, a3);
                    if (c2.type !== "throw") {
                      var l3 = c2.arg, d3 = l3.value;
                      return d3 && typeof d3 == "object" && r2.call(d3, "__await") ? t4.resolve(d3.__await).then(function(e4) {
                        n5("next", e4, o4, s3);
                      }, function(e4) {
                        n5("throw", e4, o4, s3);
                      }) : t4.resolve(d3).then(function(e4) {
                        l3.value = e4, o4(l3);
                      }, function(e4) {
                        return n5("throw", e4, o4, s3);
                      });
                    }
                    s3(c2.arg);
                  }(i2, a2, n4, o3);
                });
              }
              return n3 = n3 ? n3.then(o2, o2) : o2();
            };
          }
          function _(e3, t4) {
            var r3 = e3.iterator[t4.method];
            if (r3 === void 0) {
              if (t4.delegate = null, t4.method === "throw") {
                if (e3.iterator.return && (t4.method = "return", t4.arg = void 0, _(e3, t4), t4.method === "throw"))
                  return l2;
                t4.method = "throw", t4.arg = new TypeError("The iterator does not provide a 'throw' method");
              }
              return l2;
            }
            var n3 = u(r3, e3.iterator, t4.arg);
            if (n3.type === "throw")
              return t4.method = "throw", t4.arg = n3.arg, t4.delegate = null, l2;
            var i2 = n3.arg;
            return i2 ? i2.done ? (t4[e3.resultName] = i2.value, t4.next = e3.nextLoc, t4.method !== "return" && (t4.method = "next", t4.arg = void 0), t4.delegate = null, l2) : i2 : (t4.method = "throw", t4.arg = new TypeError("iterator result is not an object"), t4.delegate = null, l2);
          }
          function w2(e3) {
            var t4 = { tryLoc: e3[0] };
            1 in e3 && (t4.catchLoc = e3[1]), 2 in e3 && (t4.finallyLoc = e3[2], t4.afterLoc = e3[3]), this.tryEntries.push(t4);
          }
          function k2(e3) {
            var t4 = e3.completion || {};
            t4.type = "normal", delete t4.arg, e3.completion = t4;
          }
          function M2(e3) {
            this.tryEntries = [{ tryLoc: "root" }], e3.forEach(w2, this), this.reset(true);
          }
          function S2(e3) {
            if (e3) {
              var t4 = e3[i];
              if (t4)
                return t4.call(e3);
              if (typeof e3.next == "function")
                return e3;
              if (!isNaN(e3.length)) {
                var n3 = -1, a2 = function t5() {
                  for (; ++n3 < e3.length; )
                    if (r2.call(e3, n3))
                      return t5.value = e3[n3], t5.done = false, t5;
                  return t5.value = void 0, t5.done = true, t5;
                };
                return a2.next = a2;
              }
            }
            return { next: E2 };
          }
          function E2() {
            return { value: void 0, done: true };
          }
          return f.prototype = g.constructor = p2, p2.constructor = f, f.displayName = s2(p2, o, "GeneratorFunction"), e2.isGeneratorFunction = function(e3) {
            var t4 = typeof e3 == "function" && e3.constructor;
            return !!t4 && (t4 === f || (t4.displayName || t4.name) === "GeneratorFunction");
          }, e2.mark = function(e3) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e3, p2) : (e3.__proto__ = p2, s2(e3, o, "GeneratorFunction")), e3.prototype = Object.create(g), e3;
          }, e2.awrap = function(e3) {
            return { __await: e3 };
          }, y2(b.prototype), b.prototype[a] = function() {
            return this;
          }, e2.AsyncIterator = b, e2.async = function(t4, r3, n3, i2, a2) {
            a2 === void 0 && (a2 = Promise);
            var o2 = new b(c(t4, r3, n3, i2), a2);
            return e2.isGeneratorFunction(r3) ? o2 : o2.next().then(function(e3) {
              return e3.done ? e3.value : o2.next();
            });
          }, y2(g), s2(g, o, "Generator"), g[i] = function() {
            return this;
          }, g.toString = function() {
            return "[object Generator]";
          }, e2.keys = function(e3) {
            var t4 = [];
            for (var r3 in e3)
              t4.push(r3);
            return t4.reverse(), function r4() {
              for (; t4.length; ) {
                var n3 = t4.pop();
                if (n3 in e3)
                  return r4.value = n3, r4.done = false, r4;
              }
              return r4.done = true, r4;
            };
          }, e2.values = S2, M2.prototype = { constructor: M2, reset: function(e3) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(k2), !e3)
              for (var t4 in this)
                t4.charAt(0) === "t" && r2.call(this, t4) && !isNaN(+t4.slice(1)) && (this[t4] = void 0);
          }, stop: function() {
            this.done = true;
            var e3 = this.tryEntries[0].completion;
            if (e3.type === "throw")
              throw e3.arg;
            return this.rval;
          }, dispatchException: function(e3) {
            if (this.done)
              throw e3;
            var t4 = this;
            function n3(r3, n4) {
              return o2.type = "throw", o2.arg = e3, t4.next = r3, n4 && (t4.method = "next", t4.arg = void 0), !!n4;
            }
            for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
              var a2 = this.tryEntries[i2], o2 = a2.completion;
              if (a2.tryLoc === "root")
                return n3("end");
              if (a2.tryLoc <= this.prev) {
                var s3 = r2.call(a2, "catchLoc"), c2 = r2.call(a2, "finallyLoc");
                if (s3 && c2) {
                  if (this.prev < a2.catchLoc)
                    return n3(a2.catchLoc, true);
                  if (this.prev < a2.finallyLoc)
                    return n3(a2.finallyLoc);
                } else if (s3) {
                  if (this.prev < a2.catchLoc)
                    return n3(a2.catchLoc, true);
                } else {
                  if (!c2)
                    throw new Error("try statement without catch or finally");
                  if (this.prev < a2.finallyLoc)
                    return n3(a2.finallyLoc);
                }
              }
            }
          }, abrupt: function(e3, t4) {
            for (var n3 = this.tryEntries.length - 1; n3 >= 0; --n3) {
              var i2 = this.tryEntries[n3];
              if (i2.tryLoc <= this.prev && r2.call(i2, "finallyLoc") && this.prev < i2.finallyLoc) {
                var a2 = i2;
                break;
              }
            }
            a2 && (e3 === "break" || e3 === "continue") && a2.tryLoc <= t4 && t4 <= a2.finallyLoc && (a2 = null);
            var o2 = a2 ? a2.completion : {};
            return o2.type = e3, o2.arg = t4, a2 ? (this.method = "next", this.next = a2.finallyLoc, l2) : this.complete(o2);
          }, complete: function(e3, t4) {
            if (e3.type === "throw")
              throw e3.arg;
            return e3.type === "break" || e3.type === "continue" ? this.next = e3.arg : e3.type === "return" ? (this.rval = this.arg = e3.arg, this.method = "return", this.next = "end") : e3.type === "normal" && t4 && (this.next = t4), l2;
          }, finish: function(e3) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r3 = this.tryEntries[t4];
              if (r3.finallyLoc === e3)
                return this.complete(r3.completion, r3.afterLoc), k2(r3), l2;
            }
          }, catch: function(e3) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r3 = this.tryEntries[t4];
              if (r3.tryLoc === e3) {
                var n3 = r3.completion;
                if (n3.type === "throw") {
                  var i2 = n3.arg;
                  k2(r3);
                }
                return i2;
              }
            }
            throw new Error("illegal catch attempt");
          }, delegateYield: function(e3, t4, r3) {
            return this.delegate = { iterator: S2(e3), resultName: t4, nextLoc: r3 }, this.method === "next" && (this.arg = void 0), l2;
          } }, e2;
        }(e.exports);
        try {
          regeneratorRuntime = n;
        } catch (e2) {
          Function("r", "regeneratorRuntime = r")(n);
        }
      }, function(e, t2) {
        e.exports = function(e2) {
          return Function.toString.call(e2).indexOf("[native code]") !== -1;
        };
      }, function(e, t2, r) {
        var n = r(28), i = r(75);
        function a(t3, r2, o) {
          return i() ? e.exports = a = Reflect.construct : e.exports = a = function(e2, t4, r3) {
            var i2 = [null];
            i2.push.apply(i2, t4);
            var a2 = new (Function.bind.apply(e2, i2))();
            return r3 && n(a2, r3.prototype), a2;
          }, a.apply(null, arguments);
        }
        e.exports = a;
      }, function(e, t2) {
        e.exports = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (e2) {
            return false;
          }
        };
      }, function(e, t2, r) {
        var n = r(40);
        e.exports = function(e2, t3) {
          var r2 = [];
          return n(e2, function(e3, n2, i) {
            t3(e3, n2, i) && r2.push(e3);
          }), r2;
        };
      }, function(e, t2, r) {
        var n = r(78), i = r(29);
        e.exports = function(e2, t3) {
          return e2 && n(e2, t3, i);
        };
      }, function(e, t2, r) {
        var n = r(79)();
        e.exports = n;
      }, function(e, t2) {
        e.exports = function(e2) {
          return function(t3, r, n) {
            for (var i = -1, a = Object(t3), o = n(t3), s2 = o.length; s2--; ) {
              var c = o[e2 ? s2 : ++i];
              if (r(a[c], c, a) === false)
                break;
            }
            return t3;
          };
        };
      }, function(e, t2, r) {
        var n = r(81), i = r(41), a = r(10), o = r(43), s2 = r(45), c = r(46), u = Object.prototype.hasOwnProperty;
        e.exports = function(e2, t3) {
          var r2 = a(e2), l2 = !r2 && i(e2), d2 = !r2 && !l2 && o(e2), f = !r2 && !l2 && !d2 && c(e2), p2 = r2 || l2 || d2 || f, h = p2 ? n(e2.length, String) : [], v2 = h.length;
          for (var m in e2)
            !t3 && !u.call(e2, m) || p2 && (m == "length" || d2 && (m == "offset" || m == "parent") || f && (m == "buffer" || m == "byteLength" || m == "byteOffset") || s2(m, v2)) || h.push(m);
          return h;
        };
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          for (var r = -1, n = Array(e2); ++r < e2; )
            n[r] = t3(r);
          return n;
        };
      }, function(e, t2, r) {
        var n = r(17), i = r(18);
        e.exports = function(e2) {
          return i(e2) && n(e2) == "[object Arguments]";
        };
      }, function(e, t2, r) {
        var n = r(19), i = Object.prototype, a = i.hasOwnProperty, o = i.toString, s2 = n ? n.toStringTag : void 0;
        e.exports = function(e2) {
          var t3 = a.call(e2, s2), r2 = e2[s2];
          try {
            e2[s2] = void 0;
            var n2 = true;
          } catch (e3) {
          }
          var i2 = o.call(e2);
          return n2 && (t3 ? e2[s2] = r2 : delete e2[s2]), i2;
        };
      }, function(e, t2) {
        var r = Object.prototype.toString;
        e.exports = function(e2) {
          return r.call(e2);
        };
      }, function(e, t2) {
        e.exports = function() {
          return false;
        };
      }, function(e, t2, r) {
        var n = r(17), i = r(30), a = r(18), o = {};
        o["[object Float32Array]"] = o["[object Float64Array]"] = o["[object Int8Array]"] = o["[object Int16Array]"] = o["[object Int32Array]"] = o["[object Uint8Array]"] = o["[object Uint8ClampedArray]"] = o["[object Uint16Array]"] = o["[object Uint32Array]"] = true, o["[object Arguments]"] = o["[object Array]"] = o["[object ArrayBuffer]"] = o["[object Boolean]"] = o["[object DataView]"] = o["[object Date]"] = o["[object Error]"] = o["[object Function]"] = o["[object Map]"] = o["[object Number]"] = o["[object Object]"] = o["[object RegExp]"] = o["[object Set]"] = o["[object String]"] = o["[object WeakMap]"] = false, e.exports = function(e2) {
          return a(e2) && i(e2.length) && !!o[n(e2)];
        };
      }, function(e, t2, r) {
        (function(e2) {
          var n = r(42), i = t2 && !t2.nodeType && t2, a = i && typeof e2 == "object" && e2 && !e2.nodeType && e2, o = a && a.exports === i && n.process, s2 = function() {
            try {
              var e3 = a && a.require && a.require("util").types;
              return e3 || o && o.binding && o.binding("util");
            } catch (e4) {
            }
          }();
          e2.exports = s2;
        }).call(this, r(44)(e));
      }, function(e, t2, r) {
        var n = r(89), i = r(90), a = Object.prototype.hasOwnProperty;
        e.exports = function(e2) {
          if (!n(e2))
            return i(e2);
          var t3 = [];
          for (var r2 in Object(e2))
            a.call(e2, r2) && r2 != "constructor" && t3.push(r2);
          return t3;
        };
      }, function(e, t2) {
        var r = Object.prototype;
        e.exports = function(e2) {
          var t3 = e2 && e2.constructor;
          return e2 === (typeof t3 == "function" && t3.prototype || r);
        };
      }, function(e, t2, r) {
        var n = r(91)(Object.keys, Object);
        e.exports = n;
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          return function(r) {
            return e2(t3(r));
          };
        };
      }, function(e, t2, r) {
        var n = r(31);
        e.exports = function(e2, t3) {
          return function(r2, i) {
            if (r2 == null)
              return r2;
            if (!n(r2))
              return e2(r2, i);
            for (var a = r2.length, o = t3 ? a : -1, s2 = Object(r2); (t3 ? o-- : ++o < a) && i(s2[o], o, s2) !== false; )
              ;
            return r2;
          };
        };
      }, function(e, t2, r) {
        var n = r(94), i = r(142), a = r(56);
        e.exports = function(e2) {
          var t3 = i(e2);
          return t3.length == 1 && t3[0][2] ? a(t3[0][0], t3[0][1]) : function(r2) {
            return r2 === e2 || n(r2, e2, t3);
          };
        };
      }, function(e, t2, r) {
        var n = r(50), i = r(53);
        e.exports = function(e2, t3, r2, a) {
          var o = r2.length, s2 = o, c = !a;
          if (e2 == null)
            return !s2;
          for (e2 = Object(e2); o--; ) {
            var u = r2[o];
            if (c && u[2] ? u[1] !== e2[u[0]] : !(u[0] in e2))
              return false;
          }
          for (; ++o < s2; ) {
            var l2 = (u = r2[o])[0], d2 = e2[l2], f = u[1];
            if (c && u[2]) {
              if (d2 === void 0 && !(l2 in e2))
                return false;
            } else {
              var p2 = new n();
              if (a)
                var h = a(d2, f, l2, e2, t3, p2);
              if (!(h === void 0 ? i(f, d2, 3, a, p2) : h))
                return false;
            }
          }
          return true;
        };
      }, function(e, t2) {
        e.exports = function() {
          this.__data__ = [], this.size = 0;
        };
      }, function(e, t2, r) {
        var n = r(21), i = Array.prototype.splice;
        e.exports = function(e2) {
          var t3 = this.__data__, r2 = n(t3, e2);
          return !(r2 < 0) && (r2 == t3.length - 1 ? t3.pop() : i.call(t3, r2, 1), --this.size, true);
        };
      }, function(e, t2, r) {
        var n = r(21);
        e.exports = function(e2) {
          var t3 = this.__data__, r2 = n(t3, e2);
          return r2 < 0 ? void 0 : t3[r2][1];
        };
      }, function(e, t2, r) {
        var n = r(21);
        e.exports = function(e2) {
          return n(this.__data__, e2) > -1;
        };
      }, function(e, t2, r) {
        var n = r(21);
        e.exports = function(e2, t3) {
          var r2 = this.__data__, i = n(r2, e2);
          return i < 0 ? (++this.size, r2.push([e2, t3])) : r2[i][1] = t3, this;
        };
      }, function(e, t2, r) {
        var n = r(20);
        e.exports = function() {
          this.__data__ = new n(), this.size = 0;
        };
      }, function(e, t2) {
        e.exports = function(e2) {
          var t3 = this.__data__, r = t3.delete(e2);
          return this.size = t3.size, r;
        };
      }, function(e, t2) {
        e.exports = function(e2) {
          return this.__data__.get(e2);
        };
      }, function(e, t2) {
        e.exports = function(e2) {
          return this.__data__.has(e2);
        };
      }, function(e, t2, r) {
        var n = r(20), i = r(33), a = r(34);
        e.exports = function(e2, t3) {
          var r2 = this.__data__;
          if (r2 instanceof n) {
            var o = r2.__data__;
            if (!i || o.length < 199)
              return o.push([e2, t3]), this.size = ++r2.size, this;
            r2 = this.__data__ = new a(o);
          }
          return r2.set(e2, t3), this.size = r2.size, this;
        };
      }, function(e, t2, r) {
        var n = r(48), i = r(106), a = r(32), o = r(52), s2 = /^\[object .+?Constructor\]$/, c = Function.prototype, u = Object.prototype, l2 = c.toString, d2 = u.hasOwnProperty, f = RegExp("^" + l2.call(d2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        e.exports = function(e2) {
          return !(!a(e2) || i(e2)) && (n(e2) ? f : s2).test(o(e2));
        };
      }, function(e, t2, r) {
        var n, i = r(107), a = (n = /[^.]+$/.exec(i && i.keys && i.keys.IE_PROTO || "")) ? "Symbol(src)_1." + n : "";
        e.exports = function(e2) {
          return !!a && a in e2;
        };
      }, function(e, t2, r) {
        var n = r(11)["__core-js_shared__"];
        e.exports = n;
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          return e2 == null ? void 0 : e2[t3];
        };
      }, function(e, t2, r) {
        var n = r(110), i = r(20), a = r(33);
        e.exports = function() {
          this.size = 0, this.__data__ = { hash: new n(), map: new (a || i)(), string: new n() };
        };
      }, function(e, t2, r) {
        var n = r(111), i = r(112), a = r(113), o = r(114), s2 = r(115);
        function c(e2) {
          var t3 = -1, r2 = e2 == null ? 0 : e2.length;
          for (this.clear(); ++t3 < r2; ) {
            var n2 = e2[t3];
            this.set(n2[0], n2[1]);
          }
        }
        c.prototype.clear = n, c.prototype.delete = i, c.prototype.get = a, c.prototype.has = o, c.prototype.set = s2, e.exports = c;
      }, function(e, t2, r) {
        var n = r(22);
        e.exports = function() {
          this.__data__ = n ? n(null) : {}, this.size = 0;
        };
      }, function(e, t2) {
        e.exports = function(e2) {
          var t3 = this.has(e2) && delete this.__data__[e2];
          return this.size -= t3 ? 1 : 0, t3;
        };
      }, function(e, t2, r) {
        var n = r(22), i = Object.prototype.hasOwnProperty;
        e.exports = function(e2) {
          var t3 = this.__data__;
          if (n) {
            var r2 = t3[e2];
            return r2 === "__lodash_hash_undefined__" ? void 0 : r2;
          }
          return i.call(t3, e2) ? t3[e2] : void 0;
        };
      }, function(e, t2, r) {
        var n = r(22), i = Object.prototype.hasOwnProperty;
        e.exports = function(e2) {
          var t3 = this.__data__;
          return n ? t3[e2] !== void 0 : i.call(t3, e2);
        };
      }, function(e, t2, r) {
        var n = r(22);
        e.exports = function(e2, t3) {
          var r2 = this.__data__;
          return this.size += this.has(e2) ? 0 : 1, r2[e2] = n && t3 === void 0 ? "__lodash_hash_undefined__" : t3, this;
        };
      }, function(e, t2, r) {
        var n = r(23);
        e.exports = function(e2) {
          var t3 = n(this, e2).delete(e2);
          return this.size -= t3 ? 1 : 0, t3;
        };
      }, function(e, t2) {
        e.exports = function(e2) {
          var t3 = typeof e2;
          return t3 == "string" || t3 == "number" || t3 == "symbol" || t3 == "boolean" ? e2 !== "__proto__" : e2 === null;
        };
      }, function(e, t2, r) {
        var n = r(23);
        e.exports = function(e2) {
          return n(this, e2).get(e2);
        };
      }, function(e, t2, r) {
        var n = r(23);
        e.exports = function(e2) {
          return n(this, e2).has(e2);
        };
      }, function(e, t2, r) {
        var n = r(23);
        e.exports = function(e2, t3) {
          var r2 = n(this, e2), i = r2.size;
          return r2.set(e2, t3), this.size += r2.size == i ? 0 : 1, this;
        };
      }, function(e, t2, r) {
        var n = r(50), i = r(54), a = r(127), o = r(131), s2 = r(137), c = r(10), u = r(43), l2 = r(46), d2 = "[object Object]", f = Object.prototype.hasOwnProperty;
        e.exports = function(e2, t3, r2, p2, h, v2) {
          var m = c(e2), g = c(t3), y2 = m ? "[object Array]" : s2(e2), b = g ? "[object Array]" : s2(t3), _ = (y2 = y2 == "[object Arguments]" ? d2 : y2) == d2, w2 = (b = b == "[object Arguments]" ? d2 : b) == d2, k2 = y2 == b;
          if (k2 && u(e2)) {
            if (!u(t3))
              return false;
            m = true, _ = false;
          }
          if (k2 && !_)
            return v2 || (v2 = new n()), m || l2(e2) ? i(e2, t3, r2, p2, h, v2) : a(e2, t3, y2, r2, p2, h, v2);
          if (!(1 & r2)) {
            var M2 = _ && f.call(e2, "__wrapped__"), S2 = w2 && f.call(t3, "__wrapped__");
            if (M2 || S2) {
              var E2 = M2 ? e2.value() : e2, T2 = S2 ? t3.value() : t3;
              return v2 || (v2 = new n()), h(E2, T2, r2, p2, v2);
            }
          }
          return !!k2 && (v2 || (v2 = new n()), o(e2, t3, r2, p2, h, v2));
        };
      }, function(e, t2, r) {
        var n = r(34), i = r(123), a = r(124);
        function o(e2) {
          var t3 = -1, r2 = e2 == null ? 0 : e2.length;
          for (this.__data__ = new n(); ++t3 < r2; )
            this.add(e2[t3]);
        }
        o.prototype.add = o.prototype.push = i, o.prototype.has = a, e.exports = o;
      }, function(e, t2) {
        e.exports = function(e2) {
          return this.__data__.set(e2, "__lodash_hash_undefined__"), this;
        };
      }, function(e, t2) {
        e.exports = function(e2) {
          return this.__data__.has(e2);
        };
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          for (var r = -1, n = e2 == null ? 0 : e2.length; ++r < n; )
            if (t3(e2[r], r, e2))
              return true;
          return false;
        };
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          return e2.has(t3);
        };
      }, function(e, t2, r) {
        var n = r(19), i = r(128), a = r(51), o = r(54), s2 = r(129), c = r(130), u = n ? n.prototype : void 0, l2 = u ? u.valueOf : void 0;
        e.exports = function(e2, t3, r2, n2, u2, d2, f) {
          switch (r2) {
            case "[object DataView]":
              if (e2.byteLength != t3.byteLength || e2.byteOffset != t3.byteOffset)
                return false;
              e2 = e2.buffer, t3 = t3.buffer;
            case "[object ArrayBuffer]":
              return !(e2.byteLength != t3.byteLength || !d2(new i(e2), new i(t3)));
            case "[object Boolean]":
            case "[object Date]":
            case "[object Number]":
              return a(+e2, +t3);
            case "[object Error]":
              return e2.name == t3.name && e2.message == t3.message;
            case "[object RegExp]":
            case "[object String]":
              return e2 == t3 + "";
            case "[object Map]":
              var p2 = s2;
            case "[object Set]":
              var h = 1 & n2;
              if (p2 || (p2 = c), e2.size != t3.size && !h)
                return false;
              var v2 = f.get(e2);
              if (v2)
                return v2 == t3;
              n2 |= 2, f.set(e2, t3);
              var m = o(p2(e2), p2(t3), n2, u2, d2, f);
              return f.delete(e2), m;
            case "[object Symbol]":
              if (l2)
                return l2.call(e2) == l2.call(t3);
          }
          return false;
        };
      }, function(e, t2, r) {
        var n = r(11).Uint8Array;
        e.exports = n;
      }, function(e, t2) {
        e.exports = function(e2) {
          var t3 = -1, r = Array(e2.size);
          return e2.forEach(function(e3, n) {
            r[++t3] = [n, e3];
          }), r;
        };
      }, function(e, t2) {
        e.exports = function(e2) {
          var t3 = -1, r = Array(e2.size);
          return e2.forEach(function(e3) {
            r[++t3] = e3;
          }), r;
        };
      }, function(e, t2, r) {
        var n = r(132), i = Object.prototype.hasOwnProperty;
        e.exports = function(e2, t3, r2, a, o, s2) {
          var c = 1 & r2, u = n(e2), l2 = u.length;
          if (l2 != n(t3).length && !c)
            return false;
          for (var d2 = l2; d2--; ) {
            var f = u[d2];
            if (!(c ? f in t3 : i.call(t3, f)))
              return false;
          }
          var p2 = s2.get(e2);
          if (p2 && s2.get(t3))
            return p2 == t3;
          var h = true;
          s2.set(e2, t3), s2.set(t3, e2);
          for (var v2 = c; ++d2 < l2; ) {
            var m = e2[f = u[d2]], g = t3[f];
            if (a)
              var y2 = c ? a(g, m, f, t3, e2, s2) : a(m, g, f, e2, t3, s2);
            if (!(y2 === void 0 ? m === g || o(m, g, r2, a, s2) : y2)) {
              h = false;
              break;
            }
            v2 || (v2 = f == "constructor");
          }
          if (h && !v2) {
            var b = e2.constructor, _ = t3.constructor;
            b != _ && "constructor" in e2 && "constructor" in t3 && !(typeof b == "function" && b instanceof b && typeof _ == "function" && _ instanceof _) && (h = false);
          }
          return s2.delete(e2), s2.delete(t3), h;
        };
      }, function(e, t2, r) {
        var n = r(133), i = r(135), a = r(29);
        e.exports = function(e2) {
          return n(e2, a, i);
        };
      }, function(e, t2, r) {
        var n = r(134), i = r(10);
        e.exports = function(e2, t3, r2) {
          var a = t3(e2);
          return i(e2) ? a : n(a, r2(e2));
        };
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          for (var r = -1, n = t3.length, i = e2.length; ++r < n; )
            e2[i + r] = t3[r];
          return e2;
        };
      }, function(e, t2, r) {
        var n = r(39), i = r(136), a = Object.prototype.propertyIsEnumerable, o = Object.getOwnPropertySymbols, s2 = o ? function(e2) {
          return e2 == null ? [] : (e2 = Object(e2), n(o(e2), function(t3) {
            return a.call(e2, t3);
          }));
        } : i;
        e.exports = s2;
      }, function(e, t2) {
        e.exports = function() {
          return [];
        };
      }, function(e, t2, r) {
        var n = r(138), i = r(33), a = r(139), o = r(140), s2 = r(141), c = r(17), u = r(52), l2 = u(n), d2 = u(i), f = u(a), p2 = u(o), h = u(s2), v2 = c;
        (n && v2(new n(new ArrayBuffer(1))) != "[object DataView]" || i && v2(new i()) != "[object Map]" || a && v2(a.resolve()) != "[object Promise]" || o && v2(new o()) != "[object Set]" || s2 && v2(new s2()) != "[object WeakMap]") && (v2 = function(e2) {
          var t3 = c(e2), r2 = t3 == "[object Object]" ? e2.constructor : void 0, n2 = r2 ? u(r2) : "";
          if (n2)
            switch (n2) {
              case l2:
                return "[object DataView]";
              case d2:
                return "[object Map]";
              case f:
                return "[object Promise]";
              case p2:
                return "[object Set]";
              case h:
                return "[object WeakMap]";
            }
          return t3;
        }), e.exports = v2;
      }, function(e, t2, r) {
        var n = r(15)(r(11), "DataView");
        e.exports = n;
      }, function(e, t2, r) {
        var n = r(15)(r(11), "Promise");
        e.exports = n;
      }, function(e, t2, r) {
        var n = r(15)(r(11), "Set");
        e.exports = n;
      }, function(e, t2, r) {
        var n = r(15)(r(11), "WeakMap");
        e.exports = n;
      }, function(e, t2, r) {
        var n = r(55), i = r(29);
        e.exports = function(e2) {
          for (var t3 = i(e2), r2 = t3.length; r2--; ) {
            var a = t3[r2], o = e2[a];
            t3[r2] = [a, o, n(o)];
          }
          return t3;
        };
      }, function(e, t2, r) {
        var n = r(53), i = r(144), a = r(150), o = r(35), s2 = r(55), c = r(56), u = r(25);
        e.exports = function(e2, t3) {
          return o(e2) && s2(t3) ? c(u(e2), t3) : function(r2) {
            var o2 = i(r2, e2);
            return o2 === void 0 && o2 === t3 ? a(r2, e2) : n(t3, o2, 3);
          };
        };
      }, function(e, t2, r) {
        var n = r(57);
        e.exports = function(e2, t3, r2) {
          var i = e2 == null ? void 0 : n(e2, t3);
          return i === void 0 ? r2 : i;
        };
      }, function(e, t2, r) {
        var n = r(146), i = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, a = /\\(\\)?/g, o = n(function(e2) {
          var t3 = [];
          return e2.charCodeAt(0) === 46 && t3.push(""), e2.replace(i, function(e3, r2, n2, i2) {
            t3.push(n2 ? i2.replace(a, "$1") : r2 || e3);
          }), t3;
        });
        e.exports = o;
      }, function(e, t2, r) {
        var n = r(147);
        e.exports = function(e2) {
          var t3 = n(e2, function(e3) {
            return r2.size === 500 && r2.clear(), e3;
          }), r2 = t3.cache;
          return t3;
        };
      }, function(e, t2, r) {
        var n = r(34);
        function i(e2, t3) {
          if (typeof e2 != "function" || t3 != null && typeof t3 != "function")
            throw new TypeError("Expected a function");
          var r2 = function() {
            var n2 = arguments, i2 = t3 ? t3.apply(this, n2) : n2[0], a = r2.cache;
            if (a.has(i2))
              return a.get(i2);
            var o = e2.apply(this, n2);
            return r2.cache = a.set(i2, o) || a, o;
          };
          return r2.cache = new (i.Cache || n)(), r2;
        }
        i.Cache = n, e.exports = i;
      }, function(e, t2, r) {
        var n = r(149);
        e.exports = function(e2) {
          return e2 == null ? "" : n(e2);
        };
      }, function(e, t2, r) {
        var n = r(19), i = r(59), a = r(10), o = r(24), s2 = n ? n.prototype : void 0, c = s2 ? s2.toString : void 0;
        e.exports = function e2(t3) {
          if (typeof t3 == "string")
            return t3;
          if (a(t3))
            return i(t3, e2) + "";
          if (o(t3))
            return c ? c.call(t3) : "";
          var r2 = t3 + "";
          return r2 == "0" && 1 / t3 == -1 / 0 ? "-0" : r2;
        };
      }, function(e, t2, r) {
        var n = r(151), i = r(152);
        e.exports = function(e2, t3) {
          return e2 != null && i(e2, t3, n);
        };
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          return e2 != null && t3 in Object(e2);
        };
      }, function(e, t2, r) {
        var n = r(58), i = r(41), a = r(10), o = r(45), s2 = r(30), c = r(25);
        e.exports = function(e2, t3, r2) {
          for (var u = -1, l2 = (t3 = n(t3, e2)).length, d2 = false; ++u < l2; ) {
            var f = c(t3[u]);
            if (!(d2 = e2 != null && r2(e2, f)))
              break;
            e2 = e2[f];
          }
          return d2 || ++u != l2 ? d2 : !!(l2 = e2 == null ? 0 : e2.length) && s2(l2) && o(f, l2) && (a(e2) || i(e2));
        };
      }, function(e, t2, r) {
        var n = r(154), i = r(155), a = r(35), o = r(25);
        e.exports = function(e2) {
          return a(e2) ? n(o(e2)) : i(e2);
        };
      }, function(e, t2) {
        e.exports = function(e2) {
          return function(t3) {
            return t3 == null ? void 0 : t3[e2];
          };
        };
      }, function(e, t2, r) {
        var n = r(57);
        e.exports = function(e2) {
          return function(t3) {
            return n(t3, e2);
          };
        };
      }, function(e, t2, r) {
        var n = r(59), i = r(49), a = r(157), o = r(158), s2 = r(47), c = r(159), u = r(60);
        e.exports = function(e2, t3, r2) {
          var l2 = -1;
          t3 = n(t3.length ? t3 : [u], s2(i));
          var d2 = a(e2, function(e3, r3, i2) {
            return { criteria: n(t3, function(t4) {
              return t4(e3);
            }), index: ++l2, value: e3 };
          });
          return o(d2, function(e3, t4) {
            return c(e3, t4, r2);
          });
        };
      }, function(e, t2, r) {
        var n = r(40), i = r(31);
        e.exports = function(e2, t3) {
          var r2 = -1, a = i(e2) ? Array(e2.length) : [];
          return n(e2, function(e3, n2, i2) {
            a[++r2] = t3(e3, n2, i2);
          }), a;
        };
      }, function(e, t2) {
        e.exports = function(e2, t3) {
          var r = e2.length;
          for (e2.sort(t3); r--; )
            e2[r] = e2[r].value;
          return e2;
        };
      }, function(e, t2, r) {
        var n = r(160);
        e.exports = function(e2, t3, r2) {
          for (var i = -1, a = e2.criteria, o = t3.criteria, s2 = a.length, c = r2.length; ++i < s2; ) {
            var u = n(a[i], o[i]);
            if (u)
              return i >= c ? u : u * (r2[i] == "desc" ? -1 : 1);
          }
          return e2.index - t3.index;
        };
      }, function(e, t2, r) {
        var n = r(24);
        e.exports = function(e2, t3) {
          if (e2 !== t3) {
            var r2 = e2 !== void 0, i = e2 === null, a = e2 == e2, o = n(e2), s2 = t3 !== void 0, c = t3 === null, u = t3 == t3, l2 = n(t3);
            if (!c && !l2 && !o && e2 > t3 || o && s2 && u && !c && !l2 || i && s2 && u || !r2 && u || !a)
              return 1;
            if (!i && !o && !l2 && e2 < t3 || l2 && r2 && a && !i && !o || c && r2 && a || !s2 && a || !u)
              return -1;
          }
          return 0;
        };
      }, function(e, t2, r) {
        "use strict";
        r.r(t2);
        var n = r(27), i = r.n(n), a = r(61), o = r.n(a), s2 = r(0), c = r.n(s2), u = r(1), l2 = r.n(u), d2 = r(5), f = r.n(d2), p2 = r(9), h = r.n(p2), v2 = r(6), m = r.n(v2), g = r(12), y2 = r.n(g), b = r(13), _ = r.n(b), w2 = r(7), k2 = r.n(w2), M2 = r(8), S2 = r.n(M2), E2 = r(4), T2 = r.n(E2), A3 = r(14), O2 = r.n(A3), x2 = r(16), P2 = r(62), C2 = r.n(P2), j2 = "new", L2 = "loading", I3 = "joining-meeting", N2 = "joined-meeting", R3 = "left-meeting", D2 = "error", F2 = { NONE: "none", BGBLUR: "background-blur", BGIMAGE: "background-image" }, B2 = { PLAY: "play", PAUSE: "pause" }, V2 = "playing", U2 = "paused", Y2 = ["jpg", "png", "jpeg"], G2 = r(2), q2 = r(26), J2 = r(3);
        function W2(e2, t3) {
          var r2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t3 && (n2 = n2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
            })), r2.push.apply(r2, n2);
          }
          return r2;
        }
        function z2(e2) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r2 = arguments[t3] != null ? arguments[t3] : {};
            t3 % 2 ? W2(Object(r2), true).forEach(function(t4) {
              S2()(e2, t4, r2[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : W2(Object(r2)).forEach(function(t4) {
              Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(r2, t4));
            });
          }
          return e2;
        }
        function K2(e2) {
          var t3 = function() {
            if (typeof Reflect == "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy == "function")
              return true;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), true;
            } catch (e3) {
              return false;
            }
          }();
          return function() {
            var r2, n2 = k2()(e2);
            if (t3) {
              var i2 = k2()(this).constructor;
              r2 = Reflect.construct(n2, arguments, i2);
            } else
              r2 = n2.apply(this, arguments);
            return _()(this, r2);
          };
        }
        var H4 = function(e2) {
          y2()(r2, e2);
          var t3 = K2(r2);
          function r2() {
            var e3;
            return f()(this, r2), (e3 = t3.call(this))._wrappedListeners = {}, e3._messageCallbacks = {}, e3;
          }
          return m()(r2, [{ key: "addListenerForMessagesFromCallMachine", value: function(e3, t4, r3) {
            var n2 = this, i2 = function(i3) {
              if (i3.data && i3.data.what === "iframe-call-message" && (!i3.data.callFrameId || i3.data.callFrameId === t4) && (!i3.data.from || i3.data.from !== "module")) {
                var a2 = z2({}, i3.data);
                if (delete a2.from, a2.callbackStamp && n2._messageCallbacks[a2.callbackStamp]) {
                  var o2 = a2.callbackStamp;
                  n2._messageCallbacks[o2].call(r3, a2), delete n2._messageCallbacks[o2];
                }
                delete a2.what, delete a2.callbackStamp, e3.call(r3, a2);
              }
            };
            this._wrappedListeners[e3] = i2, window.addEventListener("message", i2);
          } }, { key: "addListenerForMessagesFromDailyJs", value: function(e3, t4, r3) {
            var n2 = function(n3) {
              if (!(!n3.data || n3.data.what !== "iframe-call-message" || !n3.data.action || n3.data.from && n3.data.from !== "module" || n3.data.callFrameId && t4 && n3.data.callFrameId !== t4)) {
                var i2 = n3.data;
                e3.call(r3, i2);
              }
            };
            this._wrappedListeners[e3] = n2, window.addEventListener("message", n2);
          } }, { key: "sendMessageToCallMachine", value: function(e3, t4, r3, n2) {
            var i2 = z2({}, e3);
            if (i2.what = "iframe-call-message", i2.from = "module", i2.callFrameId = n2, t4) {
              var a2 = Object(J2.c)();
              this._messageCallbacks[a2] = t4, i2.callbackStamp = a2;
            }
            (r3 ? r3.contentWindow : window).postMessage(i2, "*");
          } }, { key: "sendMessageToDailyJs", value: function(e3, t4, r3) {
            e3.what = "iframe-call-message", e3.callFrameId = r3, e3.from = "embedded", (t4 ? window : window.parent).postMessage(e3, "*");
          } }, { key: "removeListener", value: function(e3) {
            var t4 = this._wrappedListeners[e3];
            t4 && (window.removeEventListener("message", t4), delete this._wrappedListeners[e3]);
          } }, { key: "forwardPackagedMessageToCallMachine", value: function(e3, t4, r3) {
            var n2 = z2({}, e3);
            n2.callFrameId = r3, (t4 ? t4.contentWindow : window).postMessage(n2, "*");
          } }, { key: "addListenerForPackagedMessagesFromCallMachine", value: function(e3, t4) {
            var r3 = function(r4) {
              if (r4.data && r4.data.what === "iframe-call-message" && (!r4.data.callFrameId || r4.data.callFrameId === t4) && (!r4.data.from || r4.data.from !== "module")) {
                var n2 = r4.data;
                e3(n2);
              }
            };
            return this._wrappedListeners[e3] = r3, window.addEventListener("message", r3), e3;
          } }, { key: "removeListenerForPackagedMessagesFromCallMachine", value: function(e3) {
            var t4 = this._wrappedListeners[e3];
            t4 && (window.removeEventListener("message", t4), delete this._wrappedListeners[e3]);
          } }]), r2;
        }(q2.a), Q2 = r(63), $2 = r(64), Z2 = r.n($2);
        function X2(e2) {
          var t3 = function() {
            if (typeof Reflect == "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy == "function")
              return true;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), true;
            } catch (e3) {
              return false;
            }
          }();
          return function() {
            var r2, n2 = k2()(e2);
            if (t3) {
              var i2 = k2()(this).constructor;
              r2 = Reflect.construct(n2, arguments, i2);
            } else
              r2 = n2.apply(this, arguments);
            return _()(this, r2);
          };
        }
        var ee2 = function() {
          function e2() {
            f()(this, e2), this._currentLoad = null;
          }
          return m()(e2, [{ key: "load", value: function(e3, t3, r2, n2) {
            if (this.loaded)
              return window._dailyCallObjectSetup(t3), void r2(true);
            !function(e4) {
              window._dailyConfig || (window._dailyConfig = {}), window._dailyConfig.callFrameId = e4;
            }(t3), this._currentLoad && this._currentLoad.cancel(), this._currentLoad = new te2(e3, t3, function() {
              r2(false);
            }, n2), this._currentLoad.start();
          } }, { key: "cancel", value: function() {
            this._currentLoad && this._currentLoad.cancel();
          } }, { key: "loaded", get: function() {
            return this._currentLoad && this._currentLoad.succeeded;
          } }]), e2;
        }(), te2 = function() {
          function e2(t3, r2, n2, i2) {
            f()(this, e2), this._attemptsRemaining = 3, this._currentAttempt = null, this._meetingOrBaseUrl = t3, this._callFrameId = r2, this._successCallback = n2, this._failureCallback = i2;
          }
          return m()(e2, [{ key: "start", value: function() {
            var e3 = this;
            if (!this._currentAttempt) {
              this._currentAttempt = new ne2(this._meetingOrBaseUrl, this._callFrameId, this._successCallback, function t3(r2) {
                e3._currentAttempt.cancelled || (e3._attemptsRemaining--, e3._failureCallback(r2, e3._attemptsRemaining > 0), e3._attemptsRemaining <= 0 || setTimeout(function() {
                  e3._currentAttempt.cancelled || (e3._currentAttempt = new ne2(e3._meetingOrBaseUrl, e3._callFrameId, e3._successCallback, t3), e3._currentAttempt.start());
                }, 3e3));
              }), this._currentAttempt.start();
            }
          } }, { key: "cancel", value: function() {
            this._currentAttempt && this._currentAttempt.cancel();
          } }, { key: "cancelled", get: function() {
            return this._currentAttempt && this._currentAttempt.cancelled;
          } }, { key: "succeeded", get: function() {
            return this._currentAttempt && this._currentAttempt.succeeded;
          } }]), e2;
        }(), re2 = function(e2) {
          y2()(r2, e2);
          var t3 = X2(r2);
          function r2() {
            return f()(this, r2), t3.apply(this, arguments);
          }
          return r2;
        }(Z2()(Error)), ne2 = function() {
          function e2(t4, r3, n3, i3) {
            f()(this, e2), this.cancelled = false, this.succeeded = false, this._networkTimedOut = false, this._networkTimeout = null, this._iosCache = typeof iOSCallObjectBundleCache != "undefined" && iOSCallObjectBundleCache, this._refetchHeaders = null, this._meetingOrBaseUrl = t4, this._callFrameId = r3, this._successCallback = n3, this._failureCallback = i3;
          }
          var t3, r2, n2, i2;
          return m()(e2, [{ key: "start", value: (i2 = l2()(c.a.mark(function e3() {
            var t4;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    e4.prev = 0, t4 = Object(J2.a)(this._meetingOrBaseUrl), e4.next = 8;
                    break;
                  case 4:
                    return e4.prev = 4, e4.t0 = e4.catch(0), this._failureCallback("Failed to get call object bundle URL ".concat(t4, ": ").concat(e4.t0)), e4.abrupt("return");
                  case 8:
                    return e4.next = 10, this._tryLoadFromIOSCache(t4);
                  case 10:
                    !e4.sent && this._loadFromNetwork(t4);
                  case 12:
                  case "end":
                    return e4.stop();
                }
            }, e3, this, [[0, 4]]);
          })), function() {
            return i2.apply(this, arguments);
          }) }, { key: "cancel", value: function() {
            clearTimeout(this._networkTimeout), this.cancelled = true;
          } }, { key: "_tryLoadFromIOSCache", value: (n2 = l2()(c.a.mark(function e3(t4) {
            var r3;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (this._iosCache) {
                      e4.next = 2;
                      break;
                    }
                    return e4.abrupt("return", false);
                  case 2:
                    return e4.prev = 2, e4.next = 5, this._iosCache.get(t4);
                  case 5:
                    if (r3 = e4.sent, !this.cancelled) {
                      e4.next = 8;
                      break;
                    }
                    return e4.abrupt("return", true);
                  case 8:
                    if (r3) {
                      e4.next = 10;
                      break;
                    }
                    return e4.abrupt("return", false);
                  case 10:
                    if (r3.code) {
                      e4.next = 13;
                      break;
                    }
                    return this._refetchHeaders = r3.refetchHeaders, e4.abrupt("return", false);
                  case 13:
                    return Function('"use strict";' + r3.code)(), this.succeeded = true, this._successCallback(), e4.abrupt("return", true);
                  case 19:
                    return e4.prev = 19, e4.t0 = e4.catch(2), e4.abrupt("return", false);
                  case 22:
                  case "end":
                    return e4.stop();
                }
            }, e3, this, [[2, 19]]);
          })), function(e3) {
            return n2.apply(this, arguments);
          }) }, { key: "_loadFromNetwork", value: (r2 = l2()(c.a.mark(function e3(t4) {
            var r3, n3, i3, a2 = this;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    return this._networkTimeout = setTimeout(function() {
                      a2._networkTimedOut = true, a2._failureCallback("Timed out (>".concat(2e4, " ms) when loading call object bundle ").concat(t4));
                    }, 2e4), e4.prev = 1, r3 = this._refetchHeaders ? { headers: this._refetchHeaders } : {}, e4.next = 5, fetch(t4, r3);
                  case 5:
                    if (n3 = e4.sent, clearTimeout(this._networkTimeout), !this.cancelled && !this._networkTimedOut) {
                      e4.next = 9;
                      break;
                    }
                    throw new re2();
                  case 9:
                    return e4.next = 11, this._getBundleCodeFromResponse(t4, n3);
                  case 11:
                    if (i3 = e4.sent, !this.cancelled) {
                      e4.next = 14;
                      break;
                    }
                    throw new re2();
                  case 14:
                    Function('"use strict";' + i3)(), this._iosCache && this._iosCache.set(t4, i3, n3.headers), this.succeeded = true, this._successCallback(), e4.next = 26;
                    break;
                  case 20:
                    if (e4.prev = 20, e4.t0 = e4.catch(1), clearTimeout(this._networkTimeout), !(e4.t0 instanceof re2 || this.cancelled || this._networkTimedOut)) {
                      e4.next = 25;
                      break;
                    }
                    return e4.abrupt("return");
                  case 25:
                    this._failureCallback("Failed to load call object bundle ".concat(t4, ": ").concat(e4.t0));
                  case 26:
                  case "end":
                    return e4.stop();
                }
            }, e3, this, [[1, 20]]);
          })), function(e3) {
            return r2.apply(this, arguments);
          }) }, { key: "_getBundleCodeFromResponse", value: (t3 = l2()(c.a.mark(function e3(t4, r3) {
            var n3;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (!r3.ok) {
                      e4.next = 4;
                      break;
                    }
                    return e4.next = 3, r3.text();
                  case 3:
                    return e4.abrupt("return", e4.sent);
                  case 4:
                    if (!this._iosCache || r3.status !== 304) {
                      e4.next = 9;
                      break;
                    }
                    return e4.next = 7, this._iosCache.renew(t4, r3.headers);
                  case 7:
                    return n3 = e4.sent, e4.abrupt("return", n3.code);
                  case 9:
                    throw new Error("Received ".concat(r3.status, " response"));
                  case 10:
                  case "end":
                    return e4.stop();
                }
            }, e3, this);
          })), function(e3, r3) {
            return t3.apply(this, arguments);
          }) }]), e2;
        }(), ie2 = r(36), ae2 = r.n(ie2), oe2 = r(37), se2 = r.n(oe2), ce2 = function(e2, t3, r2) {
          return de2(e2.local, t3, r2) === true;
        }, ue2 = function(e2, t3, r2) {
          return e2.local.streams && e2.local.streams[t3] && e2.local.streams[t3].stream && e2.local.streams[t3].stream["get".concat(r2 === "video" ? "Video" : "Audio", "Tracks")]()[0];
        }, le2 = function(e2, t3, r2, n2) {
          var i2 = fe2(e2, t3, r2, n2);
          return i2 && i2.pendingTrack;
        }, de2 = function(e2, t3, r2) {
          if (!e2)
            return false;
          var n2 = function(e3) {
            switch (e3) {
              case "avatar":
                return true;
              case "staged":
                return e3;
              default:
                return !!e3;
            }
          }, i2 = e2.public.subscribedTracks;
          return i2 && i2[t3] ? ["cam-audio", "cam-video", "screen-video", "screen-audio", "rmpAudio", "rmpVideo"].indexOf(r2) === -1 && i2[t3].custom ? [true, "staged"].includes(i2[t3].custom) ? n2(i2[t3].custom) : n2(i2[t3].custom[r2]) : n2(i2[t3][r2]) : !i2 || n2(i2.ALL);
        }, fe2 = function(e2, t3, r2, n2) {
          var i2 = se2()(ae2()(e2.streams, function(e3) {
            return e3.participantId === t3 && e3.type === r2 && e3.pendingTrack && e3.pendingTrack.kind === n2;
          }), "starttime", "desc");
          return i2 && i2[0];
        }, pe2 = function(e2, t3) {
          var r2 = e2.local.public.customTracks;
          if (r2 && r2[t3])
            return r2[t3].track;
        }, he2 = function(e2, t3, r2, n2) {
          var i2 = "soup-" + r2, a2 = se2()(ae2()(e2.streams, function(e3) {
            return e3.participantId === t3 && e3.streamId === i2 && e3.pendingTrack && e3.pendingTrack.kind === n2;
          }), "starttime", "desc");
          return a2 && a2[0] && a2[0].pendingTrack;
        };
        function ve2(e2) {
          for (var t3 = store.getState(), r2 = 0, n2 = ["cam", "screen"]; r2 < n2.length; r2++)
            for (var i2 = n2[r2], a2 = 0, o2 = ["video", "audio"]; a2 < o2.length; a2++) {
              var s3 = o2[a2], c2 = i2 === "cam" ? s3 : "screen".concat(s3.charAt(0).toUpperCase() + s3.slice(1)), u2 = e2.tracks[c2];
              if (u2) {
                var l3 = e2.local ? ue2(t3, i2, s3) : le2(t3, e2.session_id, i2, s3);
                u2.state === "playable" && (u2.track = l3), u2.persistentTrack = l3;
              }
            }
        }
        function me2(e2) {
          try {
            var t3 = store.getState();
            for (var r2 in e2.tracks)
              if (!ge2(r2)) {
                var n2 = e2.tracks[r2].kind;
                if (n2) {
                  var i2 = e2.tracks[r2];
                  if (i2) {
                    var a2 = e2.local ? pe2(t3, r2) : he2(t3, e2.session_id, r2, n2);
                    i2.state === "playable" && (e2.tracks[r2].track = a2), i2.persistentTrack = a2;
                  }
                } else
                  console.error("unknown type for custom track");
              }
          } catch (e3) {
            console.error(e3);
          }
        }
        function ge2(e2) {
          return ["video", "audio", "screenVideo", "screenAudio"].includes(e2);
        }
        function ye2(e2, t3) {
          var r2 = store.getState();
          if (e2.local) {
            if (e2.audio)
              try {
                e2.audioTrack = r2.local.streams.cam.stream.getAudioTracks()[0], e2.audioTrack || (e2.audio = false);
              } catch (e3) {
              }
            if (e2.video)
              try {
                e2.videoTrack = r2.local.streams.cam.stream.getVideoTracks()[0], e2.videoTrack || (e2.video = false);
              } catch (e3) {
              }
            if (e2.screen)
              try {
                e2.screenVideoTrack = r2.local.streams.screen.stream.getVideoTracks()[0], e2.screenAudioTrack = r2.local.streams.screen.stream.getAudioTracks()[0], e2.screenVideoTrack || e2.screenAudioTrack || (e2.screen = false);
              } catch (e3) {
              }
          } else {
            var n2 = true;
            try {
              var i2 = r2.participants[e2.session_id];
              i2 && i2.public && i2.public.rtcType && i2.public.rtcType.impl === "peer-to-peer" && i2.private && !["connected", "completed"].includes(i2.private.peeringState) && (n2 = false);
            } catch (e3) {
              console.error(e3);
            }
            if (!n2)
              return e2.audio = false, e2.audioTrack = false, e2.video = false, e2.videoTrack = false, e2.screen = false, void (e2.screenTrack = false);
            try {
              r2.streams;
              if (e2.audio && ce2(r2, e2.session_id, "cam-audio")) {
                var a2 = le2(r2, e2.session_id, "cam", "audio");
                a2 && (t3 && t3.audioTrack && t3.audioTrack.id === a2.id ? e2.audioTrack = a2 : a2.muted || (e2.audioTrack = a2)), e2.audioTrack || (e2.audio = false);
              }
              if (e2.video && ce2(r2, e2.session_id, "cam-video")) {
                var o2 = le2(r2, e2.session_id, "cam", "video");
                o2 && (t3 && t3.videoTrack && t3.videoTrack.id === o2.id ? e2.videoTrack = o2 : o2.muted || (e2.videoTrack = o2)), e2.videoTrack || (e2.video = false);
              }
              if (e2.screen && ce2(r2, e2.session_id, "screen-audio")) {
                var s3 = le2(r2, e2.session_id, "screen", "audio");
                s3 && (t3 && t3.screenAudioTrack && t3.screenAudioTrack.id === s3.id ? e2.screenAudioTrack = s3 : s3.muted || (e2.screenAudioTrack = s3));
              }
              if (e2.screen && ce2(r2, e2.session_id, "screen-video")) {
                var c2 = le2(r2, e2.session_id, "screen", "video");
                c2 && (t3 && t3.screenVideoTrack && t3.screenVideoTrack.id === c2.id ? e2.screenVideoTrack = c2 : c2.muted || (e2.screenVideoTrack = c2));
              }
              e2.screenVideoTrack || e2.screenAudioTrack || (e2.screen = false);
            } catch (e3) {
              console.error("unexpected error matching up tracks", e3);
            }
          }
        }
        function be2(e2, t3) {
          var r2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t3 && (n2 = n2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
            })), r2.push.apply(r2, n2);
          }
          return r2;
        }
        function _e2(e2) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r2 = arguments[t3] != null ? arguments[t3] : {};
            t3 % 2 ? be2(Object(r2), true).forEach(function(t4) {
              S2()(e2, t4, r2[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : be2(Object(r2)).forEach(function(t4) {
              Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(r2, t4));
            });
          }
          return e2;
        }
        function we2(e2) {
          var t3 = function() {
            if (typeof Reflect == "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy == "function")
              return true;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), true;
            } catch (e3) {
              return false;
            }
          }();
          return function() {
            var r2, n2 = k2()(e2);
            if (t3) {
              var i2 = k2()(this).constructor;
              r2 = Reflect.construct(n2, arguments, i2);
            } else
              r2 = n2.apply(this, arguments);
            return _()(this, r2);
          };
        }
        r.d(t2, "default", function() {
          return Ce2;
        }), r.d(t2, "DAILY_STATE_NEW", function() {
          return j2;
        }), r.d(t2, "DAILY_STATE_JOINING", function() {
          return I3;
        }), r.d(t2, "DAILY_STATE_JOINED", function() {
          return N2;
        }), r.d(t2, "DAILY_STATE_LEFT", function() {
          return R3;
        }), r.d(t2, "DAILY_STATE_ERROR", function() {
          return D2;
        }), r.d(t2, "DAILY_TRACK_STATE_BLOCKED", function() {
          return "blocked";
        }), r.d(t2, "DAILY_TRACK_STATE_OFF", function() {
          return "off";
        }), r.d(t2, "DAILY_TRACK_STATE_SENDABLE", function() {
          return "sendable";
        }), r.d(t2, "DAILY_TRACK_STATE_LOADING", function() {
          return "loading";
        }), r.d(t2, "DAILY_TRACK_STATE_INTERRUPTED", function() {
          return "interrupted";
        }), r.d(t2, "DAILY_TRACK_STATE_PLAYABLE", function() {
          return "playable";
        }), r.d(t2, "DAILY_ACCESS_UNKNOWN", function() {
          return "unknown";
        }), r.d(t2, "DAILY_ACCESS_LEVEL_FULL", function() {
          return "full";
        }), r.d(t2, "DAILY_ACCESS_LEVEL_LOBBY", function() {
          return "lobby";
        }), r.d(t2, "DAILY_ACCESS_LEVEL_NONE", function() {
          return "none";
        }), r.d(t2, "DAILY_RECEIVE_SETTINGS_BASE_KEY", function() {
          return "base";
        }), r.d(t2, "DAILY_RECEIVE_SETTINGS_ALL_PARTICIPANTS_KEY", function() {
          return "*";
        }), r.d(t2, "DAILY_FATAL_ERROR_EJECTED", function() {
          return "ejected";
        }), r.d(t2, "DAILY_FATAL_ERROR_NBF_ROOM", function() {
          return "nbf-room";
        }), r.d(t2, "DAILY_FATAL_ERROR_NBF_TOKEN", function() {
          return "nbf-token";
        }), r.d(t2, "DAILY_FATAL_ERROR_EXP_ROOM", function() {
          return "exp-room";
        }), r.d(t2, "DAILY_FATAL_ERROR_EXP_TOKEN", function() {
          return "exp-token";
        }), r.d(t2, "DAILY_CAMERA_ERROR_CAM_IN_USE", function() {
          return "cam-in-use";
        }), r.d(t2, "DAILY_CAMERA_ERROR_MIC_IN_USE", function() {
          return "mic-in-use";
        }), r.d(t2, "DAILY_CAMERA_ERROR_CAM_AND_MIC_IN_USE", function() {
          return "cam-mic-in-use";
        }), r.d(t2, "DAILY_EVENT_IFRAME_READY_FOR_LAUNCH_CONFIG", function() {
          return "iframe-ready-for-launch-config";
        }), r.d(t2, "DAILY_EVENT_IFRAME_LAUNCH_CONFIG", function() {
          return "iframe-launch-config";
        }), r.d(t2, "DAILY_EVENT_THEME_UPDATED", function() {
          return "theme-updated";
        }), r.d(t2, "DAILY_EVENT_LOADING", function() {
          return "loading";
        }), r.d(t2, "DAILY_EVENT_LOADED", function() {
          return "loaded";
        }), r.d(t2, "DAILY_EVENT_LOAD_ATTEMPT_FAILED", function() {
          return "load-attempt-failed";
        }), r.d(t2, "DAILY_EVENT_STARTED_CAMERA", function() {
          return "started-camera";
        }), r.d(t2, "DAILY_EVENT_CAMERA_ERROR", function() {
          return "camera-error";
        }), r.d(t2, "DAILY_EVENT_JOINING_MEETING", function() {
          return "joining-meeting";
        }), r.d(t2, "DAILY_EVENT_JOINED_MEETING", function() {
          return "joined-meeting";
        }), r.d(t2, "DAILY_EVENT_LEFT_MEETING", function() {
          return "left-meeting";
        }), r.d(t2, "DAILY_EVENT_PARTICIPANT_JOINED", function() {
          return "participant-joined";
        }), r.d(t2, "DAILY_EVENT_PARTICIPANT_UPDATED", function() {
          return "participant-updated";
        }), r.d(t2, "DAILY_EVENT_PARTICIPANT_LEFT", function() {
          return "participant-left";
        }), r.d(t2, "DAILY_EVENT_PARTICIPANT_COUNTS_UPDATED", function() {
          return "participant-counts-updated";
        }), r.d(t2, "DAILY_EVENT_TRACK_STARTED", function() {
          return "track-started";
        }), r.d(t2, "DAILY_EVENT_TRACK_STOPPED", function() {
          return "track-stopped";
        }), r.d(t2, "DAILY_EVENT_RECORDING_STARTED", function() {
          return "recording-started";
        }), r.d(t2, "DAILY_EVENT_RECORDING_STOPPED", function() {
          return "recording-stopped";
        }), r.d(t2, "DAILY_EVENT_RECORDING_STATS", function() {
          return "recording-stats";
        }), r.d(t2, "DAILY_EVENT_RECORDING_ERROR", function() {
          return "recording-error";
        }), r.d(t2, "DAILY_EVENT_RECORDING_UPLOAD_COMPLETED", function() {
          return "recording-upload-completed";
        }), r.d(t2, "DAILY_EVENT_REMOTE_MEDIA_PLAYER_STARTED", function() {
          return "remote-media-player-started";
        }), r.d(t2, "DAILY_EVENT_REMOTE_MEDIA_PLAYER_UPDATED", function() {
          return "remote-media-player-updated";
        }), r.d(t2, "DAILY_EVENT_REMOTE_MEDIA_PLAYER_STOPPED", function() {
          return "remote-media-player-stopped";
        }), r.d(t2, "DAILY_EVENT_TRANSCRIPTION_STARTED", function() {
          return "transcription-started";
        }), r.d(t2, "DAILY_EVENT_TRANSCRIPTION_STOPPED", function() {
          return "transcription-stopped";
        }), r.d(t2, "DAILY_EVENT_TRANSCRIPTION_ERROR", function() {
          return "transcription-error";
        }), r.d(t2, "DAILY_EVENT_ERROR", function() {
          return "error";
        }), r.d(t2, "DAILY_EVENT_APP_MSG", function() {
          return "app-message";
        }), r.d(t2, "DAILY_EVENT_INPUT_EVENT", function() {
          return "input-event";
        }), r.d(t2, "DAILY_EVENT_LOCAL_SCREEN_SHARE_STARTED", function() {
          return "local-screen-share-started";
        }), r.d(t2, "DAILY_EVENT_LOCAL_SCREEN_SHARE_STOPPED", function() {
          return "local-screen-share-stopped";
        }), r.d(t2, "DAILY_EVENT_NETWORK_QUALITY_CHANGE", function() {
          return "network-quality-change";
        }), r.d(t2, "DAILY_EVENT_ACTIVE_SPEAKER_CHANGE", function() {
          return "active-speaker-change";
        }), r.d(t2, "DAILY_EVENT_ACTIVE_SPEAKER_MODE_CHANGE", function() {
          return "active-speaker-mode-change";
        }), r.d(t2, "DAILY_EVENT_FULLSCREEN", function() {
          return "fullscreen";
        }), r.d(t2, "DAILY_EVENT_EXIT_FULLSCREEN", function() {
          return "exited-fullscreen";
        }), r.d(t2, "DAILY_EVENT_NETWORK_CONNECTION", function() {
          return "network-connection";
        }), r.d(t2, "DAILY_EVENT_RECORDING_DATA", function() {
          return "recording-data";
        }), r.d(t2, "DAILY_EVENT_LIVE_STREAMING_STARTED", function() {
          return "live-streaming-started";
        }), r.d(t2, "DAILY_EVENT_LIVE_STREAMING_STOPPED", function() {
          return "live-streaming-stopped";
        }), r.d(t2, "DAILY_EVENT_LIVE_STREAMING_ERROR", function() {
          return "live-streaming-error";
        }), r.d(t2, "DAILY_EVENT_LANG_UPDATED", function() {
          return "lang-updated";
        }), r.d(t2, "DAILY_EVENT_ACCESS_STATE_UPDATED", function() {
          return "access-state-updated";
        }), r.d(t2, "DAILY_EVENT_MEETING_SESSION_UPDATED", function() {
          return "meeting-session-updated";
        }), r.d(t2, "DAILY_EVENT_WAITING_PARTICIPANT_ADDED", function() {
          return "waiting-participant-added";
        }), r.d(t2, "DAILY_EVENT_WAITING_PARTICIPANT_REMOVED", function() {
          return "waiting-participant-removed";
        }), r.d(t2, "DAILY_EVENT_WAITING_PARTICIPANT_UPDATED", function() {
          return "waiting-participant-updated";
        }), r.d(t2, "DAILY_EVENT_RECEIVE_SETTINGS_UPDATED", function() {
          return "receive-settings-updated";
        }), r.d(t2, "DAILY_EVENT_INPUT_SETTINGS_UPDATED", function() {
          return "input-settings-updated";
        }), r.d(t2, "DAILY_EVENT_NONFATAL_ERROR", function() {
          return "nonfatal-error";
        });
        var ke2 = "video", Me2 = "voice", Se2 = { present: 0, hidden: 0 }, Ee2 = { maxBitrate: { min: 1e5, max: 25e5 }, maxFramerate: { min: 1, max: 30 }, scaleResolutionDownBy: { min: 1, max: 8 } }, Te2 = ["state", "simulcastEncodings"], Ae2 = { androidInCallNotification: { title: "string", subtitle: "string", iconName: "string", disableForCustomOverride: "boolean" }, disableAutoDeviceManagement: { audio: "boolean", video: "boolean" } }, Oe2 = { id: { iconPath: "string", label: "string", tooltip: "string" } }, xe2 = { customTrayButtons: { validate: Be2, help: "customTrayButtons should be a dictionary of the type ".concat(JSON.stringify(Oe2)) }, url: { validate: function(e2) {
          return typeof e2 == "string";
        }, help: "url should be a string" }, baseUrl: { validate: function(e2) {
          return typeof e2 == "string";
        }, help: "baseUrl should be a string" }, token: { validate: function(e2) {
          return typeof e2 == "string";
        }, help: "token should be a string", queryString: "t" }, dailyConfig: { validate: function(e2) {
          return window._dailyConfig || (window._dailyConfig = {}), window._dailyConfig.experimentalGetUserMediaConstraintsModify = e2.experimentalGetUserMediaConstraintsModify, delete e2.experimentalGetUserMediaConstraintsModify, window._dailyConfig.userMediaVideoConstraints = e2.userMediaVideoConstraints, delete e2.userMediaVideoConstraints, true;
        } }, reactNativeConfig: { validate: function(e2) {
          return function e3(t3, r2) {
            if (r2 === void 0)
              return false;
            switch (T2()(r2)) {
              case "string":
                return T2()(t3) === r2;
              case "object":
                if (T2()(t3) !== "object")
                  return false;
                for (var n2 in t3)
                  if (!e3(t3[n2], r2[n2]))
                    return false;
                return true;
              default:
                return false;
            }
          }(e2, Ae2);
        }, help: "reactNativeConfig should look like ".concat(JSON.stringify(Ae2), ", all fields optional") }, lang: { validate: function(e2) {
          return ["de", "en-us", "en", "es", "fi", "fr", "it", "jp", "ka", "nl", "no", "pl", "pt", "ru", "sv", "tr", "user"].includes(e2);
        }, help: "language not supported. Options are: de, en-us, en, es, fi, fr, it, jp, ka, nl, no, pl, pt, ru, sv, tr, user" }, userName: true, activeSpeakerMode: true, showLeaveButton: true, showLocalVideo: true, showParticipantsBar: true, showFullscreenButton: true, iframeStyle: true, customLayout: true, cssFile: true, cssText: true, bodyClass: true, videoSource: { validate: function(e2, t3) {
          return t3._preloadCache.videoDeviceId = e2, true;
        } }, audioSource: { validate: function(e2, t3) {
          return t3._preloadCache.audioDeviceId = e2, true;
        } }, subscribeToTracksAutomatically: { validate: function(e2, t3) {
          return t3._preloadCache.subscribeToTracksAutomatically = e2, true;
        } }, theme: { validate: function(e2) {
          var t3 = ["accent", "accentText", "background", "backgroundAccent", "baseText", "border", "mainAreaBg", "mainAreaBgAccent", "mainAreaText", "supportiveText"], r2 = function(e3) {
            for (var r3 = 0, n2 = Object.keys(e3); r3 < n2.length; r3++) {
              var i2 = n2[r3];
              if (!t3.includes(i2))
                return console.error('unsupported color "'.concat(i2, '". Valid colors: ').concat(t3.join(", "))), false;
              if (!e3[i2].match(/^#[0-9a-f]{6}|#[0-9a-f]{3}$/i))
                return console.error("".concat(i2, ' theme color should be provided in valid hex color format. Received: "').concat(e3[i2], '"')), false;
            }
            return true;
          };
          return T2()(e2) === "object" && ("light" in e2 && "dark" in e2 || "colors" in e2) ? "light" in e2 && "dark" in e2 ? "colors" in e2.light ? "colors" in e2.dark ? r2(e2.light.colors) && r2(e2.dark.colors) : (console.error('Dark theme is missing "colors" property.', e2), false) : (console.error('Light theme is missing "colors" property.', e2), false) : r2(e2.colors) : (console.error('Theme must contain either both "light" and "dark" properties, or "colors".', e2), false);
        }, help: "unsupported theme configuration. Check error logs for detailed info." }, layoutConfig: { validate: function(e2) {
          if ("grid" in e2) {
            var t3 = e2.grid;
            if ("maxTilesPerPage" in t3) {
              if (!Number.isInteger(t3.maxTilesPerPage))
                return console.error("grid.maxTilesPerPage should be an integer. You passed ".concat(t3.maxTilesPerPage, ".")), false;
              if (t3.maxTilesPerPage > 49)
                return console.error("grid.maxTilesPerPage can't be larger than 49 without sacrificing browser performance. Please contact us at https://www.daily.co/contact to talk about your use case."), false;
            }
            if ("minTilesPerPage" in t3) {
              if (!Number.isInteger(t3.minTilesPerPage))
                return console.error("grid.minTilesPerPage should be an integer. You passed ".concat(t3.minTilesPerPage, ".")), false;
              if (t3.minTilesPerPage < 1)
                return console.error("grid.minTilesPerPage can't be lower than 1."), false;
              if ("maxTilesPerPage" in t3 && t3.minTilesPerPage > t3.maxTilesPerPage)
                return console.error("grid.minTilesPerPage can't be higher than grid.maxTilesPerPage."), false;
            }
          }
          return true;
        }, help: "unsupported layoutConfig. Check error logs for detailed info." }, receiveSettings: { validate: function(e2) {
          return Ne2(e2, { allowAllParticipantsKey: false });
        }, help: Fe2({ allowAllParticipantsKey: false }) }, inputSettings: { validate: function(e2) {
          return Re2(e2);
        }, help: De2() }, layout: { validate: function(e2) {
          return e2 === "custom-v1" || e2 === "browser" || e2 === "none";
        }, help: 'layout may only be set to "custom-v1"', queryString: "layout" }, emb: { queryString: "emb" }, embHref: { queryString: "embHref" }, dailyJsVersion: { queryString: "dailyJsVersion" } }, Pe2 = { styles: { validate: function(e2) {
          for (var t3 in e2)
            if (t3 !== "cam" && t3 !== "screen")
              return false;
          if (e2.cam) {
            for (var t3 in e2.cam)
              if (t3 !== "div" && t3 !== "video")
                return false;
          }
          if (e2.screen) {
            for (var t3 in e2.screen)
              if (t3 !== "div" && t3 !== "video")
                return false;
          }
          return true;
        }, help: "styles format should be a subset of: { cam: {div: {}, video: {}}, screen: {div: {}, video: {}} }" }, setSubscribedTracks: { validate: function(e2, t3, r2) {
          if (t3._preloadCache.subscribeToTracksAutomatically)
            return false;
          var n2 = [true, false, "staged"];
          if (n2.includes(e2) || !Object(G2.d)() && e2 === "avatar")
            return true;
          var i2 = ["audio", "video", "screenAudio", "screenVideo", "rmpAudio", "rmpVideo"];
          return function e3(t4) {
            var r3 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
            for (var a2 in t4)
              if (a2 === "custom") {
                var o2 = n2.includes(t4[a2]);
                if (!o2 && !e3(t4[a2], true))
                  return false;
              } else {
                var s3 = !r3 && !i2.includes(a2), c2 = !n2.includes(t4[a2]);
                if (s3 || c2)
                  return false;
              }
            return true;
          }(e2);
        }, help: "setSubscribedTracks cannot be used when setSubscribeToTracksAutomatically is enabled, and should be of the form: " + "true".concat(Object(G2.d)() ? "" : " | 'avatar'", " | false | 'staged' | { [audio: true|false|'staged'], [video: true|false|'staged'], [screenAudio: true|false|'staged'], [screenVideo: true|false|'staged'] }") }, setAudio: true, setVideo: true, eject: true }, Ce2 = function(e2) {
          y2()($3, e2);
          var t3, r2, n2, i2, a2, s3, u2, d3, p3, v3, g2, b2, _2, w3, k3, M3, E3, A4, P3, F3, Y3, q3, W3, z3, K3 = we2($3);
          function $3(e3) {
            var t4, r3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (f()(this, $3), t4 = K3.call(this), S2()(h()(t4), "startListeningForDeviceChanges", function() {
              navigator.mediaDevices.ondevicechange !== void 0 || Object(G2.d)() ? navigator.mediaDevices.addEventListener("devicechange", t4.deviceChangeListener) : t4.startPollingForDeviceChanges();
            }), S2()(h()(t4), "stopListeningForDeviceChanges", function() {
              navigator.mediaDevices.ondevicechange !== void 0 || Object(G2.d)() ? navigator.mediaDevices.removeEventListener("devicechange", t4.deviceChangeListener) : t4.stopPollingForDeviceChanges();
            }), S2()(h()(t4), "deviceChangeListener", l2()(c.a.mark(function e4() {
              var r4;
              return c.a.wrap(function(e5) {
                for (; ; )
                  switch (e5.prev = e5.next) {
                    case 0:
                      return e5.next = 2, t4.enumerateDevices();
                    case 2:
                      r4 = e5.sent, t4.handleDeviceChange(r4.devices);
                    case 4:
                    case "end":
                      return e5.stop();
                  }
              }, e4);
            }))), S2()(h()(t4), "handleDeviceChange", function(e4) {
              t4.emit("available-devices-updated", { action: "available-devices-updated", availableDevices: e4 });
            }), S2()(h()(t4), "startPollingForDeviceChanges", function() {
              t4._deviceChangeInterval || (t4._deviceChangeInterval = setInterval(l2()(c.a.mark(function e4() {
                var r4, n4;
                return c.a.wrap(function(e5) {
                  for (; ; )
                    switch (e5.prev = e5.next) {
                      case 0:
                        return e5.next = 2, t4.enumerateDevices();
                      case 2:
                        r4 = e5.sent, n4 = JSON.stringify(r4), t4._lastDevicesJSON && n4 !== t4._lastDevicesJSON && t4.handleDeviceChange(r4.devices), t4._lastDevicesJSON = n4;
                      case 6:
                      case "end":
                        return e5.stop();
                    }
                }, e4);
              })), 3e3));
            }), S2()(h()(t4), "stopPollingForDeviceChanges", function() {
              t4._deviceChangeInterval && (clearInterval(t4._deviceChangeInterval), t4._deviceChangeInterval = null, t4._lastDevicesJSON = null);
            }), S2()(h()(t4), "handleNativeAppActiveStateChange", function(e4) {
              t4.disableReactNativeAutoDeviceManagement("video") || (e4 ? t4.camUnmutedBeforeLosingNativeActiveState && t4.setLocalVideo(true) : (t4.camUnmutedBeforeLosingNativeActiveState = t4.localVideo(), t4.camUnmutedBeforeLosingNativeActiveState && t4.setLocalVideo(false)));
            }), S2()(h()(t4), "handleNativeAudioFocusChange", function(e4) {
              t4.disableReactNativeAutoDeviceManagement("audio") || (t4._hasNativeAudioFocus = e4, t4.toggleParticipantAudioBasedOnNativeAudioFocus(), t4._hasNativeAudioFocus ? t4.micUnmutedBeforeLosingNativeAudioFocus && t4.setLocalAudio(true) : (t4.micUnmutedBeforeLosingNativeAudioFocus = t4.localAudio(), t4.setLocalAudio(false)));
            }), r3.dailyJsVersion = $3.version(), t4._iframe = e3, t4._callObjectMode = r3.layout === "none" && !t4._iframe, t4._preloadCache = { subscribeToTracksAutomatically: true, audioDeviceId: null, videoDeviceId: null, outputDeviceId: null }, t4._callObjectMode && (window._dailyPreloadCache = t4._preloadCache), r3.showLocalVideo !== void 0 ? t4._callObjectMode ? console.error("showLocalVideo is not available in call object mode") : t4._showLocalVideo = !!r3.showLocalVideo : t4._showLocalVideo = true, r3.showParticipantsBar !== void 0 ? t4._callObjectMode ? console.error("showParticipantsBar is not available in call object mode") : t4._showParticipantsBar = !!r3.showParticipantsBar : t4._showParticipantsBar = true, r3.customTrayButtons !== void 0 ? t4._callObjectMode ? console.error("customTrayButtons is not available in call object mode") : t4._customTrayButtons = r3.customTrayButtons : t4._customTrayButtons = {}, r3.activeSpeakerMode !== void 0 ? t4._callObjectMode ? console.error("activeSpeakerMode is not available in call object mode") : t4._activeSpeakerMode = !!r3.activeSpeakerMode : t4._activeSpeakerMode = false, r3.receiveSettings ? t4._callObjectMode ? t4._receiveSettings = r3.receiveSettings : console.error("receiveSettings is only available in call object mode") : t4._receiveSettings = {}, t4._inputSettings = {}, r3.inputSettings && (t4._inputSettings = r3.inputSettings), t4.validateProperties(r3), t4.properties = _e2({}, r3), t4._callObjectLoader = t4._callObjectMode ? new ee2() : null, t4._meetingState = j2, t4._isPreparingToJoin = false, t4._accessState = { access: "unknown" }, t4._nativeInCallAudioMode = ke2, t4._participants = {}, t4._participantCounts = Se2, t4._rmpPlayerState = {}, t4._waitingParticipants = {}, t4._inputEventsOn = {}, t4._network = { threshold: "good", quality: 100 }, t4._activeSpeaker = {}, t4._callFrameId = Object(J2.c)(), t4._messageChannel = Object(G2.d)() ? new Q2.a() : new H4(), t4._iframe && (t4._iframe.requestFullscreen ? t4._iframe.addEventListener("fullscreenchange", function(e4) {
              document.fullscreenElement === t4._iframe ? (t4.emit("fullscreen", { action: "fullscreen" }), t4.sendMessageToCallMachine({ action: "fullscreen" })) : (t4.emit("exited-fullscreen", { action: "exited-fullscreen" }), t4.sendMessageToCallMachine({ action: "exited-fullscreen" }));
            }) : t4._iframe.webkitRequestFullscreen && t4._iframe.addEventListener("webkitfullscreenchange", function(e4) {
              document.webkitFullscreenElement === t4._iframe ? (t4.emit("fullscreen", { action: "fullscreen" }), t4.sendMessageToCallMachine({ action: "fullscreen" })) : (t4.emit("exited-fullscreen", { action: "exited-fullscreen" }), t4.sendMessageToCallMachine({ action: "exited-fullscreen" }));
            })), Object(G2.d)()) {
              var n3 = t4.nativeUtils();
              n3.addAudioFocusChangeListener && n3.removeAudioFocusChangeListener && n3.addAppActiveStateChangeListener && n3.removeAppActiveStateChangeListener || console.warn("expected (add|remove)(AudioFocus|AppActiveState)ChangeListener to be available in React Native"), t4._hasNativeAudioFocus = true, n3.addAudioFocusChangeListener(t4.handleNativeAudioFocusChange), n3.addAppActiveStateChangeListener(t4.handleNativeAppActiveStateChange);
            }
            return t4._callObjectMode && t4.startListeningForDeviceChanges(), t4._messageChannel.addListenerForMessagesFromCallMachine(t4.handleMessageFromCallMachine, t4._callFrameId, h()(t4)), t4;
          }
          return m()($3, null, [{ key: "supportedBrowser", value: function() {
            if (Object(G2.d)())
              return { supported: true, mobile: true, name: "React Native", version: null, supportsScreenShare: false, supportsSfu: true, supportsVideoProcessing: false };
            var e3 = C2.a.getParser(Object(G2.b)());
            return { supported: !!Object(G2.a)(), mobile: e3.getPlatformType() === "mobile", name: e3.getBrowserName(), version: e3.getBrowserVersion(), supportsFullscreen: !!Object(G2.c)(), supportsScreenShare: !!Object(G2.e)(), supportsSfu: !!Object(G2.f)(), supportsVideoProcessing: Object(G2.g)() };
          } }, { key: "version", value: function() {
            return "0.26.0";
          } }, { key: "createCallObject", value: function() {
            var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return e3.layout = "none", new $3(null, e3);
          } }, { key: "wrap", value: function(e3) {
            var t4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (Le2(), !e3 || !e3.contentWindow || typeof e3.src != "string")
              throw new Error("DailyIframe::Wrap needs an iframe-like first argument");
            return t4.layout || (t4.customLayout ? t4.layout = "custom-v1" : t4.layout = "browser"), new $3(e3, t4);
          } }, { key: "createFrame", value: function(e3, t4) {
            var r3, n3;
            Le2(), e3 && t4 ? (r3 = e3, n3 = t4) : e3 && e3.append ? (r3 = e3, n3 = {}) : (r3 = document.body, n3 = e3 || {});
            var i3 = n3.iframeStyle;
            i3 || (i3 = r3 === document.body ? { position: "fixed", border: "1px solid black", backgroundColor: "white", width: "375px", height: "450px", right: "1em", bottom: "1em" } : { border: 0, width: "100%", height: "100%" });
            var a3 = document.createElement("iframe");
            window.navigator && window.navigator.userAgent.match(/Chrome\/61\./) ? a3.allow = "microphone, camera" : a3.allow = "microphone; camera; autoplay; display-capture", a3.style.visibility = "hidden", r3.appendChild(a3), a3.style.visibility = null, Object.keys(i3).forEach(function(e4) {
              return a3.style[e4] = i3[e4];
            }), n3.layout || (n3.customLayout ? n3.layout = "custom-v1" : n3.layout = "browser");
            try {
              return new $3(a3, n3);
            } catch (e4) {
              throw r3.removeChild(a3), e4;
            }
          } }, { key: "createTransparentFrame", value: function() {
            var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            Le2();
            var t4 = document.createElement("iframe");
            return t4.allow = "microphone; camera; autoplay", t4.style.cssText = "\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      border: 0;\n      pointer-events: none;\n    ", document.body.appendChild(t4), e3.layout || (e3.layout = "custom-v1"), $3.wrap(t4, e3);
          } }]), m()($3, [{ key: "destroy", value: (z3 = l2()(c.a.mark(function e3() {
            var t4, r3, n3;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (e4.prev = 0, ![N2, L2].includes(this._meetingState)) {
                      e4.next = 4;
                      break;
                    }
                    return e4.next = 4, this.leave();
                  case 4:
                    e4.next = 8;
                    break;
                  case 6:
                    e4.prev = 6, e4.t0 = e4.catch(0);
                  case 8:
                    (t4 = this._iframe) && (r3 = t4.parentElement) && r3.removeChild(t4), this._messageChannel.removeListener(this.handleMessageFromCallMachine), Object(G2.d)() && ((n3 = this.nativeUtils()).removeAudioFocusChangeListener(this.handleNativeAudioFocusChange), n3.removeAppActiveStateChangeListener(this.handleNativeAppActiveStateChange)), this._callObjectMode && this.stopListeningForDeviceChanges(), this.resetMeetingDependentVars();
                  case 14:
                  case "end":
                    return e4.stop();
                }
            }, e3, this, [[0, 6]]);
          })), function() {
            return z3.apply(this, arguments);
          }) }, { key: "loadCss", value: function(e3) {
            var t4 = e3.bodyClass, r3 = e3.cssFile, n3 = e3.cssText;
            return Le2(), this.sendMessageToCallMachine({ action: "load-css", cssFile: this.absoluteUrl(r3), bodyClass: t4, cssText: n3 }), this;
          } }, { key: "iframe", value: function() {
            return Le2(), this._iframe;
          } }, { key: "meetingState", value: function() {
            return this._meetingState;
          } }, { key: "accessState", value: function() {
            if (!this._callObjectMode)
              throw new Error("accessState() currently only supported in call object mode");
            return this._accessState;
          } }, { key: "participants", value: function() {
            return this._participants;
          } }, { key: "participantCounts", value: function() {
            return this._participantCounts;
          } }, { key: "waitingParticipants", value: function() {
            if (!this._callObjectMode)
              throw new Error("waitingParticipants() currently only supported in call object mode");
            return this._waitingParticipants;
          } }, { key: "validateParticipantProperties", value: function(e3, t4) {
            for (var r3 in t4) {
              if (!Pe2[r3])
                throw new Error("unrecognized updateParticipant property ".concat(r3));
              if (Pe2[r3].validate && !Pe2[r3].validate(t4[r3], this, this._participants[e3]))
                throw new Error(Pe2[r3].help);
            }
          } }, { key: "updateParticipant", value: function(e3, t4) {
            return this._participants.local && this._participants.local.session_id === e3 && (e3 = "local"), e3 && t4 && this._participants[e3] && (this.validateParticipantProperties(e3, t4), this.sendMessageToCallMachine({ action: "update-participant", id: e3, properties: t4 })), this;
          } }, { key: "updateParticipants", value: function(e3) {
            var t4 = this._participants.local && this._participants.local.session_id;
            for (var r3 in e3)
              r3 === t4 && (r3 = "local"), r3 && e3[r3] && (this._participants[r3] || r3 === "*") ? this.validateParticipantProperties(r3, e3[r3]) : (console.warn("unrecognized participant in updateParticipants: ".concat(r3)), delete e3[r3]);
            return this.sendMessageToCallMachine({ action: "update-participants", participants: e3 }), this;
          } }, { key: "updateWaitingParticipant", value: (W3 = l2()(c.a.mark(function e3() {
            var t4, r3, n3 = this, i3 = arguments;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (t4 = i3.length > 0 && i3[0] !== void 0 ? i3[0] : "", r3 = i3.length > 1 && i3[1] !== void 0 ? i3[1] : {}, this._callObjectMode) {
                      e4.next = 4;
                      break;
                    }
                    throw new Error("updateWaitingParticipant() currently only supported in call object mode");
                  case 4:
                    if (this._meetingState === N2) {
                      e4.next = 6;
                      break;
                    }
                    throw new Error("updateWaitingParticipant() only supported for joined meetings");
                  case 6:
                    if (typeof t4 == "string" && T2()(r3) === "object") {
                      e4.next = 8;
                      break;
                    }
                    throw new Error("updateWaitingParticipant() must take an id string and a updates object");
                  case 8:
                    return e4.abrupt("return", new Promise(function(e5, i4) {
                      n3.sendMessageToCallMachine({ action: "daily-method-update-waiting-participant", id: t4, updates: r3 }, function(t5) {
                        t5.error && i4(t5.error), t5.id || i4(new Error("unknown error in updateWaitingParticipant()")), e5({ id: t5.id });
                      });
                    }));
                  case 9:
                  case "end":
                    return e4.stop();
                }
            }, e3, this);
          })), function() {
            return W3.apply(this, arguments);
          }) }, { key: "updateWaitingParticipants", value: (q3 = l2()(c.a.mark(function e3() {
            var t4, r3 = this, n3 = arguments;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (t4 = n3.length > 0 && n3[0] !== void 0 ? n3[0] : {}, this._callObjectMode) {
                      e4.next = 3;
                      break;
                    }
                    throw new Error("updateWaitingParticipants() currently only supported in call object mode");
                  case 3:
                    if (this._meetingState === N2) {
                      e4.next = 5;
                      break;
                    }
                    throw new Error("updateWaitingParticipants() only supported for joined meetings");
                  case 5:
                    if (T2()(t4) === "object") {
                      e4.next = 7;
                      break;
                    }
                    throw new Error("updateWaitingParticipants() must take a mapping between ids and update objects");
                  case 7:
                    return e4.abrupt("return", new Promise(function(e5, n4) {
                      r3.sendMessageToCallMachine({ action: "daily-method-update-waiting-participants", updatesById: t4 }, function(t5) {
                        t5.error && n4(t5.error), t5.ids || n4(new Error("unknown error in updateWaitingParticipants()")), e5({ ids: t5.ids });
                      });
                    }));
                  case 8:
                  case "end":
                    return e4.stop();
                }
            }, e3, this);
          })), function() {
            return q3.apply(this, arguments);
          }) }, { key: "requestAccess", value: (Y3 = l2()(c.a.mark(function e3() {
            var t4, r3, n3, i3, a3, o2 = this, s4 = arguments;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (t4 = s4.length > 0 && s4[0] !== void 0 ? s4[0] : {}, r3 = t4.access, n3 = r3 === void 0 ? { level: "full" } : r3, i3 = t4.name, a3 = i3 === void 0 ? "" : i3, this._callObjectMode) {
                      e4.next = 3;
                      break;
                    }
                    throw new Error("requestAccess() currently only supported in call object mode");
                  case 3:
                    if (this._meetingState === N2) {
                      e4.next = 5;
                      break;
                    }
                    throw new Error("requestAccess() only supported for joined meetings");
                  case 5:
                    return e4.abrupt("return", new Promise(function(e5, t5) {
                      o2.sendMessageToCallMachine({ action: "daily-method-request-access", access: n3, name: a3 }, function(r4) {
                        r4.error && t5(r4.error), r4.access || t5(new Error("unknown error in requestAccess()")), e5({ access: r4.access, granted: r4.granted });
                      });
                    }));
                  case 6:
                  case "end":
                    return e4.stop();
                }
            }, e3, this);
          })), function() {
            return Y3.apply(this, arguments);
          }) }, { key: "localAudio", value: function() {
            return this._participants.local ? this._participants.local.audio : null;
          } }, { key: "localVideo", value: function() {
            return this._participants.local ? this._participants.local.video : null;
          } }, { key: "setLocalAudio", value: function(e3) {
            return this.sendMessageToCallMachine({ action: "local-audio", state: e3 }), this;
          } }, { key: "setLocalVideo", value: function(e3) {
            return this.sendMessageToCallMachine({ action: "local-video", state: e3 }), this;
          } }, { key: "getReceiveSettings", value: (F3 = l2()(c.a.mark(function e3(t4) {
            var r3, n3, i3, a3 = this, o2 = arguments;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (r3 = o2.length > 1 && o2[1] !== void 0 ? o2[1] : {}, n3 = r3.showInheritedValues, i3 = n3 !== void 0 && n3, this._callObjectMode) {
                      e4.next = 3;
                      break;
                    }
                    throw new Error("getReceiveSettings() only supported in call object mode");
                  case 3:
                    e4.t0 = T2()(t4), e4.next = e4.t0 === "string" ? 6 : e4.t0 === "undefined" ? 7 : 8;
                    break;
                  case 6:
                    return e4.abrupt("return", new Promise(function(e5) {
                      a3.sendMessageToCallMachine({ action: "get-single-participant-receive-settings", id: t4, showInheritedValues: i3 }, function(t5) {
                        e5(t5.receiveSettings);
                      });
                    }));
                  case 7:
                    return e4.abrupt("return", this._receiveSettings);
                  case 8:
                    throw new Error('first argument to getReceiveSettings() must be a participant id (or "base"), or there should be no arguments');
                  case 9:
                  case "end":
                    return e4.stop();
                }
            }, e3, this);
          })), function(e3) {
            return F3.apply(this, arguments);
          }) }, { key: "updateReceiveSettings", value: (P3 = l2()(c.a.mark(function e3(t4) {
            var r3 = this;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (this._callObjectMode) {
                      e4.next = 2;
                      break;
                    }
                    throw new Error("updateReceiveSettings() only supported in call object mode");
                  case 2:
                    if (Ne2(t4, { allowAllParticipantsKey: true })) {
                      e4.next = 4;
                      break;
                    }
                    throw new Error(Fe2({ allowAllParticipantsKey: true }));
                  case 4:
                    if (this._meetingState === N2) {
                      e4.next = 6;
                      break;
                    }
                    throw new Error("updateReceiveSettings() is only allowed when joined. To specify receive settings earlier, use the receiveSettings config property.");
                  case 6:
                    return e4.abrupt("return", new Promise(function(e5) {
                      r3.sendMessageToCallMachine({ action: "update-receive-settings", receiveSettings: t4 }, function(t5) {
                        e5({ receiveSettings: t5.receiveSettings });
                      });
                    }));
                  case 7:
                  case "end":
                    return e4.stop();
                }
            }, e3, this);
          })), function(e3) {
            return P3.apply(this, arguments);
          }) }, { key: "getInputSettings", value: function() {
            var e3 = this;
            return new Promise(function(t4) {
              t4(e3._inputSettings);
            });
          } }, { key: "updateInputSettings", value: (A4 = l2()(c.a.mark(function e3(t4) {
            var r3 = this;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    return e4.abrupt("return", new Promise(function(e5, n3) {
                      if (!Re2(t4))
                        return console.error(De2()), void n3(De2());
                      r3.sendMessageToCallMachine({ action: "update-input-settings", inputSettings: t4 }, function(t5) {
                        t5.error ? n3(t5.error) : e5({ inputSettings: t5.inputSettings });
                      });
                    }));
                  case 1:
                  case "end":
                    return e4.stop();
                }
            }, e3);
          })), function(e3) {
            return A4.apply(this, arguments);
          }) }, { key: "setBandwidth", value: function(e3) {
            var t4 = e3.kbs, r3 = e3.trackConstraints;
            return Le2(), this.sendMessageToCallMachine({ action: "set-bandwidth", kbs: t4, trackConstraints: r3 }), this;
          } }, { key: "getDailyLang", value: function() {
            var e3 = this;
            return Le2(), new Promise(function() {
              var t4 = l2()(c.a.mark(function t5(r3) {
                var n3;
                return c.a.wrap(function(t6) {
                  for (; ; )
                    switch (t6.prev = t6.next) {
                      case 0:
                        n3 = function(e4) {
                          delete e4.action, delete e4.callbackStamp, r3(e4);
                        }, e3.sendMessageToCallMachine({ action: "get-daily-lang" }, n3);
                      case 2:
                      case "end":
                        return t6.stop();
                    }
                }, t5);
              }));
              return function(e4) {
                return t4.apply(this, arguments);
              };
            }());
          } }, { key: "setDailyLang", value: function(e3) {
            return Le2(), this.sendMessageToCallMachine({ action: "set-daily-lang", lang: e3 }), this;
          } }, { key: "getMeetingSession", value: (E3 = l2()(c.a.mark(function e3() {
            var t4 = this;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (this._meetingState === N2) {
                      e4.next = 2;
                      break;
                    }
                    throw new Error("getMeetingSession() is only allowed when joined");
                  case 2:
                    return e4.abrupt("return", new Promise(function() {
                      var e5 = l2()(c.a.mark(function e6(r3) {
                        var n3;
                        return c.a.wrap(function(e7) {
                          for (; ; )
                            switch (e7.prev = e7.next) {
                              case 0:
                                n3 = function(e8) {
                                  delete e8.action, delete e8.callbackStamp, delete e8.callFrameId, r3(e8);
                                }, t4.sendMessageToCallMachine({ action: "get-meeting-session" }, n3);
                              case 2:
                              case "end":
                                return e7.stop();
                            }
                        }, e6);
                      }));
                      return function(t5) {
                        return e5.apply(this, arguments);
                      };
                    }()));
                  case 3:
                  case "end":
                    return e4.stop();
                }
            }, e3, this);
          })), function() {
            return E3.apply(this, arguments);
          }) }, { key: "setUserName", value: function(e3, t4) {
            var r3 = this;
            return this.properties.userName = e3, new Promise(function() {
              var n3 = l2()(c.a.mark(function n4(i3) {
                var a3;
                return c.a.wrap(function(n5) {
                  for (; ; )
                    switch (n5.prev = n5.next) {
                      case 0:
                        a3 = function(e4) {
                          delete e4.action, delete e4.callbackStamp, i3(e4);
                        }, r3.sendMessageToCallMachine({ action: "set-user-name", name: e3 != null ? e3 : "", thisMeetingOnly: Object(G2.d)() || !!t4 && !!t4.thisMeetingOnly }, a3);
                      case 2:
                      case "end":
                        return n5.stop();
                    }
                }, n4);
              }));
              return function(e4) {
                return n3.apply(this, arguments);
              };
            }());
          } }, { key: "startCamera", value: function() {
            var e3 = this, t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            if (!this._callObjectMode)
              throw new Error("startCamera() currently only supported in call object mode");
            if ([I3, N2].includes(this._meetingState))
              throw new Error("startCamera() not supported after joining a meeting: did you mean to use setLocalAudio() and/or setLocalVideo() instead?");
            return new Promise(function() {
              var r3 = l2()(c.a.mark(function r4(n3, i3) {
                var a3;
                return c.a.wrap(function(r5) {
                  for (; ; )
                    switch (r5.prev = r5.next) {
                      case 0:
                        if (a3 = function(e4) {
                          delete e4.action, delete e4.callbackStamp, n3(e4);
                        }, !e3.needsLoad()) {
                          r5.next = 12;
                          break;
                        }
                        return r5.prev = 2, r5.next = 5, e3.load(t4);
                      case 5:
                        r5.next = 10;
                        break;
                      case 7:
                        r5.prev = 7, r5.t0 = r5.catch(2), i3(r5.t0);
                      case 10:
                        r5.next = 13;
                        break;
                      case 12:
                        e3.validateProperties(t4);
                      case 13:
                        e3.sendMessageToCallMachine({ action: "start-camera", properties: je2(e3.properties), preloadCache: je2(e3._preloadCache) }, a3);
                      case 14:
                      case "end":
                        return r5.stop();
                    }
                }, r4, null, [[2, 7]]);
              }));
              return function(e4, t5) {
                return r3.apply(this, arguments);
              };
            }());
          } }, { key: "setCamera", value: function(e3) {
            var t4 = this;
            if (Ie2(), this.needsLoad())
              throw new Error("Before you can invoke setCamera, first you need to invoke one of these methods: join, startCamera, or preAuth");
            return new Promise(function(r3, n3) {
              t4.sendMessageToCallMachine({ action: "set-camera", cameraDeviceId: e3 }, function(e4) {
                r3({ device: e4.device });
              });
            });
          } }, { key: "setAudioDevice", value: (M3 = l2()(c.a.mark(function e3(t4) {
            var r3;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    return Ie2(), this.nativeUtils().setAudioDevice(t4), e4.next = 4, this.nativeUtils().getAudioDevice();
                  case 4:
                    return r3 = e4.sent, e4.abrupt("return", { deviceId: r3 });
                  case 6:
                  case "end":
                    return e4.stop();
                }
            }, e3, this);
          })), function(e3) {
            return M3.apply(this, arguments);
          }) }, { key: "cycleCamera", value: function() {
            var e3 = this;
            return new Promise(function(t4, r3) {
              e3.sendMessageToCallMachine({ action: "cycle-camera" }, function(e4) {
                t4({ device: e4.device });
              });
            });
          } }, { key: "cycleMic", value: function() {
            var e3 = this;
            return Le2(), new Promise(function(t4, r3) {
              e3.sendMessageToCallMachine({ action: "cycle-mic" }, function(e4) {
                t4({ device: e4.device });
              });
            });
          } }, { key: "getCameraFacingMode", value: function() {
            var e3 = this;
            return Ie2(), new Promise(function(t4, r3) {
              e3.sendMessageToCallMachine({ action: "get-camera-facing-mode" }, function(e4) {
                t4(e4.facingMode);
              });
            });
          } }, { key: "setInputDevices", value: function(e3) {
            var t4 = e3.audioDeviceId, r3 = e3.videoDeviceId, n3 = e3.audioSource, i3 = e3.videoSource;
            return console.warn("setInputDevices() is deprecated: instead use setInputDevicesAsync(), which returns a Promise"), this.setInputDevicesAsync({ audioDeviceId: t4, videoDeviceId: r3, audioSource: n3, videoSource: i3 }), this;
          } }, { key: "setInputDevicesAsync", value: (k3 = l2()(c.a.mark(function e3(t4) {
            var r3, n3, i3, a3, o2 = this;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (r3 = t4.audioDeviceId, n3 = t4.videoDeviceId, i3 = t4.audioSource, a3 = t4.videoSource, Le2(), i3 !== void 0 && (r3 = i3), a3 !== void 0 && (n3 = a3), r3 && (this._preloadCache.audioDeviceId = r3), n3 && (this._preloadCache.videoDeviceId = n3), !this._callObjectMode || !this.needsLoad()) {
                      e4.next = 8;
                      break;
                    }
                    return e4.abrupt("return", { camera: { deviceId: this._preloadCache.videoDeviceId }, mic: { deviceId: this._preloadCache.audioDeviceId }, speaker: { deviceId: this._preloadCache.outputDeviceId } });
                  case 8:
                    return r3 instanceof MediaStreamTrack && (r3 = "daily-custom-track"), n3 instanceof MediaStreamTrack && (n3 = "daily-custom-track"), e4.abrupt("return", new Promise(function(e5) {
                      o2.sendMessageToCallMachine({ action: "set-input-devices", audioDeviceId: r3, videoDeviceId: n3 }, function(t5) {
                        delete t5.action, delete t5.callbackStamp, t5.returnPreloadCache ? e5({ camera: { deviceId: o2._preloadCache.videoDeviceId }, mic: { deviceId: o2._preloadCache.audioDeviceId }, speaker: { deviceId: o2._preloadCache.outputDeviceId } }) : e5(t5);
                      });
                    }));
                  case 11:
                  case "end":
                    return e4.stop();
                }
            }, e3, this);
          })), function(e3) {
            return k3.apply(this, arguments);
          }) }, { key: "setOutputDevice", value: function(e3) {
            var t4 = e3.outputDeviceId;
            return Le2(), t4 && (this._preloadCache.outputDeviceId = t4), this._callObjectMode && this._meetingState !== N2 && !this._didPreAuth ? (console.warn("setOutputDevice() not supported before preAuth() or join()"), this) : (this.sendMessageToCallMachine({ action: "set-output-device", outputDeviceId: t4 }), this);
          } }, { key: "getInputDevices", value: (w3 = l2()(c.a.mark(function e3() {
            var t4 = this;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (!this._callObjectMode || !this.needsLoad()) {
                      e4.next = 2;
                      break;
                    }
                    return e4.abrupt("return", { camera: { deviceId: this._preloadCache.videoDeviceId }, mic: { deviceId: this._preloadCache.audioDeviceId }, speaker: { deviceId: this._preloadCache.outputDeviceId } });
                  case 2:
                    return e4.abrupt("return", new Promise(function(e5, r3) {
                      t4.sendMessageToCallMachine({ action: "get-input-devices" }, function(r4) {
                        delete r4.action, delete r4.callbackStamp, r4.returnPreloadCache ? e5({ camera: { deviceId: t4._preloadCache.videoDeviceId }, mic: { deviceId: t4._preloadCache.audioDeviceId }, speaker: { deviceId: t4._preloadCache.outputDeviceId } }) : e5(r4);
                      });
                    }));
                  case 3:
                  case "end":
                    return e4.stop();
                }
            }, e3, this);
          })), function() {
            return w3.apply(this, arguments);
          }) }, { key: "nativeInCallAudioMode", value: function() {
            return Ie2(), this._nativeInCallAudioMode;
          } }, { key: "setNativeInCallAudioMode", value: function(e3) {
            if (Ie2(), [ke2, Me2].includes(e3)) {
              if (e3 !== this._nativeInCallAudioMode)
                return this._nativeInCallAudioMode = e3, !this.disableReactNativeAutoDeviceManagement("audio") && this.isMeetingPendingOrOngoing(this._meetingState, this._isPreparingToJoin) && this.nativeUtils().setAudioMode(this._nativeInCallAudioMode), this;
            } else
              console.error("invalid in-call audio mode specified: ", e3);
          } }, { key: "preAuth", value: (_2 = l2()(c.a.mark(function e3() {
            var t4, r3, n3, i3 = this, a3 = arguments;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (t4 = a3.length > 0 && a3[0] !== void 0 ? a3[0] : {}, this._callObjectMode) {
                      e4.next = 3;
                      break;
                    }
                    throw new Error("preAuth() currently only supported in call object mode");
                  case 3:
                    if (![I3, N2].includes(this._meetingState)) {
                      e4.next = 5;
                      break;
                    }
                    throw new Error("preAuth() not supported after joining a meeting");
                  case 5:
                    if (!this.needsLoad()) {
                      e4.next = 8;
                      break;
                    }
                    return e4.next = 8, this.load(t4);
                  case 8:
                    if (t4.url) {
                      e4.next = 10;
                      break;
                    }
                    throw new Error("preAuth() requires at least a url to be provided");
                  case 10:
                    if (r3 = Object(J2.a)(t4.url), n3 = Object(J2.a)(this.properties.url || this.properties.baseUrl), r3 === n3) {
                      e4.next = 14;
                      break;
                    }
                    throw new Error("url in preAuth() has a different bundle url than the one loaded (".concat(n3, " -> ").concat(r3, ")"));
                  case 14:
                    return this.validateProperties(t4), this.properties = _e2(_e2({}, this.properties), t4), e4.abrupt("return", new Promise(function(e5, t5) {
                      i3.sendMessageToCallMachine({ action: "daily-method-preauth", properties: je2(i3.properties) }, function(r4) {
                        return r4.error ? t5(r4.error) : r4.access ? (i3._didPreAuth = true, void e5({ access: r4.access })) : t5(new Error("unknown error in preAuth()"));
                      });
                    }));
                  case 17:
                  case "end":
                    return e4.stop();
                }
            }, e3, this);
          })), function() {
            return _2.apply(this, arguments);
          }) }, { key: "load", value: (b2 = l2()(c.a.mark(function e3(t4) {
            var r3 = this;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (this.needsLoad()) {
                      e4.next = 2;
                      break;
                    }
                    return e4.abrupt("return");
                  case 2:
                    if (t4 && (this.validateProperties(t4), this.properties = _e2(_e2({}, this.properties), t4)), this._callObjectMode || this.properties.url) {
                      e4.next = 5;
                      break;
                    }
                    throw new Error("can't load iframe meeting because url property isn't set");
                  case 5:
                    this.updateMeetingState(L2);
                    try {
                      this.emit("loading", { action: "loading" });
                    } catch (e5) {
                      console.log("could not emit 'loading'", e5);
                    }
                    if (!this._callObjectMode) {
                      e4.next = 11;
                      break;
                    }
                    return e4.abrupt("return", new Promise(function(e5, t5) {
                      r3._callObjectLoader.cancel(), r3._callObjectLoader.load(r3.properties.url || r3.properties.baseUrl, r3._callFrameId, function(t6) {
                        r3.updateMeetingState("loaded"), t6 && r3.emit("loaded", { action: "loaded" }), e5();
                      }, function(e6, n3) {
                        r3.emit("load-attempt-failed", { action: "load-attempt-failed", errorMsg: e6 }), n3 || (r3.updateMeetingState(D2), r3.resetMeetingDependentVars(), r3.emit("error", { action: "error", errorMsg: e6 }), t5(e6));
                      });
                    }));
                  case 11:
                    return this._iframe.src = this.assembleMeetingUrl(), e4.abrupt("return", new Promise(function(e5, t5) {
                      r3._loadedCallback = function(n3) {
                        if (r3._meetingState !== D2) {
                          for (var i3 in r3.updateMeetingState("loaded"), (r3.properties.cssFile || r3.properties.cssText) && r3.loadCss(r3.properties), r3._inputEventsOn)
                            r3.sendMessageToCallMachine({ action: "register-input-handler", on: i3 });
                          e5();
                        } else
                          t5(n3);
                      };
                    }));
                  case 13:
                  case "end":
                    return e4.stop();
                }
            }, e3, this);
          })), function(e3) {
            return b2.apply(this, arguments);
          }) }, { key: "join", value: (g2 = l2()(c.a.mark(function e3() {
            var t4, r3, n3, i3, a3 = this, o2 = arguments;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (t4 = o2.length > 0 && o2[0] !== void 0 ? o2[0] : {}, r3 = false, !this.needsLoad()) {
                      e4.next = 15;
                      break;
                    }
                    return this.updateIsPreparingToJoin(true), e4.prev = 4, e4.next = 7, this.load(t4);
                  case 7:
                    e4.next = 13;
                    break;
                  case 9:
                    return e4.prev = 9, e4.t0 = e4.catch(4), this.updateIsPreparingToJoin(false), e4.abrupt("return", Promise.reject(e4.t0));
                  case 13:
                    e4.next = 42;
                    break;
                  case 15:
                    if (r3 = !(!this.properties.cssFile && !this.properties.cssText), !this._didPreAuth) {
                      e4.next = 25;
                      break;
                    }
                    if (!t4.url || t4.url === this.properties.url) {
                      e4.next = 21;
                      break;
                    }
                    return console.error("url in join() is different than the one used in preAuth()"), this.updateIsPreparingToJoin(false), e4.abrupt("return", Promise.reject());
                  case 21:
                    if (!t4.token || t4.token === this.properties.token) {
                      e4.next = 25;
                      break;
                    }
                    return console.error("token in join() is different than the one used in preAuth()"), this.updateIsPreparingToJoin(false), e4.abrupt("return", Promise.reject());
                  case 25:
                    if (!t4.url) {
                      e4.next = 40;
                      break;
                    }
                    if (!this._callObjectMode) {
                      e4.next = 36;
                      break;
                    }
                    if (n3 = Object(J2.a)(t4.url), i3 = Object(J2.a)(this.properties.url || this.properties.baseUrl), n3 === i3) {
                      e4.next = 33;
                      break;
                    }
                    return console.error("url in join() has a different bundle url than the one loaded (".concat(i3, " -> ").concat(n3, ")")), this.updateIsPreparingToJoin(false), e4.abrupt("return", Promise.reject());
                  case 33:
                    this.properties.url = t4.url, e4.next = 40;
                    break;
                  case 36:
                    if (!t4.url || t4.url === this.properties.url) {
                      e4.next = 40;
                      break;
                    }
                    return console.error("url in join() is different than the one used in load() (".concat(this.properties.url, " -> ").concat(t4.url, ")")), this.updateIsPreparingToJoin(false), e4.abrupt("return", Promise.reject());
                  case 40:
                    this.validateProperties(t4), this.properties = _e2(_e2({}, this.properties), t4);
                  case 42:
                    if (t4.showLocalVideo !== void 0 && (this._callObjectMode ? console.error("showLocalVideo is not available in callObject mode") : this._showLocalVideo = !!t4.showLocalVideo), t4.showParticipantsBar !== void 0 && (this._callObjectMode ? console.error("showParticipantsBar is not available in callObject mode") : this._showParticipantsBar = !!t4.showParticipantsBar), this._meetingState !== N2 && this._meetingState !== I3) {
                      e4.next = 48;
                      break;
                    }
                    return console.warn("already joined meeting, call leave() before joining again"), this.updateIsPreparingToJoin(false), e4.abrupt("return");
                  case 48:
                    this.updateMeetingState(I3, false);
                    try {
                      this.emit("joining-meeting", { action: "joining-meeting" });
                    } catch (e5) {
                      console.log("could not emit 'joining-meeting'", e5);
                    }
                    return this.sendMessageToCallMachine({ action: "join-meeting", properties: je2(this.properties), preloadCache: je2(this._preloadCache) }), e4.abrupt("return", new Promise(function(e5, t5) {
                      a3._joinedCallback = function(n4, i4) {
                        if (a3._meetingState !== D2) {
                          if (a3.updateMeetingState(N2), n4)
                            for (var o3 in n4)
                              a3._callObjectMode && (ve2(n4[o3]), me2(n4[o3]), ye2(n4[o3], a3._participants[o3])), a3._participants[o3] = _e2({}, n4[o3]), a3.toggleParticipantAudioBasedOnNativeAudioFocus();
                          r3 && a3.loadCss(a3.properties), e5(n4);
                        } else
                          t5(i4);
                      };
                    }));
                  case 52:
                  case "end":
                    return e4.stop();
                }
            }, e3, this, [[4, 9]]);
          })), function() {
            return g2.apply(this, arguments);
          }) }, { key: "leave", value: (v3 = l2()(c.a.mark(function e3() {
            var t4 = this;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    return e4.abrupt("return", new Promise(function(e5, r3) {
                      if (t4._callObjectLoader && !t4._callObjectLoader.loaded) {
                        t4._callObjectLoader.cancel(), t4.updateMeetingState(R3), t4.resetMeetingDependentVars();
                        try {
                          t4.emit(R3, { action: R3 });
                        } catch (e6) {
                          console.log("could not emit 'left-meeting'", e6);
                        }
                        e5();
                      } else
                        t4._meetingState === R3 || t4._meetingState === D2 ? e5() : (t4._leftCallback = function() {
                          t4._meetingState !== D2 && t4.updateMeetingState(R3), t4.resetMeetingDependentVars(), e5();
                        }, t4.sendMessageToCallMachine({ action: "leave-meeting" }));
                    }));
                  case 1:
                  case "end":
                    return e4.stop();
                }
            }, e3);
          })), function() {
            return v3.apply(this, arguments);
          }) }, { key: "startScreenShare", value: function() {
            var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            Le2(), e3.mediaStream && (this._preloadCache.screenMediaStream = e3.mediaStream, e3.mediaStream = "daily-custom-track"), this.sendMessageToCallMachine({ action: "local-screen-start", captureOptions: e3 });
          } }, { key: "stopScreenShare", value: function() {
            Le2(), this.sendMessageToCallMachine({ action: "local-screen-stop" });
          } }, { key: "startRecording", value: function() {
            var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.sendMessageToCallMachine(_e2({ action: "local-recording-start" }, e3));
          } }, { key: "updateRecording", value: function(e3) {
            var t4 = e3.layout, r3 = t4 === void 0 ? { preset: "default" } : t4;
            this.sendMessageToCallMachine({ action: "daily-method-update-recording", layout: r3 });
          } }, { key: "stopRecording", value: function() {
            this.sendMessageToCallMachine({ action: "local-recording-stop" });
          } }, { key: "startLiveStreaming", value: function() {
            var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.sendMessageToCallMachine(_e2({ action: "daily-method-start-live-streaming" }, e3));
          } }, { key: "updateLiveStreaming", value: function(e3) {
            var t4 = e3.layout, r3 = t4 === void 0 ? { preset: "default" } : t4;
            this.sendMessageToCallMachine({ action: "daily-method-update-live-streaming", layout: r3 });
          } }, { key: "stopLiveStreaming", value: function() {
            this.sendMessageToCallMachine({ action: "daily-method-stop-live-streaming" });
          } }, { key: "startRemoteMediaPlayer", value: (p3 = l2()(c.a.mark(function e3(t4) {
            var r3, n3, i3, a3 = this;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    r3 = t4.url, n3 = t4.settings, i3 = n3 === void 0 ? { state: B2.PLAY } : n3, e4.prev = 1, Ve2(r3), Ue2(i3), Ge2(i3), e4.next = 12;
                    break;
                  case 7:
                    throw e4.prev = 7, e4.t0 = e4.catch(1), console.error("invalid argument Error: ".concat(e4.t0)), console.error('startRemoteMediaPlayer arguments must be of the form: \n  { url: "playback url", \n  settings?: \n  {state: "play"|"pause", simulcastEncodings?: [{}] } }'), e4.t0;
                  case 12:
                    return e4.abrupt("return", new Promise(function() {
                      var e5 = l2()(c.a.mark(function e6(t5, n4) {
                        var o2;
                        return c.a.wrap(function(e7) {
                          for (; ; )
                            switch (e7.prev = e7.next) {
                              case 0:
                                o2 = function(e8) {
                                  e8.error ? n4({ error: e8.error, errorMsg: e8.errorMsg }) : t5({ session_id: e8.session_id, remoteMediaPlayerState: { state: e8.state, settings: e8.settings } });
                                }, a3.sendMessageToCallMachine({ action: "daily-method-start-remote-media-player", url: r3, settings: i3 }, o2);
                              case 2:
                              case "end":
                                return e7.stop();
                            }
                        }, e6);
                      }));
                      return function(t5, r4) {
                        return e5.apply(this, arguments);
                      };
                    }()));
                  case 13:
                  case "end":
                    return e4.stop();
                }
            }, e3, null, [[1, 7]]);
          })), function(e3) {
            return p3.apply(this, arguments);
          }) }, { key: "stopRemoteMediaPlayer", value: (d3 = l2()(c.a.mark(function e3(t4) {
            var r3 = this;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (typeof t4 == "string") {
                      e4.next = 2;
                      break;
                    }
                    throw new Error(" remotePlayerID must be of type string");
                  case 2:
                    return e4.abrupt("return", new Promise(function() {
                      var e5 = l2()(c.a.mark(function e6(n3, i3) {
                        var a3;
                        return c.a.wrap(function(e7) {
                          for (; ; )
                            switch (e7.prev = e7.next) {
                              case 0:
                                a3 = function(e8) {
                                  e8.error ? i3({ error: e8.error, errorMsg: e8.errorMsg }) : n3();
                                }, r3.sendMessageToCallMachine({ action: "daily-method-stop-remote-media-player", session_id: t4 }, a3);
                              case 2:
                              case "end":
                                return e7.stop();
                            }
                        }, e6);
                      }));
                      return function(t5, r4) {
                        return e5.apply(this, arguments);
                      };
                    }()));
                  case 3:
                  case "end":
                    return e4.stop();
                }
            }, e3);
          })), function(e3) {
            return d3.apply(this, arguments);
          }) }, { key: "updateRemoteMediaPlayer", value: (u2 = l2()(c.a.mark(function e3(t4) {
            var r3, n3, i3 = this;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    r3 = t4.session_id, n3 = t4.settings, e4.prev = 1, Ue2(n3), e4.next = 10;
                    break;
                  case 5:
                    throw e4.prev = 5, e4.t0 = e4.catch(1), console.error("invalid argument Error: ".concat(e4.t0)), console.error('updateRemoteMediaPlayer arguments must be of the form: \n  session_id: "participant session", \n  { settings?: {state: "play"|"pause"} }'), e4.t0;
                  case 10:
                    return e4.abrupt("return", new Promise(function() {
                      var e5 = l2()(c.a.mark(function e6(t5, a3) {
                        var o2;
                        return c.a.wrap(function(e7) {
                          for (; ; )
                            switch (e7.prev = e7.next) {
                              case 0:
                                o2 = function(e8) {
                                  e8.error ? a3({ error: e8.error, errorMsg: e8.errorMsg }) : t5({ session_id: e8.session_id, remoteMediaPlayerState: { state: e8.state, settings: e8.settings } });
                                }, i3.sendMessageToCallMachine({ action: "daily-method-update-remote-media-player", session_id: r3, settings: n3 }, o2);
                              case 2:
                              case "end":
                                return e7.stop();
                            }
                        }, e6);
                      }));
                      return function(t5, r4) {
                        return e5.apply(this, arguments);
                      };
                    }()));
                  case 11:
                  case "end":
                    return e4.stop();
                }
            }, e3, null, [[1, 5]]);
          })), function(e3) {
            return u2.apply(this, arguments);
          }) }, { key: "startTranscription", value: function() {
            this.sendMessageToCallMachine({ action: "daily-method-start-transcription" });
          } }, { key: "stopTranscription", value: function() {
            this.sendMessageToCallMachine({ action: "daily-method-stop-transcription" });
          } }, { key: "getNetworkStats", value: function() {
            var e3 = this;
            if (this._meetingState !== N2) {
              return { stats: { latest: {} } };
            }
            return new Promise(function(t4, r3) {
              e3.sendMessageToCallMachine({ action: "get-calc-stats" }, function(r4) {
                t4(_e2({ stats: r4.stats }, e3._network));
              });
            });
          } }, { key: "getActiveSpeaker", value: function() {
            return Le2(), this._activeSpeaker;
          } }, { key: "setActiveSpeakerMode", value: function(e3) {
            return Le2(), this.sendMessageToCallMachine({ action: "set-active-speaker-mode", enabled: e3 }), this;
          } }, { key: "activeSpeakerMode", value: function() {
            return Le2(), this._activeSpeakerMode;
          } }, { key: "subscribeToTracksAutomatically", value: function() {
            return this._preloadCache.subscribeToTracksAutomatically;
          } }, { key: "setSubscribeToTracksAutomatically", value: function(e3) {
            if (this._meetingState !== N2)
              throw new Error("setSubscribeToTracksAutomatically() is only allowed when joined");
            return this._preloadCache.subscribeToTracksAutomatically = e3, this.sendMessageToCallMachine({ action: "daily-method-subscribe-to-tracks-automatically", enabled: e3 }), this;
          } }, { key: "enumerateDevices", value: (s3 = l2()(c.a.mark(function e3() {
            var t4, r3 = this;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (!this._callObjectMode) {
                      e4.next = 5;
                      break;
                    }
                    return e4.next = 3, navigator.mediaDevices.enumerateDevices();
                  case 3:
                    return t4 = e4.sent, e4.abrupt("return", { devices: t4.map(function(e5) {
                      return JSON.parse(JSON.stringify(e5));
                    }) });
                  case 5:
                    return e4.abrupt("return", new Promise(function(e5, t5) {
                      r3.sendMessageToCallMachine({ action: "enumerate-devices" }, function(t6) {
                        e5({ devices: t6.devices });
                      });
                    }));
                  case 6:
                  case "end":
                    return e4.stop();
                }
            }, e3, this);
          })), function() {
            return s3.apply(this, arguments);
          }) }, { key: "sendAppMessage", value: function(e3) {
            var t4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "*";
            if (JSON.stringify(e3).length > 4096)
              throw new Error("Message data too large. Max size is 4096");
            return this.sendMessageToCallMachine({ action: "app-msg", data: e3, to: t4 }), this;
          } }, { key: "addFakeParticipant", value: function(e3) {
            return Le2(), this.sendMessageToCallMachine(_e2({ action: "add-fake-participant" }, e3)), this;
          } }, { key: "setShowNamesMode", value: function(e3) {
            return Le2(), e3 && e3 !== "always" && e3 !== "never" ? (console.error('setShowNamesMode argument should be "always", "never", or false'), this) : (this.sendMessageToCallMachine({ action: "set-show-names", mode: e3 }), this);
          } }, { key: "setShowLocalVideo", value: function() {
            var e3 = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0];
            return Le2(), typeof e3 != "boolean" ? (console.error("setShowLocalVideo only accepts a boolean value"), this) : this._callObjectMode ? (console.error("setShowLocalVideo is not available in callObject mode"), this) : this._meetingState !== N2 ? (console.error("the meeting must be joined before calling setShowLocalVideo"), this) : (this.sendMessageToCallMachine({ action: "set-show-local-video", show: e3 }), this._showLocalVideo = e3, this);
          } }, { key: "showLocalVideo", value: function() {
            return Le2(), this._callObjectMode ? (console.error("showLocalVideo is not available in callObject mode"), this) : this._showLocalVideo;
          } }, { key: "setShowParticipantsBar", value: function() {
            var e3 = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0];
            return Le2(), typeof e3 != "boolean" ? (console.error("setShowParticipantsBar only accepts a boolean value"), this) : this._callObjectMode ? (console.error("setShowParticipantsBar is not available in callObject mode"), this) : this._meetingState !== N2 ? (console.error("the meeting must be joined before calling setShowParticipantsBar"), this) : (this.sendMessageToCallMachine({ action: "set-show-participants-bar", show: e3 }), this._showParticipantsBar = e3, this);
          } }, { key: "showParticipantsBar", value: function() {
            return Le2(), this._callObjectMode ? (console.error("showParticipantsBar is not available in callObject mode"), this) : this._showParticipantsBar;
          } }, { key: "customTrayButtons", value: function() {
            return Le2(), this._callObjectMode ? (console.error("customTrayButtons is not available in callObject mode"), this) : this._customTrayButtons;
          } }, { key: "updateCustomTrayButtons", value: function(e3) {
            return Le2(), this._callObjectMode ? (console.error("updateCustomTrayButtons is not available in callObject mode"), this) : this._meetingState !== N2 ? (console.error("the meeting must be joined before calling updateCustomTrayButtons"), this) : Be2(e3) ? (this.sendMessageToCallMachine({ action: "update-custom-tray-buttons", btns: e3 }), this._customTrayButtons = e3, this) : (console.error("updateCustomTrayButtons only accepts a dictionary of the type ".concat(JSON.stringify(Oe2))), this);
          } }, { key: "theme", value: function() {
            return this._callObjectMode ? (console.error("theme is not available in callObject mode"), this) : this.properties.theme;
          } }, { key: "setTheme", value: function(e3) {
            var t4 = this;
            return new Promise(function(r3, n3) {
              if (t4._callObjectMode)
                n3("setTheme is not available in callObject mode");
              else
                try {
                  t4.validateProperties({ theme: e3 }), t4.properties.theme = _e2({}, e3), t4.sendMessageToCallMachine({ action: "set-theme", theme: t4.properties.theme });
                  try {
                    t4.emit("theme-updated", { action: "theme-updated", theme: t4.properties.theme });
                  } catch (e4) {
                    console.log("could not emit 'theme-updated'", e4);
                  }
                  r3(t4.properties.theme);
                } catch (e4) {
                  n3(e4);
                }
            });
          } }, { key: "detectAllFaces", value: function() {
            var e3 = this;
            return Le2(), new Promise(function(t4, r3) {
              e3.sendMessageToCallMachine({ action: "detect-all-faces" }, function(e4) {
                delete e4.action, delete e4.callbackStamp, t4(e4);
              });
            });
          } }, { key: "requestFullscreen", value: (a2 = l2()(c.a.mark(function e3() {
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (Le2(), this._iframe && !document.fullscreenElement && Object(G2.c)()) {
                      e4.next = 3;
                      break;
                    }
                    return e4.abrupt("return");
                  case 3:
                    return e4.prev = 3, e4.next = 6, this._iframe.requestFullscreen;
                  case 6:
                    if (!e4.sent) {
                      e4.next = 10;
                      break;
                    }
                    this._iframe.requestFullscreen(), e4.next = 11;
                    break;
                  case 10:
                    this._iframe.webkitRequestFullscreen();
                  case 11:
                    e4.next = 16;
                    break;
                  case 13:
                    e4.prev = 13, e4.t0 = e4.catch(3), console.log("could not make video call fullscreen", e4.t0);
                  case 16:
                  case "end":
                    return e4.stop();
                }
            }, e3, this, [[3, 13]]);
          })), function() {
            return a2.apply(this, arguments);
          }) }, { key: "exitFullscreen", value: function() {
            Le2(), document.fullscreenElement ? document.exitFullscreen() : document.webkitFullscreenElement && document.webkitExitFullscreen();
          } }, { key: "room", value: (i2 = l2()(c.a.mark(function e3() {
            var t4, r3, n3, i3 = this, a3 = arguments;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    if (t4 = a3.length > 0 && a3[0] !== void 0 ? a3[0] : {}, r3 = t4.includeRoomConfigDefaults, n3 = r3 === void 0 || r3, this._accessState.access === "unknown" || this.needsLoad()) {
                      e4.next = 5;
                      break;
                    }
                    return e4.abrupt("return", new Promise(function(e5, t5) {
                      i3.sendMessageToCallMachine({ action: "lib-room-info", includeRoomConfigDefaults: n3 }, function(t6) {
                        delete t6.action, delete t6.callbackStamp, e5(t6);
                      });
                    }));
                  case 5:
                    if (!this.properties.url) {
                      e4.next = 7;
                      break;
                    }
                    return e4.abrupt("return", { roomUrlPendingJoin: this.properties.url });
                  case 7:
                    return e4.abrupt("return", null);
                  case 8:
                  case "end":
                    return e4.stop();
                }
            }, e3, this);
          })), function() {
            return i2.apply(this, arguments);
          }) }, { key: "geo", value: (n2 = l2()(c.a.mark(function e3() {
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    return e4.abrupt("return", new Promise(function() {
                      var e5 = l2()(c.a.mark(function e6(t4, r3) {
                        var n3, i3;
                        return c.a.wrap(function(e7) {
                          for (; ; )
                            switch (e7.prev = e7.next) {
                              case 0:
                                return e7.prev = 0, e7.next = 4, fetch("https://gs.daily.co/_ks_/x-swsl/:");
                              case 4:
                                return n3 = e7.sent, e7.next = 7, n3.json();
                              case 7:
                                i3 = e7.sent, t4({ current: i3.geo }), e7.next = 15;
                                break;
                              case 11:
                                e7.prev = 11, e7.t0 = e7.catch(0), console.error("geo lookup failed", e7.t0), t4({ current: "" });
                              case 15:
                              case "end":
                                return e7.stop();
                            }
                        }, e6, null, [[0, 11]]);
                      }));
                      return function(t4, r3) {
                        return e5.apply(this, arguments);
                      };
                    }()));
                  case 1:
                  case "end":
                    return e4.stop();
                }
            }, e3);
          })), function() {
            return n2.apply(this, arguments);
          }) }, { key: "setNetworkTopology", value: (r2 = l2()(c.a.mark(function e3(t4) {
            var r3 = this;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    return Le2(), e4.abrupt("return", new Promise(function() {
                      var e5 = l2()(c.a.mark(function e6(n3, i3) {
                        var a3;
                        return c.a.wrap(function(e7) {
                          for (; ; )
                            switch (e7.prev = e7.next) {
                              case 0:
                                a3 = function(e8) {
                                  e8.error ? i3({ error: e8.error }) : n3({ workerId: e8.workerId });
                                }, r3.sendMessageToCallMachine({ action: "set-network-topology", opts: t4 }, a3);
                              case 2:
                              case "end":
                                return e7.stop();
                            }
                        }, e6);
                      }));
                      return function(t5, r4) {
                        return e5.apply(this, arguments);
                      };
                    }()));
                  case 2:
                  case "end":
                    return e4.stop();
                }
            }, e3);
          })), function(e3) {
            return r2.apply(this, arguments);
          }) }, { key: "getNetworkTopology", value: (t3 = l2()(c.a.mark(function e3() {
            var t4 = this;
            return c.a.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    return e4.abrupt("return", new Promise(function() {
                      var e5 = l2()(c.a.mark(function e6(r3, n3) {
                        var i3;
                        return c.a.wrap(function(e7) {
                          for (; ; )
                            switch (e7.prev = e7.next) {
                              case 0:
                                i3 = function(e8) {
                                  e8.error ? n3({ error: e8.error }) : r3({ topology: e8.topology });
                                }, t4.sendMessageToCallMachine({ action: "get-network-topology" }, i3);
                              case 2:
                              case "end":
                                return e7.stop();
                            }
                        }, e6);
                      }));
                      return function(t5, r3) {
                        return e5.apply(this, arguments);
                      };
                    }()));
                  case 1:
                  case "end":
                    return e4.stop();
                }
            }, e3);
          })), function() {
            return t3.apply(this, arguments);
          }) }, { key: "setPlayNewParticipantSound", value: function(e3) {
            if (Le2(), typeof e3 != "number" && e3 !== true && e3 !== false)
              throw new Error("argument to setShouldPlayNewParticipantSound should be true, false, or a number, but is ".concat(e3));
            this.sendMessageToCallMachine({ action: "daily-method-set-play-ding", arg: e3 });
          } }, { key: "on", value: function(e3, t4) {
            return this._inputEventsOn[e3] = {}, this.sendMessageToCallMachine({ action: "register-input-handler", on: e3 }), O2.a.prototype.on.call(this, e3, t4);
          } }, { key: "once", value: function(e3, t4) {
            return this._inputEventsOn[e3] = {}, this.sendMessageToCallMachine({ action: "register-input-handler", on: e3 }), O2.a.prototype.once.call(this, e3, t4);
          } }, { key: "off", value: function(e3, t4) {
            return delete this._inputEventsOn[e3], this.sendMessageToCallMachine({ action: "register-input-handler", off: e3 }), O2.a.prototype.off.call(this, e3, t4);
          } }, { key: "validateProperties", value: function(e3) {
            for (var t4 in e3) {
              if (!xe2[t4])
                throw new Error("unrecognized property '".concat(t4, "'"));
              if (xe2[t4].validate && !xe2[t4].validate(e3[t4], this))
                throw new Error("property '".concat(t4, "': ").concat(xe2[t4].help));
            }
          } }, { key: "assembleMeetingUrl", value: function() {
            var e3 = _e2(_e2({}, this.properties), {}, { emb: this._callFrameId, embHref: encodeURIComponent(window.location.href) }), t4 = e3.url.match(/\?/) ? "&" : "?";
            return e3.url + t4 + Object.keys(xe2).filter(function(t5) {
              return xe2[t5].queryString && e3[t5] !== void 0;
            }).map(function(t5) {
              return "".concat(xe2[t5].queryString, "=").concat(e3[t5]);
            }).join("&");
          } }, { key: "needsLoad", value: function() {
            return [j2, L2, R3, D2].includes(this._meetingState);
          } }, { key: "sendMessageToCallMachine", value: function(e3, t4) {
            this._messageChannel.sendMessageToCallMachine(e3, t4, this._iframe, this._callFrameId);
          } }, { key: "forwardPackagedMessageToCallMachine", value: function(e3) {
            this._messageChannel.forwardPackagedMessageToCallMachine(e3, this._iframe, this._callFrameId);
          } }, { key: "addListenerForPackagedMessagesFromCallMachine", value: function(e3) {
            return this._messageChannel.addListenerForPackagedMessagesFromCallMachine(e3, this._callFrameId);
          } }, { key: "removeListenerForPackagedMessagesFromCallMachine", value: function(e3) {
            this._messageChannel.removeListenerForPackagedMessagesFromCallMachine(e3);
          } }, { key: "handleMessageFromCallMachine", value: function(e3) {
            switch (e3.action) {
              case "iframe-ready-for-launch-config":
                this.sendMessageToCallMachine(_e2({ action: "iframe-launch-config" }, this.properties));
                break;
              case "loaded":
                this._loadedCallback && (this._loadedCallback(), this._loadedCallback = null);
                try {
                  this.emit(e3.action, e3);
                } catch (t5) {
                  console.log("could not emit", e3, t5);
                }
                break;
              case "joined-meeting":
                this._joinedCallback && (this._joinedCallback(e3.participants), this._joinedCallback = null);
                try {
                  this.emit(e3.action, e3);
                } catch (t5) {
                  console.log("could not emit", e3, t5);
                }
                break;
              case "participant-joined":
              case "participant-updated":
                if (this._meetingState === R3)
                  return;
                if (e3.participant && e3.participant.session_id) {
                  var t4 = e3.participant.local ? "local" : e3.participant.session_id;
                  this._callObjectMode && (ve2(e3.participant), me2(e3.participant), ye2(e3.participant, this._participants[t4]));
                  try {
                    this.maybeEventTrackStopped(this._participants[t4], e3.participant, "audioTrack"), this.maybeEventTrackStopped(this._participants[t4], e3.participant, "videoTrack"), this.maybeEventTrackStopped(this._participants[t4], e3.participant, "screenVideoTrack"), this.maybeEventTrackStopped(this._participants[t4], e3.participant, "screenAudioTrack"), this.maybeEventTrackStarted(this._participants[t4], e3.participant, "audioTrack"), this.maybeEventTrackStarted(this._participants[t4], e3.participant, "videoTrack"), this.maybeEventTrackStarted(this._participants[t4], e3.participant, "screenVideoTrack"), this.maybeEventTrackStarted(this._participants[t4], e3.participant, "screenAudioTrack"), this.maybeEventTrackStoppedForCustomTracks(this._participants[t4], e3.participant), this.maybeEventTrackStartedForCustomTracks(this._participants[t4], e3.participant), this.maybeEventRecordingStopped(this._participants[t4], e3.participant), this.maybeEventRecordingStarted(this._participants[t4], e3.participant);
                  } catch (e4) {
                    console.error("track events error", e4);
                  }
                  if (!this.compareEqualForParticipantUpdateEvent(e3.participant, this._participants[t4])) {
                    this._participants[t4] = _e2({}, e3.participant), this.toggleParticipantAudioBasedOnNativeAudioFocus();
                    try {
                      this.emit(e3.action, e3);
                    } catch (t5) {
                      console.log("could not emit", e3, t5);
                    }
                  }
                }
                break;
              case "participant-left":
                if (e3.participant && e3.participant.session_id) {
                  var r3 = this._participants[e3.participant.session_id];
                  r3 && (this.maybeEventTrackStopped(r3, null, "audioTrack"), this.maybeEventTrackStopped(r3, null, "videoTrack"), this.maybeEventTrackStopped(r3, null, "screenVideoTrack"), this.maybeEventTrackStopped(r3, null, "screenAudioTrack"), this.maybeEventTrackStoppedForCustomTracks(r3, null)), delete this._participants[e3.participant.session_id];
                  try {
                    this.emit(e3.action, e3);
                  } catch (t5) {
                    console.log("could not emit", e3, t5);
                  }
                }
                break;
              case "participant-counts-updated":
                if (!Object(x2.deepEqual)(this._participantCounts, e3.participantCounts)) {
                  this._participantCounts = e3.participantCounts;
                  try {
                    this.emit(e3.action, e3);
                  } catch (t5) {
                    console.log("could not emit", e3, t5);
                  }
                }
                break;
              case "access-state-updated":
                var n3 = { access: e3.access };
                if (e3.awaitingAccess && (n3.awaitingAccess = e3.awaitingAccess), !Object(x2.deepEqual)(this._accessState, n3)) {
                  this._accessState = n3;
                  try {
                    this.emit(e3.action, e3);
                  } catch (t5) {
                    console.log("could not emit", e3, t5);
                  }
                }
                break;
              case "meeting-session-updated":
                if (e3.meetingSession)
                  try {
                    delete e3.callFrameId, this.emit(e3.action, e3);
                  } catch (t5) {
                    console.log("could not emit", e3, t5);
                  }
                break;
              case "error":
                this._iframe && !e3.preserveIframe && (this._iframe.src = ""), this.updateMeetingState(D2), this.resetMeetingDependentVars(), this._loadedCallback && (this._loadedCallback(e3.errorMsg), this._loadedCallback = null), this._joinedCallback && (this._joinedCallback(null, e3.errorMsg), this._joinedCallback = null);
                try {
                  e3.preserveIframe;
                  var i3 = o()(e3, ["preserveIframe"]);
                  this.emit(e3.action, i3);
                } catch (t5) {
                  console.log("could not emit", e3, t5);
                }
                break;
              case "left-meeting":
                this._leftCallback && (this._leftCallback(), this._leftCallback = null);
                try {
                  this.emit(e3.action, e3);
                } catch (t5) {
                  console.log("could not emit", e3, t5);
                }
                break;
              case "input-event":
                var a3 = this._participants[e3.session_id];
                a3 || (a3 = e3.session_id === this._participants.local.session_id ? this._participants.local : {});
                try {
                  this.emit(e3.event.type, { action: e3.event.type, event: e3.event, participant: _e2({}, a3) });
                } catch (t5) {
                  console.log("could not emit", e3, t5);
                }
                break;
              case "network-quality-change":
                var s4 = e3.threshold, c2 = e3.quality;
                if (s4 !== this._network.threshold || c2 !== this._network.quality) {
                  this._network.quality = c2, this._network.threshold = s4;
                  try {
                    this.emit(e3.action, e3);
                  } catch (t5) {
                    console.log("could not emit", e3, t5);
                  }
                }
                break;
              case "active-speaker-change":
                var u3 = e3.activeSpeaker;
                if (this._activeSpeaker.peerId !== u3.peerId) {
                  this._activeSpeaker.peerId = u3.peerId;
                  try {
                    this.emit(e3.action, { action: e3.action, activeSpeaker: this._activeSpeaker });
                  } catch (t5) {
                    console.log("could not emit", e3, t5);
                  }
                }
                break;
              case "show-local-video-changed":
                if (this._callObjectMode)
                  return;
                var l3 = e3.show;
                this._showLocalVideo = l3;
                try {
                  this.emit(e3.action, { action: e3.action, show: l3 });
                } catch (t5) {
                  console.log("could not emit", e3, t5);
                }
                break;
              case "active-speaker-mode-change":
                var d4 = e3.enabled;
                if (this._activeSpeakerMode !== d4) {
                  this._activeSpeakerMode = d4;
                  try {
                    this.emit(e3.action, { action: e3.action, enabled: this._activeSpeakerMode });
                  } catch (t5) {
                    console.log("could not emit", e3, t5);
                  }
                }
                break;
              case "waiting-participant-added":
              case "waiting-participant-updated":
              case "waiting-participant-removed":
                this._waitingParticipants = e3.allWaitingParticipants;
                try {
                  this.emit(e3.action, { action: e3.action, participant: e3.participant });
                } catch (t5) {
                  console.log("could not emit", e3, t5);
                }
                break;
              case "receive-settings-updated":
                if (!Object(x2.deepEqual)(this._receiveSettings, e3.receiveSettings)) {
                  this._receiveSettings = e3.receiveSettings;
                  try {
                    this.emit(e3.action, { action: e3.action, receiveSettings: e3.receiveSettings });
                  } catch (t5) {
                    console.log("could not emit", e3, t5);
                  }
                }
                break;
              case "input-settings-updated":
                if (!Object(x2.deepEqual)(this._inputSettings, e3.inputSettings)) {
                  this._inputSettings = e3.inputSettings;
                  try {
                    this.emit(e3.action, { action: e3.action, inputSettings: e3.inputSettings });
                  } catch (t5) {
                    console.log("could not emit", e3, t5);
                  }
                }
                break;
              case "remote-media-player-started":
                var f2 = e3.session_id;
                this._rmpPlayerState[f2] = e3.playerState, this.emitDailyJSEvent(e3);
                break;
              case "remote-media-player-stopped":
                delete this._rmpPlayerState[e3.session_id], this.emitDailyJSEvent(e3);
                break;
              case "remote-media-player-updated":
                var p4 = e3.session_id, h2 = this._rmpPlayerState[p4];
                h2 && this.compareEqualForRMPUpdateEvent(h2, e3.remoteMediaPlayerState) || (this._rmpPlayerState[p4] = e3.remoteMediaPlayerState, this.emitDailyJSEvent(e3));
                break;
              case "custom-button-click":
                this.emitDailyJSEvent(e3);
                break;
              case "recording-started":
              case "recording-stopped":
              case "recording-stats":
              case "recording-error":
              case "recording-upload-completed":
              case "transcription-started":
              case "transcription-stopped":
              case "transcription-error":
              case "started-camera":
              case "camera-error":
              case "app-message":
              case "local-screen-share-started":
              case "local-screen-share-stopped":
              case "network-connection":
              case "recording-data":
              case "live-streaming-started":
              case "live-streaming-stopped":
              case "live-streaming-error":
              case "nonfatal-error":
              case "lang-updated":
                try {
                  this.emit(e3.action, e3);
                } catch (t5) {
                  console.log("could not emit", e3, t5);
                }
                break;
              case "request-fullscreen":
                this.requestFullscreen();
                break;
              case "request-exit-fullscreen":
                this.exitFullscreen();
            }
          } }, { key: "maybeEventRecordingStopped", value: function(e3, t4) {
            var r3 = "record";
            if (e3 && !t4.local && t4[r3] === false && e3[r3] !== t4[r3])
              try {
                this.emit("recording-stopped", { action: "recording-stopped" });
              } catch (e4) {
                console.log("could not emit", e4);
              }
          } }, { key: "maybeEventRecordingStarted", value: function(e3, t4) {
            var r3 = "record";
            if (e3 && !t4.local && t4[r3] === true && e3[r3] !== t4[r3])
              try {
                this.emit("recording-started", { action: "recording-started" });
              } catch (e4) {
                console.log("could not emit", e4);
              }
          } }, { key: "maybeEventTrackStopped", value: function(e3, t4, r3) {
            if (e3 && (e3[r3] && e3[r3].readyState === "ended" || e3[r3] && (!t4 || !t4[r3]) || e3[r3] && e3[r3].id !== t4[r3].id))
              try {
                this.emit("track-stopped", { action: "track-stopped", track: e3[r3], participant: t4 });
              } catch (e4) {
                console.log("could not emit", e4);
              }
          } }, { key: "maybeEventCustomTrackStopped", value: function(e3, t4, r3, n3) {
            if (e3 && (!n3 || !n3.remoteMediaPlayerState || n3.remoteMediaPlayerState.state != V2 && n3.remoteMediaPlayerState.state != U2) && (e3 && e3.readyState === "ended" || e3 && !t4 || e3 && e3.id !== t4.id))
              try {
                this.emit("track-stopped", { action: "track-stopped", track: e3, participant: r3 });
              } catch (e4) {
                console.log("maybeEventCustomTrackStopped: could not emit", e4);
              }
          } }, { key: "maybeEventCustomTrackStarted", value: function(e3, t4, r3) {
            if (t4 && !e3 || t4 && e3.readyState === "ended" || t4 && t4.id !== e3.id)
              try {
                this.emit("track-started", { action: "track-started", track: t4, participant: r3 });
              } catch (e4) {
                console.log("maybeEventCustomTrackStarted: could not emit", e4);
              }
          } }, { key: "maybeEventTrackStarted", value: function(e3, t4, r3) {
            if (t4[r3] && (!e3 || !e3[r3]) || t4[r3] && e3[r3].readyState === "ended" || t4[r3] && t4[r3].id !== e3[r3].id)
              try {
                this.emit("track-started", { action: "track-started", track: t4[r3], participant: t4 });
              } catch (e4) {
                console.log("could not emit", e4);
              }
          } }, { key: "maybeEventTrackStoppedForCustomTracks", value: function(e3, t4) {
            if (e3)
              for (var r3 in e3.tracks)
                ge2(r3) || this.maybeEventCustomTrackStopped(e3.tracks[r3].track, t4 && t4.tracks[r3] ? t4.tracks[r3].track : null, e3, t4);
          } }, { key: "maybeEventTrackStartedForCustomTracks", value: function(e3, t4) {
            if (t4)
              for (var r3 in t4.tracks)
                ge2(r3) || this.maybeEventCustomTrackStarted(e3 && e3.tracks[r3] ? e3.tracks[r3].track : null, t4.tracks[r3].track, t4);
          } }, { key: "compareEqualForRMPUpdateEvent", value: function(e3, t4) {
            return e3.state === t4.state;
          } }, { key: "emitDailyJSEvent", value: function(e3) {
            try {
              this.emit(e3.action, e3);
            } catch (t4) {
              console.log("could not emit", e3, t4);
            }
          } }, { key: "compareEqualForParticipantUpdateEvent", value: function(e3, t4) {
            return !!Object(x2.deepEqual)(e3, t4) && ((!e3.videoTrack || !t4.videoTrack || e3.videoTrack.id === t4.videoTrack.id && e3.videoTrack.muted === t4.videoTrack.muted && e3.videoTrack.enabled === t4.videoTrack.enabled) && (!e3.audioTrack || !t4.audioTrack || e3.audioTrack.id === t4.audioTrack.id && e3.audioTrack.muted === t4.audioTrack.muted && e3.audioTrack.enabled === t4.audioTrack.enabled));
          } }, { key: "nativeUtils", value: function() {
            return Object(G2.d)() ? typeof DailyNativeUtils == "undefined" ? (console.warn("in React Native, DailyNativeUtils is expected to be available"), null) : DailyNativeUtils : null;
          } }, { key: "updateIsPreparingToJoin", value: function(e3) {
            this.updateMeetingState(this._meetingState, e3);
          } }, { key: "updateMeetingState", value: function(e3) {
            var t4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._isPreparingToJoin;
            if (e3 !== this._meetingState || t4 !== this._isPreparingToJoin) {
              var r3 = this._meetingState, n3 = this._isPreparingToJoin;
              this._meetingState = e3, this._isPreparingToJoin = t4;
              var i3 = this.isMeetingPendingOrOngoing(r3, n3), a3 = this.isMeetingPendingOrOngoing(this._meetingState, this._isPreparingToJoin);
              i3 !== a3 && (this.updateKeepDeviceAwake(a3), this.updateDeviceAudioMode(a3), this.updateShowAndroidOngoingMeetingNotification(a3), this.updateNoOpRecordingEnsuringBackgroundContinuity(a3));
            }
          } }, { key: "resetMeetingDependentVars", value: function() {
            this._participants = {}, this._participantCounts = Se2, this._waitingParticipants = {}, this._activeSpeaker = {}, this._activeSpeakerMode = false, this._didPreAuth = false, this._accessState = { access: "unknown" }, this._receiveSettings = {}, this._inputSettings = {}, this._preloadCache;
          } }, { key: "updateKeepDeviceAwake", value: function(e3) {
            Object(G2.d)() && this.nativeUtils().setKeepDeviceAwake(e3, this._callFrameId);
          } }, { key: "updateDeviceAudioMode", value: function(e3) {
            if (Object(G2.d)() && !this.disableReactNativeAutoDeviceManagement("audio")) {
              var t4 = e3 ? this._nativeInCallAudioMode : "idle";
              this.nativeUtils().setAudioMode(t4);
            }
          } }, { key: "updateShowAndroidOngoingMeetingNotification", value: function(e3) {
            if (Object(G2.d)() && this.nativeUtils().setShowOngoingMeetingNotification) {
              var t4, r3, n3, i3;
              if (this.properties.reactNativeConfig && this.properties.reactNativeConfig.androidInCallNotification) {
                var a3 = this.properties.reactNativeConfig.androidInCallNotification;
                t4 = a3.title, r3 = a3.subtitle, n3 = a3.iconName, i3 = a3.disableForCustomOverride;
              }
              i3 && (e3 = false), this.nativeUtils().setShowOngoingMeetingNotification(e3, t4, r3, n3, this._callFrameId);
            }
          } }, { key: "updateNoOpRecordingEnsuringBackgroundContinuity", value: function(e3) {
            Object(G2.d)() && this.nativeUtils().enableNoOpRecordingEnsuringBackgroundContinuity && this.nativeUtils().enableNoOpRecordingEnsuringBackgroundContinuity(e3);
          } }, { key: "isMeetingPendingOrOngoing", value: function(e3, t4) {
            return [I3, N2].includes(e3) || t4;
          } }, { key: "toggleParticipantAudioBasedOnNativeAudioFocus", value: function() {
            if (Object(G2.d)()) {
              var e3 = store.getState();
              for (var t4 in e3.streams) {
                var r3 = e3.streams[t4];
                r3 && r3.pendingTrack && r3.pendingTrack.kind === "audio" && (r3.pendingTrack.enabled = this._hasNativeAudioFocus);
              }
            }
          } }, { key: "disableReactNativeAutoDeviceManagement", value: function(e3) {
            return this.properties.reactNativeConfig && this.properties.reactNativeConfig.disableAutoDeviceManagement && this.properties.reactNativeConfig.disableAutoDeviceManagement[e3];
          } }, { key: "absoluteUrl", value: function(e3) {
            if (e3 !== void 0) {
              var t4 = document.createElement("a");
              return t4.href = e3, t4.href;
            }
          } }, { key: "sayHello", value: function() {
            var e3 = "hello, world.";
            return console.log(e3), e3;
          } }]), $3;
        }(O2.a);
        function je2(e2) {
          var t3 = {};
          for (var r2 in e2)
            e2[r2] instanceof MediaStreamTrack ? t3[r2] = "daily-custom-track" : r2 === "dailyConfig" ? (e2[r2].modifyLocalSdpHook && (window._dailyConfig && (window._dailyConfig.modifyLocalSdpHook = e2[r2].modifyLocalSdpHook), delete e2[r2].modifyLocalSdpHook), e2[r2].modifyRemoteSdpHook && (window._dailyConfig && (window._dailyConfig.modifyRemoteSdpHook = e2[r2].modifyRemoteSdpHook), delete e2[r2].modifyRemoteSdpHook), t3[r2] = e2[r2]) : t3[r2] = e2[r2];
          return t3;
        }
        function Le2() {
          if (Object(G2.d)())
            throw new Error("This daily-js method is not currently supported in React Native");
        }
        function Ie2() {
          if (!Object(G2.d)())
            throw new Error("This daily-js method is only supported in React Native");
        }
        function Ne2(e2, t3) {
          for (var r2 = t3.allowAllParticipantsKey, n2 = function(e3) {
            var t4 = ["local"];
            return r2 || t4.push("*"), e3 && !t4.includes(e3);
          }, a2 = function(e3) {
            return !!(e3.layer === void 0 || Number.isInteger(e3.layer) && e3.layer >= 0 || e3.layer === "inherit");
          }, o2 = function(e3) {
            return !!e3 && (!(e3.video && !a2(e3.video)) && !(e3.screenVideo && !a2(e3.screenVideo)));
          }, s3 = 0, c2 = Object.entries(e2); s3 < c2.length; s3++) {
            var u2 = i()(c2[s3], 2), l3 = u2[0], d3 = u2[1];
            if (!n2(l3) || !o2(d3))
              return false;
          }
          return true;
        }
        function Re2(e2) {
          return T2()(e2) === "object" && (!(!e2.video || T2()(e2.video) !== "object") && !!function(e3) {
            var t3 = ["type", "config", "publish"];
            if (!e3)
              return false;
            if (T2()(e3) !== "object")
              return false;
            if (Object.keys(e3).length === 0)
              return false;
            if (e3.type && !function(e4) {
              if (typeof e4 != "string")
                return false;
              if (!Object.values(F2).includes(e4))
                return console.error("inputSettings video processor type invalid"), false;
              return true;
            }(e3.type))
              return false;
            if (e3.publish !== void 0 && typeof e3.publish != "boolean")
              return false;
            typeof e3.publish == "boolean" && console.warn("inputSettings.video.processor: publish key has been deprecated; it will be ignored");
            if (e3.config) {
              if (T2()(e3.config) !== "object")
                return false;
              if (!function(e4, t4) {
                var r2 = Object.keys(t4);
                if (r2.length === 0)
                  return true;
                var n2 = "invalid object in inputSettings -> video -> processor -> config";
                switch (e4) {
                  case F2.BGBLUR:
                    return r2.length > 1 || r2[0] !== "strength" ? (console.error(n2), false) : !(typeof t4.strength != "number" || t4.strength <= 0 || t4.strength > 1 || isNaN(t4.strength)) || (console.error("".concat(n2, "; expected: {0 < strength <= 1}, got: ").concat(t4.strength)), false);
                  case F2.BGIMAGE:
                    return !(t4.source !== void 0 && !function(e5) {
                      if (e5.source === "default")
                        return e5.type = "default", true;
                      if (Object(J2.d)(e5.source))
                        return e5.type = "url", !!function(e6) {
                          var t6 = new URL(e6), r4 = t6.pathname;
                          if (t6.protocol === "data:")
                            try {
                              var n3 = r4.substring(r4.indexOf(":") + 1, r4.indexOf(";")).split("/")[1];
                              return Y2.includes(n3);
                            } catch (e7) {
                              return console.error("failed to deduce blob content type", e7), false;
                            }
                          var i2 = r4.split(".").at(-1).toLowerCase().trim();
                          return Y2.includes(i2);
                        }(e5.source) || (console.error("invalid image type; supported types: [".concat(Y2.join(", "), "]")), false);
                      return t5 = e5.source, r3 = Number(t5), isNaN(r3) || !Number.isInteger(r3) || r3 <= 0 || r3 > 10 ? (console.error("invalid image selection; must be an int, > 0, <= ".concat(10)), false) : (e5.type = "daily-preselect", true);
                      var t5, r3;
                    }(t4));
                  default:
                    return true;
                }
              }(e3.type, e3.config))
                return false;
            }
            return Object.keys(e3).filter(function(e4) {
              return !t3.includes(e4);
            }).forEach(function(t4) {
              console.warn("invalid key inputSettings -> video -> processor : ".concat(t4)), delete e3[t4];
            }), true;
          }(e2.video.processor));
        }
        function De2() {
          var e2 = Object.values(F2).join(" | ");
          return "inputSettings must be of the form: { video: { processor: [ ".concat(e2, " ] }, config?: {} }");
        }
        function Fe2(e2) {
          var t3 = e2.allowAllParticipantsKey;
          return "receiveSettings must be of the form { [<remote participant id> | ".concat("base").concat(t3 ? ' | "'.concat("*", '"') : "", "]: ") + '{ [video: [{ layer: [<non-negative integer> | "inherit"] } | "inherit"]], [screenVideo: [{ layer: [<non-negative integer> | "inherit"] } | "inherit"]] }}}';
        }
        function Be2(e2) {
          if (e2 && T2()(e2) !== "object" || Array.isArray(e2))
            return console.error("customTrayButtons should be an Object of the type ".concat(JSON.stringify(Oe2), ".")), false;
          if (e2)
            for (var t3 = 0, r2 = Object.entries(e2); t3 < r2.length; t3++)
              for (var n2 = i()(r2[t3], 1)[0], a2 = 0, o2 = Object.entries(e2[n2]); a2 < o2.length; a2++) {
                var s3 = i()(o2[a2], 2), c2 = s3[0], u2 = s3[1];
                if (c2 === "iconPath" && !Object(J2.d)(u2))
                  return console.error("customTrayButton ".concat(c2, " should be a url.")), false;
                if (T2()(u2) !== Oe2.id[c2])
                  return console.error("customTrayButton ".concat(c2, " should be a ").concat(Oe2.id[c2], ".")), false;
              }
          return true;
        }
        function Ve2(e2) {
          if (typeof e2 != "string")
            throw new Error('url parameter must be "string" type');
        }
        function Ue2(e2) {
          if (T2()(e2) !== "object")
            throw new Error('RemoteMediaPlayerSettings: must be "object" type');
          if (!e2.state || !Object.values(B2).includes(e2.state))
            throw new Error("Invalid value for RemoteMediaPlayerSettings.state, valid values are: " + JSON.stringify(B2));
        }
        function Ye2(e2, t3, r2) {
          return !(typeof e2 != "number" || e2 < t3 || e2 > r2);
        }
        function Ge2(e2) {
          for (var t3 in e2)
            if (!Te2.includes(t3))
              throw new Error("Invalid key ".concat(t3, ", valid keys are: ").concat(Te2));
          if (e2.simulcastEncodings) {
            if (!(e2.simulcastEncodings instanceof Array))
              throw new Error('simulcastEncodings must be "Array"');
            if (!Ye2(e2.simulcastEncodings.length, 0, 3))
              throw new Error('"simulcastEncodings" not in range. valid range 1 to 3 layers');
            e2.simulcastEncodings.every(function(e3) {
              for (var t4 in e3) {
                if (!Ee2.hasOwnProperty(t4))
                  throw new Error("Invalid key ".concat(t4, ", valid keys are:") + Object.keys(Ee2));
                if (typeof e3[t4] != "number")
                  throw new Error("simulcastEncodings[].".concat(t4, ' must be "number"'));
                var r2 = Ee2[t4], n2 = r2.min, i2 = r2.max;
                if (!Ye2(e3[t4], n2, i2))
                  throw new Error("simulcastEncodings[].".concat(t4, " value not in range. valid range:        ").concat(n2, " to ").concat(i2));
              }
              if (!e3.hasOwnProperty("maxBitrate"))
                throw new Error("simulcastEncodings[].maxBitrate is not specified");
            });
          }
        }
      }]);
    });
  }
});

// .svelte-kit/output/server/chunks/__layout-cdc2bbe6.js
var layout_cdc2bbe6_exports = {};
__export(layout_cdc2bbe6_exports, {
  default: () => _layout2,
  load: () => load2
});
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$1.defaultMaxListeners;
  return that._maxListeners;
}
function _addListener(target, type, listener, prepend) {
  var m;
  var events22;
  var existing;
  checkListener(listener);
  events22 = target._events;
  if (events22 === void 0) {
    events22 = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events22.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events22 = target._events;
    }
    existing = events22[type];
  }
  if (existing === void 0) {
    existing = events22[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events22[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type;
      w2.count = existing.length;
      ProcessEmitWarning(w2);
    }
  }
  return target;
}
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
function _listeners(target, type, unwrap) {
  var events22 = target._events;
  if (events22 === void 0)
    return [];
  var evlistener = events22[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
function listenerCount(type) {
  var events22 = this._events;
  if (events22 !== void 0) {
    var evlistener = events22[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once2(emitter, name22) {
  return new Promise(function(resolve2, reject2) {
    function errorListener(err) {
      emitter.removeListener(name22, resolver);
      reject2(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve2([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name22, resolver, { once: true });
    if (name22 !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name22, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name22, listener);
    } else {
      emitter.on(name22, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name22, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name22, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
function HTTPParser(type) {
  assert2.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE || type === void 0);
  if (type === void 0)
    ;
  else {
    this.initialize(type);
  }
}
function parseErrorCode(code) {
  var err = new Error("Parse Error");
  err.code = code;
  return err;
}
function each2(obj, fn2) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn2(key, obj[key]);
    }
  }
}
function repoInfoNeedsQueryParam(repoInfo) {
  return repoInfo.host !== repoInfo.internalHost || repoInfo.isCustomHost() || repoInfo.includeNamespaceInQueryParams;
}
function repoInfoConnectionURL(repoInfo, type, params) {
  assert(typeof type === "string", "typeof type must == string");
  assert(typeof params === "object", "typeof params must == object");
  let connURL;
  if (type === WEBSOCKET) {
    connURL = (repoInfo.secure ? "wss://" : "ws://") + repoInfo.internalHost + "/.ws?";
  } else if (type === LONG_POLLING) {
    connURL = (repoInfo.secure ? "https://" : "http://") + repoInfo.internalHost + "/.lp?";
  } else {
    throw new Error("Unknown connection type: " + type);
  }
  if (repoInfoNeedsQueryParam(repoInfo)) {
    params["ns"] = repoInfo.namespace;
  }
  const pairs = [];
  each2(params, (key, value) => {
    pairs.push(key + "=" + value);
  });
  return connURL + pairs.join("&");
}
function statsManagerGetCollection(repoInfo) {
  const hashString = repoInfo.toString();
  if (!collections[hashString]) {
    collections[hashString] = new StatsCollection();
  }
  return collections[hashString];
}
function statsManagerGetOrCreateReporter(repoInfo, creatorFunction) {
  const hashString = repoInfo.toString();
  if (!reporters[hashString]) {
    reporters[hashString] = creatorFunction();
  }
  return reporters[hashString];
}
function setSDKVersion(version22) {
  SDK_VERSION2 = version22;
}
function setWebSocketImpl(impl) {
  WebSocketImpl = impl;
}
function newEmptyPath() {
  return new Path("");
}
function pathGetFront(path) {
  if (path.pieceNum_ >= path.pieces_.length) {
    return null;
  }
  return path.pieces_[path.pieceNum_];
}
function pathGetLength(path) {
  return path.pieces_.length - path.pieceNum_;
}
function pathPopFront(path) {
  let pieceNum = path.pieceNum_;
  if (pieceNum < path.pieces_.length) {
    pieceNum++;
  }
  return new Path(path.pieces_, pieceNum);
}
function pathGetBack(path) {
  if (path.pieceNum_ < path.pieces_.length) {
    return path.pieces_[path.pieces_.length - 1];
  }
  return null;
}
function pathToUrlEncodedString(path) {
  let pathString = "";
  for (let i = path.pieceNum_; i < path.pieces_.length; i++) {
    if (path.pieces_[i] !== "") {
      pathString += "/" + encodeURIComponent(String(path.pieces_[i]));
    }
  }
  return pathString || "/";
}
function pathSlice(path, begin = 0) {
  return path.pieces_.slice(path.pieceNum_ + begin);
}
function pathParent(path) {
  if (path.pieceNum_ >= path.pieces_.length) {
    return null;
  }
  const pieces = [];
  for (let i = path.pieceNum_; i < path.pieces_.length - 1; i++) {
    pieces.push(path.pieces_[i]);
  }
  return new Path(pieces, 0);
}
function pathChild(path, childPathObj) {
  const pieces = [];
  for (let i = path.pieceNum_; i < path.pieces_.length; i++) {
    pieces.push(path.pieces_[i]);
  }
  if (childPathObj instanceof Path) {
    for (let i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {
      pieces.push(childPathObj.pieces_[i]);
    }
  } else {
    const childPieces = childPathObj.split("/");
    for (let i = 0; i < childPieces.length; i++) {
      if (childPieces[i].length > 0) {
        pieces.push(childPieces[i]);
      }
    }
  }
  return new Path(pieces, 0);
}
function pathIsEmpty(path) {
  return path.pieceNum_ >= path.pieces_.length;
}
function newRelativePath(outerPath, innerPath) {
  const outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);
  if (outer === null) {
    return innerPath;
  } else if (outer === inner) {
    return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));
  } else {
    throw new Error("INTERNAL ERROR: innerPath (" + innerPath + ") is not within outerPath (" + outerPath + ")");
  }
}
function pathEquals(path, other) {
  if (pathGetLength(path) !== pathGetLength(other)) {
    return false;
  }
  for (let i = path.pieceNum_, j2 = other.pieceNum_; i <= path.pieces_.length; i++, j2++) {
    if (path.pieces_[i] !== other.pieces_[j2]) {
      return false;
    }
  }
  return true;
}
function pathContains(path, other) {
  let i = path.pieceNum_;
  let j2 = other.pieceNum_;
  if (pathGetLength(path) > pathGetLength(other)) {
    return false;
  }
  while (i < path.pieces_.length) {
    if (path.pieces_[i] !== other.pieces_[j2]) {
      return false;
    }
    ++i;
    ++j2;
  }
  return true;
}
function validationPathPush(validationPath, child) {
  if (validationPath.parts_.length > 0) {
    validationPath.byteLength_ += 1;
  }
  validationPath.parts_.push(child);
  validationPath.byteLength_ += stringLength(child);
  validationPathCheckValid(validationPath);
}
function validationPathPop(validationPath) {
  const last = validationPath.parts_.pop();
  validationPath.byteLength_ -= stringLength(last);
  if (validationPath.parts_.length > 0) {
    validationPath.byteLength_ -= 1;
  }
}
function validationPathCheckValid(validationPath) {
  if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) {
    throw new Error(validationPath.errorPrefix_ + "has a key path longer than " + MAX_PATH_LENGTH_BYTES + " bytes (" + validationPath.byteLength_ + ").");
  }
  if (validationPath.parts_.length > MAX_PATH_DEPTH) {
    throw new Error(validationPath.errorPrefix_ + "path specified exceeds the maximum depth that can be written (" + MAX_PATH_DEPTH + ") or object contains a cycle " + validationPathToErrorString(validationPath));
  }
}
function validationPathToErrorString(validationPath) {
  if (validationPath.parts_.length === 0) {
    return "";
  }
  return "in property '" + validationPath.parts_.join(".") + "'";
}
function NAME_ONLY_COMPARATOR(left, right) {
  return nameCompare(left.name, right.name);
}
function NAME_COMPARATOR(left, right) {
  return nameCompare(left, right);
}
function setMaxNode$1(val) {
  MAX_NODE$2 = val;
}
function setNodeFromJSON(val) {
  nodeFromJSON$1 = val;
}
function setMaxNode(val) {
  MAX_NODE$1 = val;
}
function nodeFromJSON(json, priority = null) {
  if (json === null) {
    return ChildrenNode.EMPTY_NODE;
  }
  if (typeof json === "object" && ".priority" in json) {
    priority = json[".priority"];
  }
  assert(priority === null || typeof priority === "string" || typeof priority === "number" || typeof priority === "object" && ".sv" in priority, "Invalid priority type found: " + typeof priority);
  if (typeof json === "object" && ".value" in json && json[".value"] !== null) {
    json = json[".value"];
  }
  if (typeof json !== "object" || ".sv" in json) {
    const jsonLeaf = json;
    return new LeafNode(jsonLeaf, nodeFromJSON(priority));
  }
  if (!(json instanceof Array) && USE_HINZE) {
    const children = [];
    let childrenHavePriority = false;
    const hinzeJsonObj = json;
    each2(hinzeJsonObj, (key, child) => {
      if (key.substring(0, 1) !== ".") {
        const childNode = nodeFromJSON(child);
        if (!childNode.isEmpty()) {
          childrenHavePriority = childrenHavePriority || !childNode.getPriority().isEmpty();
          children.push(new NamedNode(key, childNode));
        }
      }
    });
    if (children.length === 0) {
      return ChildrenNode.EMPTY_NODE;
    }
    const childSet = buildChildSet(children, NAME_ONLY_COMPARATOR, (namedNode) => namedNode.name, NAME_COMPARATOR);
    if (childrenHavePriority) {
      const sortedChildSet = buildChildSet(children, PRIORITY_INDEX.getCompare());
      return new ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap({ ".priority": sortedChildSet }, { ".priority": PRIORITY_INDEX }));
    } else {
      return new ChildrenNode(childSet, nodeFromJSON(priority), IndexMap.Default);
    }
  } else {
    let node = ChildrenNode.EMPTY_NODE;
    each2(json, (key, childData) => {
      if (contains(json, key)) {
        if (key.substring(0, 1) !== ".") {
          const childNode = nodeFromJSON(childData);
          if (childNode.isLeafNode() || !childNode.isEmpty()) {
            node = node.updateImmediateChild(key, childNode);
          }
        }
      }
    });
    return node.updatePriority(nodeFromJSON(priority));
  }
}
function changeValue(snapshotNode) {
  return { type: "value", snapshotNode };
}
function changeChildAdded(childName, snapshotNode) {
  return { type: "child_added", snapshotNode, childName };
}
function changeChildRemoved(childName, snapshotNode) {
  return { type: "child_removed", snapshotNode, childName };
}
function changeChildChanged(childName, snapshotNode, oldSnap) {
  return {
    type: "child_changed",
    snapshotNode,
    childName,
    oldSnap
  };
}
function changeChildMoved(childName, snapshotNode) {
  return { type: "child_moved", snapshotNode, childName };
}
function queryParamsToRestQueryStringParameters(queryParams) {
  const qs2 = {};
  if (queryParams.isDefault()) {
    return qs2;
  }
  let orderBy;
  if (queryParams.index_ === PRIORITY_INDEX) {
    orderBy = "$priority";
  } else if (queryParams.index_ === VALUE_INDEX) {
    orderBy = "$value";
  } else if (queryParams.index_ === KEY_INDEX) {
    orderBy = "$key";
  } else {
    assert(queryParams.index_ instanceof PathIndex, "Unrecognized index type!");
    orderBy = queryParams.index_.toString();
  }
  qs2["orderBy"] = stringify(orderBy);
  if (queryParams.startSet_) {
    qs2["startAt"] = stringify(queryParams.indexStartValue_);
    if (queryParams.startNameSet_) {
      qs2["startAt"] += "," + stringify(queryParams.indexStartName_);
    }
  }
  if (queryParams.endSet_) {
    qs2["endAt"] = stringify(queryParams.indexEndValue_);
    if (queryParams.endNameSet_) {
      qs2["endAt"] += "," + stringify(queryParams.indexEndName_);
    }
  }
  if (queryParams.limitSet_) {
    if (queryParams.isViewFromLeft()) {
      qs2["limitToFirst"] = queryParams.limit_;
    } else {
      qs2["limitToLast"] = queryParams.limit_;
    }
  }
  return qs2;
}
function queryParamsGetQueryObject(queryParams) {
  const obj = {};
  if (queryParams.startSet_) {
    obj["sp"] = queryParams.indexStartValue_;
    if (queryParams.startNameSet_) {
      obj["sn"] = queryParams.indexStartName_;
    }
  }
  if (queryParams.endSet_) {
    obj["ep"] = queryParams.indexEndValue_;
    if (queryParams.endNameSet_) {
      obj["en"] = queryParams.indexEndName_;
    }
  }
  if (queryParams.limitSet_) {
    obj["l"] = queryParams.limit_;
    let viewFrom = queryParams.viewFrom_;
    if (viewFrom === "") {
      if (queryParams.isViewFromLeft()) {
        viewFrom = "l";
      } else {
        viewFrom = "r";
      }
    }
    obj["vf"] = viewFrom;
  }
  if (queryParams.index_ !== PRIORITY_INDEX) {
    obj["i"] = queryParams.index_.toString();
  }
  return obj;
}
function newSparseSnapshotTree() {
  return {
    value: null,
    children: new Map()
  };
}
function sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) {
  if (pathIsEmpty(path)) {
    sparseSnapshotTree.value = data;
    sparseSnapshotTree.children.clear();
  } else if (sparseSnapshotTree.value !== null) {
    sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);
  } else {
    const childKey = pathGetFront(path);
    if (!sparseSnapshotTree.children.has(childKey)) {
      sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());
    }
    const child = sparseSnapshotTree.children.get(childKey);
    path = pathPopFront(path);
    sparseSnapshotTreeRemember(child, path, data);
  }
}
function sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) {
  if (sparseSnapshotTree.value !== null) {
    func(prefixPath, sparseSnapshotTree.value);
  } else {
    sparseSnapshotTreeForEachChild(sparseSnapshotTree, (key, tree) => {
      const path = new Path(prefixPath.toString() + "/" + key);
      sparseSnapshotTreeForEachTree(tree, path, func);
    });
  }
}
function sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) {
  sparseSnapshotTree.children.forEach((tree, key) => {
    func(key, tree);
  });
}
function newOperationSourceUser() {
  return {
    fromUser: true,
    fromServer: false,
    queryId: null,
    tagged: false
  };
}
function newOperationSourceServer() {
  return {
    fromUser: false,
    fromServer: true,
    queryId: null,
    tagged: false
  };
}
function newOperationSourceServerTaggedQuery(queryId) {
  return {
    fromUser: false,
    fromServer: true,
    queryId,
    tagged: true
  };
}
function eventGeneratorGenerateEventsForChanges(eventGenerator, changes, eventCache, eventRegistrations) {
  const events22 = [];
  const moves = [];
  changes.forEach((change) => {
    if (change.type === "child_changed" && eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {
      moves.push(changeChildMoved(change.childName, change.snapshotNode));
    }
  });
  eventGeneratorGenerateEventsForType(eventGenerator, events22, "child_removed", changes, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events22, "child_added", changes, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events22, "child_moved", moves, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events22, "child_changed", changes, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events22, "value", changes, eventRegistrations, eventCache);
  return events22;
}
function eventGeneratorGenerateEventsForType(eventGenerator, events22, eventType, changes, registrations, eventCache) {
  const filteredChanges = changes.filter((change) => change.type === eventType);
  filteredChanges.sort((a, b) => eventGeneratorCompareChanges(eventGenerator, a, b));
  filteredChanges.forEach((change) => {
    const materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);
    registrations.forEach((registration) => {
      if (registration.respondsTo(change.type)) {
        events22.push(registration.createEvent(materializedChange, eventGenerator.query_));
      }
    });
  });
}
function eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache) {
  if (change.type === "value" || change.type === "child_removed") {
    return change;
  } else {
    change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);
    return change;
  }
}
function eventGeneratorCompareChanges(eventGenerator, a, b) {
  if (a.childName == null || b.childName == null) {
    throw assertionError("Should only compare child_ events.");
  }
  const aWrapped = new NamedNode(a.childName, a.snapshotNode);
  const bWrapped = new NamedNode(b.childName, b.snapshotNode);
  return eventGenerator.index_.compare(aWrapped, bWrapped);
}
function newViewCache(eventCache, serverCache) {
  return { eventCache, serverCache };
}
function viewCacheUpdateEventSnap(viewCache, eventSnap, complete, filtered) {
  return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);
}
function viewCacheUpdateServerSnap(viewCache, serverSnap, complete, filtered) {
  return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));
}
function viewCacheGetCompleteEventSnap(viewCache) {
  return viewCache.eventCache.isFullyInitialized() ? viewCache.eventCache.getNode() : null;
}
function viewCacheGetCompleteServerSnap(viewCache) {
  return viewCache.serverCache.isFullyInitialized() ? viewCache.serverCache.getNode() : null;
}
function compoundWriteAddWrite(compoundWrite, path, node) {
  if (pathIsEmpty(path)) {
    return new CompoundWrite(new ImmutableTree(node));
  } else {
    const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
    if (rootmost != null) {
      const rootMostPath = rootmost.path;
      let value = rootmost.value;
      const relativePath = newRelativePath(rootMostPath, path);
      value = value.updateChild(relativePath, node);
      return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));
    } else {
      const subtree = new ImmutableTree(node);
      const newWriteTree2 = compoundWrite.writeTree_.setTree(path, subtree);
      return new CompoundWrite(newWriteTree2);
    }
  }
}
function compoundWriteAddWrites(compoundWrite, path, updates) {
  let newWrite = compoundWrite;
  each2(updates, (childKey, node) => {
    newWrite = compoundWriteAddWrite(newWrite, pathChild(path, childKey), node);
  });
  return newWrite;
}
function compoundWriteRemoveWrite(compoundWrite, path) {
  if (pathIsEmpty(path)) {
    return CompoundWrite.empty();
  } else {
    const newWriteTree2 = compoundWrite.writeTree_.setTree(path, new ImmutableTree(null));
    return new CompoundWrite(newWriteTree2);
  }
}
function compoundWriteHasCompleteWrite(compoundWrite, path) {
  return compoundWriteGetCompleteNode(compoundWrite, path) != null;
}
function compoundWriteGetCompleteNode(compoundWrite, path) {
  const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
  if (rootmost != null) {
    return compoundWrite.writeTree_.get(rootmost.path).getChild(newRelativePath(rootmost.path, path));
  } else {
    return null;
  }
}
function compoundWriteGetCompleteChildren(compoundWrite) {
  const children = [];
  const node = compoundWrite.writeTree_.value;
  if (node != null) {
    if (!node.isLeafNode()) {
      node.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
        children.push(new NamedNode(childName, childNode));
      });
    }
  } else {
    compoundWrite.writeTree_.children.inorderTraversal((childName, childTree) => {
      if (childTree.value != null) {
        children.push(new NamedNode(childName, childTree.value));
      }
    });
  }
  return children;
}
function compoundWriteChildCompoundWrite(compoundWrite, path) {
  if (pathIsEmpty(path)) {
    return compoundWrite;
  } else {
    const shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path);
    if (shadowingNode != null) {
      return new CompoundWrite(new ImmutableTree(shadowingNode));
    } else {
      return new CompoundWrite(compoundWrite.writeTree_.subtree(path));
    }
  }
}
function compoundWriteIsEmpty(compoundWrite) {
  return compoundWrite.writeTree_.isEmpty();
}
function compoundWriteApply(compoundWrite, node) {
  return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);
}
function applySubtreeWrite(relativePath, writeTree, node) {
  if (writeTree.value != null) {
    return node.updateChild(relativePath, writeTree.value);
  } else {
    let priorityWrite = null;
    writeTree.children.inorderTraversal((childKey, childTree) => {
      if (childKey === ".priority") {
        assert(childTree.value !== null, "Priority writes must always be leaf nodes");
        priorityWrite = childTree.value;
      } else {
        node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);
      }
    });
    if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {
      node = node.updateChild(pathChild(relativePath, ".priority"), priorityWrite);
    }
    return node;
  }
}
function writeTreeChildWrites(writeTree, path) {
  return newWriteTreeRef(path, writeTree);
}
function writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) {
  assert(writeId > writeTree.lastWriteId, "Stacking an older write on top of newer ones");
  if (visible === void 0) {
    visible = true;
  }
  writeTree.allWrites.push({
    path,
    snap,
    writeId,
    visible
  });
  if (visible) {
    writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);
  }
  writeTree.lastWriteId = writeId;
}
function writeTreeGetWrite(writeTree, writeId) {
  for (let i = 0; i < writeTree.allWrites.length; i++) {
    const record = writeTree.allWrites[i];
    if (record.writeId === writeId) {
      return record;
    }
  }
  return null;
}
function writeTreeRemoveWrite(writeTree, writeId) {
  const idx = writeTree.allWrites.findIndex((s2) => {
    return s2.writeId === writeId;
  });
  assert(idx >= 0, "removeWrite called with nonexistent writeId.");
  const writeToRemove = writeTree.allWrites[idx];
  writeTree.allWrites.splice(idx, 1);
  let removedWriteWasVisible = writeToRemove.visible;
  let removedWriteOverlapsWithOtherWrites = false;
  let i = writeTree.allWrites.length - 1;
  while (removedWriteWasVisible && i >= 0) {
    const currentWrite = writeTree.allWrites[i];
    if (currentWrite.visible) {
      if (i >= idx && writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {
        removedWriteWasVisible = false;
      } else if (pathContains(writeToRemove.path, currentWrite.path)) {
        removedWriteOverlapsWithOtherWrites = true;
      }
    }
    i--;
  }
  if (!removedWriteWasVisible) {
    return false;
  } else if (removedWriteOverlapsWithOtherWrites) {
    writeTreeResetTree_(writeTree);
    return true;
  } else {
    if (writeToRemove.snap) {
      writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);
    } else {
      const children = writeToRemove.children;
      each2(children, (childName) => {
        writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));
      });
    }
    return true;
  }
}
function writeTreeRecordContainsPath_(writeRecord, path) {
  if (writeRecord.snap) {
    return pathContains(writeRecord.path, path);
  } else {
    for (const childName in writeRecord.children) {
      if (writeRecord.children.hasOwnProperty(childName) && pathContains(pathChild(writeRecord.path, childName), path)) {
        return true;
      }
    }
    return false;
  }
}
function writeTreeResetTree_(writeTree) {
  writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());
  if (writeTree.allWrites.length > 0) {
    writeTree.lastWriteId = writeTree.allWrites[writeTree.allWrites.length - 1].writeId;
  } else {
    writeTree.lastWriteId = -1;
  }
}
function writeTreeDefaultFilter_(write) {
  return write.visible;
}
function writeTreeLayerTree_(writes, filter, treeRoot) {
  let compoundWrite = CompoundWrite.empty();
  for (let i = 0; i < writes.length; ++i) {
    const write = writes[i];
    if (filter(write)) {
      const writePath = write.path;
      let relativePath;
      if (write.snap) {
        if (pathContains(treeRoot, writePath)) {
          relativePath = newRelativePath(treeRoot, writePath);
          compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write.snap);
        } else if (pathContains(writePath, treeRoot)) {
          relativePath = newRelativePath(writePath, treeRoot);
          compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write.snap.getChild(relativePath));
        } else
          ;
      } else if (write.children) {
        if (pathContains(treeRoot, writePath)) {
          relativePath = newRelativePath(treeRoot, writePath);
          compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write.children);
        } else if (pathContains(writePath, treeRoot)) {
          relativePath = newRelativePath(writePath, treeRoot);
          if (pathIsEmpty(relativePath)) {
            compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write.children);
          } else {
            const child = safeGet(write.children, pathGetFront(relativePath));
            if (child) {
              const deepNode = child.getChild(pathPopFront(relativePath));
              compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);
            }
          }
        } else
          ;
      } else {
        throw assertionError("WriteRecord should have .snap or .children");
      }
    }
  }
  return compoundWrite;
}
function writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
  if (!writeIdsToExclude && !includeHiddenWrites) {
    const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
    if (shadowingNode != null) {
      return shadowingNode;
    } else {
      const subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
      if (compoundWriteIsEmpty(subMerge)) {
        return completeServerCache;
      } else if (completeServerCache == null && !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {
        return null;
      } else {
        const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
        return compoundWriteApply(subMerge, layeredCache);
      }
    }
  } else {
    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {
      return completeServerCache;
    } else {
      if (!includeHiddenWrites && completeServerCache == null && !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {
        return null;
      } else {
        const filter = function(write) {
          return (write.visible || includeHiddenWrites) && (!writeIdsToExclude || !~writeIdsToExclude.indexOf(write.writeId)) && (pathContains(write.path, treePath) || pathContains(treePath, write.path));
        };
        const mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);
        const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
        return compoundWriteApply(mergeAtPath, layeredCache);
      }
    }
  }
}
function writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) {
  let completeChildren = ChildrenNode.EMPTY_NODE;
  const topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
  if (topLevelSet) {
    if (!topLevelSet.isLeafNode()) {
      topLevelSet.forEachChild(PRIORITY_INDEX, (childName, childSnap) => {
        completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
      });
    }
    return completeChildren;
  } else if (completeServerChildren) {
    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    completeServerChildren.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
      const node = compoundWriteApply(compoundWriteChildCompoundWrite(merge, new Path(childName)), childNode);
      completeChildren = completeChildren.updateImmediateChild(childName, node);
    });
    compoundWriteGetCompleteChildren(merge).forEach((namedNode) => {
      completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
    });
    return completeChildren;
  } else {
    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    compoundWriteGetCompleteChildren(merge).forEach((namedNode) => {
      completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
    });
    return completeChildren;
  }
}
function writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {
  assert(existingEventSnap || existingServerSnap, "Either existingEventSnap or existingServerSnap must exist");
  const path = pathChild(treePath, childPath);
  if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) {
    return null;
  } else {
    const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
    if (compoundWriteIsEmpty(childMerge)) {
      return existingServerSnap.getChild(childPath);
    } else {
      return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));
    }
  }
}
function writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) {
  const path = pathChild(treePath, childKey);
  const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
  if (shadowingNode != null) {
    return shadowingNode;
  } else {
    if (existingServerSnap.isCompleteForChild(childKey)) {
      const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
      return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));
    } else {
      return null;
    }
  }
}
function writeTreeShadowingWrite(writeTree, path) {
  return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
}
function writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count, reverse, index) {
  let toIterate;
  const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
  const shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());
  if (shadowingNode != null) {
    toIterate = shadowingNode;
  } else if (completeServerData != null) {
    toIterate = compoundWriteApply(merge, completeServerData);
  } else {
    return [];
  }
  toIterate = toIterate.withIndex(index);
  if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {
    const nodes = [];
    const cmp = index.getCompare();
    const iter = reverse ? toIterate.getReverseIteratorFrom(startPost, index) : toIterate.getIteratorFrom(startPost, index);
    let next = iter.getNext();
    while (next && nodes.length < count) {
      if (cmp(next, startPost) !== 0) {
        nodes.push(next);
      }
      next = iter.getNext();
    }
    return nodes;
  } else {
    return [];
  }
}
function newWriteTree() {
  return {
    visibleWrites: CompoundWrite.empty(),
    allWrites: [],
    lastWriteId: -1
  };
}
function writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
  return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);
}
function writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) {
  return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);
}
function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) {
  return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);
}
function writeTreeRefShadowingWrite(writeTreeRef, path) {
  return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));
}
function writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count, reverse, index) {
  return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index);
}
function writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) {
  return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);
}
function writeTreeRefChild(writeTreeRef, childName) {
  return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);
}
function newWriteTreeRef(path, writeTree) {
  return {
    treePath: path,
    writeTree
  };
}
function viewProcessorAssertIndexed(viewProcessor, viewCache) {
  assert(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), "Event snap not indexed");
  assert(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), "Server snap not indexed");
}
function viewProcessorApplyOperation(viewProcessor, oldViewCache, operation, writesCache, completeCache) {
  const accumulator = new ChildChangeAccumulator();
  let newViewCache2, filterServerNode;
  if (operation.type === OperationType.OVERWRITE) {
    const overwrite = operation;
    if (overwrite.source.fromUser) {
      newViewCache2 = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);
    } else {
      assert(overwrite.source.fromServer, "Unknown source.");
      filterServerNode = overwrite.source.tagged || oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path);
      newViewCache2 = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
    }
  } else if (operation.type === OperationType.MERGE) {
    const merge = operation;
    if (merge.source.fromUser) {
      newViewCache2 = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);
    } else {
      assert(merge.source.fromServer, "Unknown source.");
      filterServerNode = merge.source.tagged || oldViewCache.serverCache.isFiltered();
      newViewCache2 = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
    }
  } else if (operation.type === OperationType.ACK_USER_WRITE) {
    const ackUserWrite = operation;
    if (!ackUserWrite.revert) {
      newViewCache2 = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
    } else {
      newViewCache2 = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);
    }
  } else if (operation.type === OperationType.LISTEN_COMPLETE) {
    newViewCache2 = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);
  } else {
    throw assertionError("Unknown operation type: " + operation.type);
  }
  const changes = accumulator.getChanges();
  viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache2, changes);
  return { viewCache: newViewCache2, changes };
}
function viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache2, accumulator) {
  const eventSnap = newViewCache2.eventCache;
  if (eventSnap.isFullyInitialized()) {
    const isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
    const oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);
    if (accumulator.length > 0 || !oldViewCache.eventCache.isFullyInitialized() || isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap) || !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {
      accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache2)));
    }
  }
}
function viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, viewCache, changePath, writesCache, source, accumulator) {
  const oldEventSnap = viewCache.eventCache;
  if (writeTreeRefShadowingWrite(writesCache, changePath) != null) {
    return viewCache;
  } else {
    let newEventCache, serverNode;
    if (pathIsEmpty(changePath)) {
      assert(viewCache.serverCache.isFullyInitialized(), "If change path is empty, we must have complete server data");
      if (viewCache.serverCache.isFiltered()) {
        const serverCache = viewCacheGetCompleteServerSnap(viewCache);
        const completeChildren = serverCache instanceof ChildrenNode ? serverCache : ChildrenNode.EMPTY_NODE;
        const completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);
        newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);
      } else {
        const completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
        newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);
      }
    } else {
      const childKey = pathGetFront(changePath);
      if (childKey === ".priority") {
        assert(pathGetLength(changePath) === 1, "Can't have a priority with additional path components");
        const oldEventNode = oldEventSnap.getNode();
        serverNode = viewCache.serverCache.getNode();
        const updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);
        if (updatedPriority != null) {
          newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);
        } else {
          newEventCache = oldEventSnap.getNode();
        }
      } else {
        const childChangePath = pathPopFront(changePath);
        let newEventChild;
        if (oldEventSnap.isCompleteForChild(childKey)) {
          serverNode = viewCache.serverCache.getNode();
          const eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);
          if (eventChildUpdate != null) {
            newEventChild = oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath, eventChildUpdate);
          } else {
            newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);
          }
        } else {
          newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
        }
        if (newEventChild != null) {
          newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);
        } else {
          newEventCache = oldEventSnap.getNode();
        }
      }
    }
    return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());
  }
}
function viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {
  const oldServerSnap = oldViewCache.serverCache;
  let newServerCache;
  const serverFilter = filterServerNode ? viewProcessor.filter : viewProcessor.filter.getIndexedFilter();
  if (pathIsEmpty(changePath)) {
    newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);
  } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {
    const newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);
    newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
  } else {
    const childKey = pathGetFront(changePath);
    if (!oldServerSnap.isCompleteForPath(changePath) && pathGetLength(changePath) > 1) {
      return oldViewCache;
    }
    const childChangePath = pathPopFront(changePath);
    const childNode = oldServerSnap.getNode().getImmediateChild(childKey);
    const newChildNode = childNode.updateChild(childChangePath, changedSnap);
    if (childKey === ".priority") {
      newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);
    } else {
      newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);
    }
  }
  const newViewCache2 = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());
  const source = new WriteTreeCompleteChildSource(writesCache, newViewCache2, completeCache);
  return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache2, changePath, writesCache, source, accumulator);
}
function viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {
  const oldEventSnap = oldViewCache.eventCache;
  let newViewCache2, newEventCache;
  const source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);
  if (pathIsEmpty(changePath)) {
    newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);
    newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());
  } else {
    const childKey = pathGetFront(changePath);
    if (childKey === ".priority") {
      newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);
      newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
    } else {
      const childChangePath = pathPopFront(changePath);
      const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
      let newChild;
      if (pathIsEmpty(childChangePath)) {
        newChild = changedSnap;
      } else {
        const childNode = source.getCompleteChild(childKey);
        if (childNode != null) {
          if (pathGetBack(childChangePath) === ".priority" && childNode.getChild(pathParent(childChangePath)).isEmpty()) {
            newChild = childNode;
          } else {
            newChild = childNode.updateChild(childChangePath, changedSnap);
          }
        } else {
          newChild = ChildrenNode.EMPTY_NODE;
        }
      }
      if (!oldChild.equals(newChild)) {
        const newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);
        newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());
      } else {
        newViewCache2 = oldViewCache;
      }
    }
  }
  return newViewCache2;
}
function viewProcessorCacheHasChild(viewCache, childKey) {
  return viewCache.eventCache.isCompleteForChild(childKey);
}
function viewProcessorApplyUserMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, accumulator) {
  let curViewCache = viewCache;
  changedChildren.foreach((relativePath, childNode) => {
    const writePath = pathChild(path, relativePath);
    if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
      curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
    }
  });
  changedChildren.foreach((relativePath, childNode) => {
    const writePath = pathChild(path, relativePath);
    if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
      curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
    }
  });
  return curViewCache;
}
function viewProcessorApplyMerge(viewProcessor, node, merge) {
  merge.foreach((relativePath, childNode) => {
    node = node.updateChild(relativePath, childNode);
  });
  return node;
}
function viewProcessorApplyServerMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {
  if (viewCache.serverCache.getNode().isEmpty() && !viewCache.serverCache.isFullyInitialized()) {
    return viewCache;
  }
  let curViewCache = viewCache;
  let viewMergeTree;
  if (pathIsEmpty(path)) {
    viewMergeTree = changedChildren;
  } else {
    viewMergeTree = new ImmutableTree(null).setTree(path, changedChildren);
  }
  const serverNode = viewCache.serverCache.getNode();
  viewMergeTree.children.inorderTraversal((childKey, childTree) => {
    if (serverNode.hasChild(childKey)) {
      const serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);
      const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);
      curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
    }
  });
  viewMergeTree.children.inorderTraversal((childKey, childMergeTree) => {
    const isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) && childMergeTree.value === void 0;
    if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {
      const serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);
      const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);
      curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
    }
  });
  return curViewCache;
}
function viewProcessorAckUserWrite(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {
  if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) {
    return viewCache;
  }
  const filterServerNode = viewCache.serverCache.isFiltered();
  const serverCache = viewCache.serverCache;
  if (affectedTree.value != null) {
    if (pathIsEmpty(ackPath) && serverCache.isFullyInitialized() || serverCache.isCompleteForPath(ackPath)) {
      return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
    } else if (pathIsEmpty(ackPath)) {
      let changedChildren = new ImmutableTree(null);
      serverCache.getNode().forEachChild(KEY_INDEX, (name22, node) => {
        changedChildren = changedChildren.set(new Path(name22), node);
      });
      return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);
    } else {
      return viewCache;
    }
  } else {
    let changedChildren = new ImmutableTree(null);
    affectedTree.foreach((mergePath, value) => {
      const serverCachePath = pathChild(ackPath, mergePath);
      if (serverCache.isCompleteForPath(serverCachePath)) {
        changedChildren = changedChildren.set(mergePath, serverCache.getNode().getChild(serverCachePath));
      }
    });
    return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);
  }
}
function viewProcessorListenComplete(viewProcessor, viewCache, path, writesCache, accumulator) {
  const oldServerNode = viewCache.serverCache;
  const newViewCache2 = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path), oldServerNode.isFiltered());
  return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache2, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);
}
function viewProcessorRevertUserWrite(viewProcessor, viewCache, path, writesCache, completeServerCache, accumulator) {
  let complete;
  if (writeTreeRefShadowingWrite(writesCache, path) != null) {
    return viewCache;
  } else {
    const source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);
    const oldEventCache = viewCache.eventCache.getNode();
    let newEventCache;
    if (pathIsEmpty(path) || pathGetFront(path) === ".priority") {
      let newNode;
      if (viewCache.serverCache.isFullyInitialized()) {
        newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
      } else {
        const serverChildren = viewCache.serverCache.getNode();
        assert(serverChildren instanceof ChildrenNode, "serverChildren would be complete if leaf node");
        newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);
      }
      newNode = newNode;
      newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);
    } else {
      const childKey = pathGetFront(path);
      let newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
      if (newChild == null && viewCache.serverCache.isCompleteForChild(childKey)) {
        newChild = oldEventCache.getImmediateChild(childKey);
      }
      if (newChild != null) {
        newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path), source, accumulator);
      } else if (viewCache.eventCache.getNode().hasChild(childKey)) {
        newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path), source, accumulator);
      } else {
        newEventCache = oldEventCache;
      }
      if (newEventCache.isEmpty() && viewCache.serverCache.isFullyInitialized()) {
        complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
        if (complete.isLeafNode()) {
          newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);
        }
      }
    }
    complete = viewCache.serverCache.isFullyInitialized() || writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;
    return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());
  }
}
function viewGetCompleteServerCache(view, path) {
  const cache = viewCacheGetCompleteServerSnap(view.viewCache_);
  if (cache) {
    if (view.query._queryParams.loadsAllData() || !pathIsEmpty(path) && !cache.getImmediateChild(pathGetFront(path)).isEmpty()) {
      return cache.getChild(path);
    }
  }
  return null;
}
function viewApplyOperation(view, operation, writesCache, completeServerCache) {
  if (operation.type === OperationType.MERGE && operation.source.queryId !== null) {
    assert(viewCacheGetCompleteServerSnap(view.viewCache_), "We should always have a full cache before handling merges");
    assert(viewCacheGetCompleteEventSnap(view.viewCache_), "Missing event cache, even though we have a server cache");
  }
  const oldViewCache = view.viewCache_;
  const result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);
  viewProcessorAssertIndexed(view.processor_, result.viewCache);
  assert(result.viewCache.serverCache.isFullyInitialized() || !oldViewCache.serverCache.isFullyInitialized(), "Once a server snap is complete, it should never go back");
  view.viewCache_ = result.viewCache;
  return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);
}
function viewGenerateEventsForChanges_(view, changes, eventCache, eventRegistration) {
  const registrations = eventRegistration ? [eventRegistration] : view.eventRegistrations_;
  return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);
}
function syncPointSetReferenceConstructor(val) {
  assert(!referenceConstructor$1, "__referenceConstructor has already been defined");
  referenceConstructor$1 = val;
}
function syncPointApplyOperation(syncPoint, operation, writesCache, optCompleteServerCache) {
  const queryId = operation.source.queryId;
  if (queryId !== null) {
    const view = syncPoint.views.get(queryId);
    assert(view != null, "SyncTree gave us an op for an invalid query.");
    return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);
  } else {
    let events22 = [];
    for (const view of syncPoint.views.values()) {
      events22 = events22.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));
    }
    return events22;
  }
}
function syncPointGetCompleteServerCache(syncPoint, path) {
  let serverCache = null;
  for (const view of syncPoint.views.values()) {
    serverCache = serverCache || viewGetCompleteServerCache(view, path);
  }
  return serverCache;
}
function syncTreeSetReferenceConstructor(val) {
  assert(!referenceConstructor, "__referenceConstructor has already been defined");
  referenceConstructor = val;
}
function syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) {
  writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);
  if (!visible) {
    return [];
  } else {
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));
  }
}
function syncTreeAckUserWrite(syncTree, writeId, revert = false) {
  const write = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);
  const needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);
  if (!needToReevaluate) {
    return [];
  } else {
    let affectedTree = new ImmutableTree(null);
    if (write.snap != null) {
      affectedTree = affectedTree.set(newEmptyPath(), true);
    } else {
      each2(write.children, (pathString) => {
        affectedTree = affectedTree.set(new Path(pathString), true);
      });
    }
    return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write.path, affectedTree, revert));
  }
}
function syncTreeApplyServerOverwrite(syncTree, path, newData) {
  return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));
}
function syncTreeApplyServerMerge(syncTree, path, changedChildren) {
  const changeTree = ImmutableTree.fromObject(changedChildren);
  return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));
}
function syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) {
  const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
  if (queryKey != null) {
    const r = syncTreeParseQueryKey_(queryKey);
    const queryPath = r.path, queryId = r.queryId;
    const relativePath = newRelativePath(queryPath, path);
    const op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);
    return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
  } else {
    return [];
  }
}
function syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) {
  const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
  if (queryKey) {
    const r = syncTreeParseQueryKey_(queryKey);
    const queryPath = r.path, queryId = r.queryId;
    const relativePath = newRelativePath(queryPath, path);
    const changeTree = ImmutableTree.fromObject(changedChildren);
    const op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);
    return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
  } else {
    return [];
  }
}
function syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) {
  const includeHiddenSets = true;
  const writeTree = syncTree.pendingWriteTree_;
  const serverCache = syncTree.syncPointTree_.findOnPath(path, (pathSoFar, syncPoint) => {
    const relativePath = newRelativePath(pathSoFar, path);
    const serverCache2 = syncPointGetCompleteServerCache(syncPoint, relativePath);
    if (serverCache2) {
      return serverCache2;
    }
  });
  return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);
}
function syncTreeApplyOperationToSyncPoints_(syncTree, operation) {
  return syncTreeApplyOperationHelper_(operation, syncTree.syncPointTree_, null, writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath()));
}
function syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) {
  if (pathIsEmpty(operation.path)) {
    return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
  } else {
    const syncPoint = syncPointTree.get(newEmptyPath());
    if (serverCache == null && syncPoint != null) {
      serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
    }
    let events22 = [];
    const childName = pathGetFront(operation.path);
    const childOperation = operation.operationForChild(childName);
    const childTree = syncPointTree.children.get(childName);
    if (childTree && childOperation) {
      const childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;
      const childWritesCache = writeTreeRefChild(writesCache, childName);
      events22 = events22.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
    }
    if (syncPoint) {
      events22 = events22.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
    }
    return events22;
  }
}
function syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) {
  const syncPoint = syncPointTree.get(newEmptyPath());
  if (serverCache == null && syncPoint != null) {
    serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
  }
  let events22 = [];
  syncPointTree.children.inorderTraversal((childName, childTree) => {
    const childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;
    const childWritesCache = writeTreeRefChild(writesCache, childName);
    const childOperation = operation.operationForChild(childName);
    if (childOperation) {
      events22 = events22.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));
    }
  });
  if (syncPoint) {
    events22 = events22.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
  }
  return events22;
}
function syncTreeQueryKeyForTag_(syncTree, tag) {
  return syncTree.tagToQueryMap.get(tag);
}
function syncTreeParseQueryKey_(queryKey) {
  const splitIndex = queryKey.indexOf("$");
  assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, "Bad queryKey.");
  return {
    queryId: queryKey.substr(splitIndex + 1),
    path: new Path(queryKey.substr(0, splitIndex))
  };
}
function syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) {
  const syncPoint = syncTree.syncPointTree_.get(queryPath);
  assert(syncPoint, "Missing sync point for query tag that we're tracking");
  const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);
  return syncPointApplyOperation(syncPoint, operation, writesCache, null);
}
function resolveDeferredValue(node, existingVal, serverValues) {
  const rawPri = node.getPriority().val();
  const priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild(".priority"), serverValues);
  let newNode;
  if (node.isLeafNode()) {
    const leafNode = node;
    const value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);
    if (value !== leafNode.getValue() || priority !== leafNode.getPriority().val()) {
      return new LeafNode(value, nodeFromJSON(priority));
    } else {
      return node;
    }
  } else {
    const childrenNode = node;
    newNode = childrenNode;
    if (priority !== childrenNode.getPriority().val()) {
      newNode = newNode.updatePriority(new LeafNode(priority));
    }
    childrenNode.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
      const newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);
      if (newChildNode !== childNode) {
        newNode = newNode.updateImmediateChild(childName, newChildNode);
      }
    });
    return newNode;
  }
}
function treeSubTree(tree, pathObj) {
  let path = pathObj instanceof Path ? pathObj : new Path(pathObj);
  let child = tree, next = pathGetFront(path);
  while (next !== null) {
    const childNode = safeGet(child.node.children, next) || {
      children: {},
      childCount: 0
    };
    child = new Tree(next, child, childNode);
    path = pathPopFront(path);
    next = pathGetFront(path);
  }
  return child;
}
function treeGetValue(tree) {
  return tree.node.value;
}
function treeSetValue(tree, value) {
  tree.node.value = value;
  treeUpdateParents(tree);
}
function treeHasChildren(tree) {
  return tree.node.childCount > 0;
}
function treeIsEmpty(tree) {
  return treeGetValue(tree) === void 0 && !treeHasChildren(tree);
}
function treeForEachChild(tree, action) {
  each2(tree.node.children, (child, childTree) => {
    action(new Tree(child, tree, childTree));
  });
}
function treeForEachDescendant(tree, action, includeSelf, childrenFirst) {
  if (includeSelf && !childrenFirst) {
    action(tree);
  }
  treeForEachChild(tree, (child) => {
    treeForEachDescendant(child, action, true, childrenFirst);
  });
  if (includeSelf && childrenFirst) {
    action(tree);
  }
}
function treeForEachAncestor(tree, action, includeSelf) {
  let node = includeSelf ? tree : tree.parent;
  while (node !== null) {
    if (action(node)) {
      return true;
    }
    node = node.parent;
  }
  return false;
}
function treeGetPath(tree) {
  return new Path(tree.parent === null ? tree.name : treeGetPath(tree.parent) + "/" + tree.name);
}
function treeUpdateParents(tree) {
  if (tree.parent !== null) {
    treeUpdateChild(tree.parent, tree.name, tree);
  }
}
function treeUpdateChild(tree, childName, child) {
  const childEmpty = treeIsEmpty(child);
  const childExists = contains(tree.node.children, childName);
  if (childEmpty && childExists) {
    delete tree.node.children[childName];
    tree.node.childCount--;
    treeUpdateParents(tree);
  } else if (!childEmpty && !childExists) {
    tree.node.children[childName] = child.node;
    tree.node.childCount++;
    treeUpdateParents(tree);
  }
}
function eventQueueQueueEvents(eventQueue, eventDataList) {
  let currList = null;
  for (let i = 0; i < eventDataList.length; i++) {
    const data = eventDataList[i];
    const path = data.getPath();
    if (currList !== null && !pathEquals(path, currList.path)) {
      eventQueue.eventLists_.push(currList);
      currList = null;
    }
    if (currList === null) {
      currList = { events: [], path };
    }
    currList.events.push(data);
  }
  if (currList) {
    eventQueue.eventLists_.push(currList);
  }
}
function eventQueueRaiseEventsForChangedPath(eventQueue, changedPath, eventDataList) {
  eventQueueQueueEvents(eventQueue, eventDataList);
  eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, (eventPath) => pathContains(eventPath, changedPath) || pathContains(changedPath, eventPath));
}
function eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, predicate) {
  eventQueue.recursionDepth_++;
  let sentAll = true;
  for (let i = 0; i < eventQueue.eventLists_.length; i++) {
    const eventList = eventQueue.eventLists_[i];
    if (eventList) {
      const eventPath = eventList.path;
      if (predicate(eventPath)) {
        eventListRaise(eventQueue.eventLists_[i]);
        eventQueue.eventLists_[i] = null;
      } else {
        sentAll = false;
      }
    }
  }
  if (sentAll) {
    eventQueue.eventLists_ = [];
  }
  eventQueue.recursionDepth_--;
}
function eventListRaise(eventList) {
  for (let i = 0; i < eventList.events.length; i++) {
    const eventData = eventList.events[i];
    if (eventData !== null) {
      eventList.events[i] = null;
      const eventFn = eventData.getEventRunner();
      if (logger2) {
        log("event: " + eventData.toString());
      }
      exceptionGuard(eventFn);
    }
  }
}
function repoStart(repo, appId, authOverride) {
  repo.stats_ = statsManagerGetCollection(repo.repoInfo_);
  if (repo.forceRestClient_ || beingCrawled()) {
    repo.server_ = new ReadonlyRestClient(repo.repoInfo_, (pathString, data, isMerge, tag) => {
      repoOnDataUpdate(repo, pathString, data, isMerge, tag);
    }, repo.authTokenProvider_, repo.appCheckProvider_);
    setTimeout(() => repoOnConnectStatus(repo, true), 0);
  } else {
    if (typeof authOverride !== "undefined" && authOverride !== null) {
      if (typeof authOverride !== "object") {
        throw new Error("Only objects are supported for option databaseAuthVariableOverride");
      }
      try {
        stringify(authOverride);
      } catch (e) {
        throw new Error("Invalid authOverride provided: " + e);
      }
    }
    repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, appId, (pathString, data, isMerge, tag) => {
      repoOnDataUpdate(repo, pathString, data, isMerge, tag);
    }, (connectStatus) => {
      repoOnConnectStatus(repo, connectStatus);
    }, (updates) => {
      repoOnServerInfoUpdate(repo, updates);
    }, repo.authTokenProvider_, repo.appCheckProvider_, authOverride);
    repo.server_ = repo.persistentConnection_;
  }
  repo.authTokenProvider_.addTokenChangeListener((token) => {
    repo.server_.refreshAuthToken(token);
  });
  repo.appCheckProvider_.addTokenChangeListener((result) => {
    repo.server_.refreshAppCheckToken(result.token);
  });
  repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, () => new StatsReporter(repo.stats_, repo.server_));
  repo.infoData_ = new SnapshotHolder();
  repo.infoSyncTree_ = new SyncTree({
    startListening: (query, tag, currentHashFn, onComplete) => {
      let infoEvents = [];
      const node = repo.infoData_.getNode(query._path);
      if (!node.isEmpty()) {
        infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query._path, node);
        setTimeout(() => {
          onComplete("ok");
        }, 0);
      }
      return infoEvents;
    },
    stopListening: () => {
    }
  });
  repoUpdateInfo(repo, "connected", false);
  repo.serverSyncTree_ = new SyncTree({
    startListening: (query, tag, currentHashFn, onComplete) => {
      repo.server_.listen(query, currentHashFn, tag, (status, data) => {
        const events22 = onComplete(status, data);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events22);
      });
      return [];
    },
    stopListening: (query, tag) => {
      repo.server_.unlisten(query, tag);
    }
  });
}
function repoServerTime(repo) {
  const offsetNode = repo.infoData_.getNode(new Path(".info/serverTimeOffset"));
  const offset = offsetNode.val() || 0;
  return new Date().getTime() + offset;
}
function repoGenerateServerValues(repo) {
  return generateWithValues({
    timestamp: repoServerTime(repo)
  });
}
function repoOnDataUpdate(repo, pathString, data, isMerge, tag) {
  repo.dataUpdateCount++;
  const path = new Path(pathString);
  data = repo.interceptServerDataCallback_ ? repo.interceptServerDataCallback_(pathString, data) : data;
  let events22 = [];
  if (tag) {
    if (isMerge) {
      const taggedChildren = map(data, (raw) => nodeFromJSON(raw));
      events22 = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path, taggedChildren, tag);
    } else {
      const taggedSnap = nodeFromJSON(data);
      events22 = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path, taggedSnap, tag);
    }
  } else if (isMerge) {
    const changedChildren = map(data, (raw) => nodeFromJSON(raw));
    events22 = syncTreeApplyServerMerge(repo.serverSyncTree_, path, changedChildren);
  } else {
    const snap = nodeFromJSON(data);
    events22 = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap);
  }
  let affectedPath = path;
  if (events22.length > 0) {
    affectedPath = repoRerunTransactions(repo, path);
  }
  eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events22);
}
function repoOnConnectStatus(repo, connectStatus) {
  repoUpdateInfo(repo, "connected", connectStatus);
  if (connectStatus === false) {
    repoRunOnDisconnectEvents(repo);
  }
}
function repoOnServerInfoUpdate(repo, updates) {
  each2(updates, (key, value) => {
    repoUpdateInfo(repo, key, value);
  });
}
function repoUpdateInfo(repo, pathString, value) {
  const path = new Path("/.info/" + pathString);
  const newNode = nodeFromJSON(value);
  repo.infoData_.updateSnapshot(path, newNode);
  const events22 = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path, newNode);
  eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events22);
}
function repoGetNextWriteId(repo) {
  return repo.nextWriteId_++;
}
function repoRunOnDisconnectEvents(repo) {
  repoLog(repo, "onDisconnectEvents");
  const serverValues = repoGenerateServerValues(repo);
  const resolvedOnDisconnectTree = newSparseSnapshotTree();
  sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), (path, node) => {
    const resolved = resolveDeferredValueTree(path, node, repo.serverSyncTree_, serverValues);
    sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path, resolved);
  });
  let events22 = [];
  sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), (path, snap) => {
    events22 = events22.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap));
    const affectedPath = repoAbortTransactions(repo, path);
    repoRerunTransactions(repo, affectedPath);
  });
  repo.onDisconnect_ = newSparseSnapshotTree();
  eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events22);
}
function repoInterrupt(repo) {
  if (repo.persistentConnection_) {
    repo.persistentConnection_.interrupt(INTERRUPT_REASON);
  }
}
function repoLog(repo, ...varArgs) {
  let prefix = "";
  if (repo.persistentConnection_) {
    prefix = repo.persistentConnection_.id + ":";
  }
  log(prefix, ...varArgs);
}
function repoGetLatestState(repo, path, excludeSets) {
  return syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path, excludeSets) || ChildrenNode.EMPTY_NODE;
}
function repoSendReadyTransactions(repo, node = repo.transactionQueueTree_) {
  if (!node) {
    repoPruneCompletedTransactionsBelowNode(repo, node);
  }
  if (treeGetValue(node)) {
    const queue = repoBuildTransactionQueue(repo, node);
    assert(queue.length > 0, "Sending zero length transaction queue");
    const allRun = queue.every((transaction) => transaction.status === 0);
    if (allRun) {
      repoSendTransactionQueue(repo, treeGetPath(node), queue);
    }
  } else if (treeHasChildren(node)) {
    treeForEachChild(node, (childNode) => {
      repoSendReadyTransactions(repo, childNode);
    });
  }
}
function repoSendTransactionQueue(repo, path, queue) {
  const setsToIgnore = queue.map((txn) => {
    return txn.currentWriteId;
  });
  const latestState = repoGetLatestState(repo, path, setsToIgnore);
  let snapToSend = latestState;
  const latestHash = latestState.hash();
  for (let i = 0; i < queue.length; i++) {
    const txn = queue[i];
    assert(txn.status === 0, "tryToSendTransactionQueue_: items in queue should all be run.");
    txn.status = 1;
    txn.retryCount++;
    const relativePath = newRelativePath(path, txn.path);
    snapToSend = snapToSend.updateChild(relativePath, txn.currentOutputSnapshotRaw);
  }
  const dataToSend = snapToSend.val(true);
  const pathToSend = path;
  repo.server_.put(pathToSend.toString(), dataToSend, (status) => {
    repoLog(repo, "transaction put response", {
      path: pathToSend.toString(),
      status
    });
    let events22 = [];
    if (status === "ok") {
      const callbacks = [];
      for (let i = 0; i < queue.length; i++) {
        queue[i].status = 2;
        events22 = events22.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId));
        if (queue[i].onComplete) {
          callbacks.push(() => queue[i].onComplete(null, true, queue[i].currentOutputSnapshotResolved));
        }
        queue[i].unwatcher();
      }
      repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path));
      repoSendReadyTransactions(repo, repo.transactionQueueTree_);
      eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events22);
      for (let i = 0; i < callbacks.length; i++) {
        exceptionGuard(callbacks[i]);
      }
    } else {
      if (status === "datastale") {
        for (let i = 0; i < queue.length; i++) {
          if (queue[i].status === 3) {
            queue[i].status = 4;
          } else {
            queue[i].status = 0;
          }
        }
      } else {
        warn("transaction at " + pathToSend.toString() + " failed: " + status);
        for (let i = 0; i < queue.length; i++) {
          queue[i].status = 4;
          queue[i].abortReason = status;
        }
      }
      repoRerunTransactions(repo, path);
    }
  }, latestHash);
}
function repoRerunTransactions(repo, changedPath) {
  const rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);
  const path = treeGetPath(rootMostTransactionNode);
  const queue = repoBuildTransactionQueue(repo, rootMostTransactionNode);
  repoRerunTransactionQueue(repo, queue, path);
  return path;
}
function repoRerunTransactionQueue(repo, queue, path) {
  if (queue.length === 0) {
    return;
  }
  const callbacks = [];
  let events22 = [];
  const txnsToRerun = queue.filter((q2) => {
    return q2.status === 0;
  });
  const setsToIgnore = txnsToRerun.map((q2) => {
    return q2.currentWriteId;
  });
  for (let i = 0; i < queue.length; i++) {
    const transaction = queue[i];
    const relativePath = newRelativePath(path, transaction.path);
    let abortTransaction = false, abortReason;
    assert(relativePath !== null, "rerunTransactionsUnderNode_: relativePath should not be null.");
    if (transaction.status === 4) {
      abortTransaction = true;
      abortReason = transaction.abortReason;
      events22 = events22.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
    } else if (transaction.status === 0) {
      if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) {
        abortTransaction = true;
        abortReason = "maxretry";
        events22 = events22.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
      } else {
        const currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);
        transaction.currentInputSnapshot = currentNode;
        const newData = queue[i].update(currentNode.val());
        if (newData !== void 0) {
          validateFirebaseData("transaction failed: Data returned ", newData, transaction.path);
          let newDataNode = nodeFromJSON(newData);
          const hasExplicitPriority = typeof newData === "object" && newData != null && contains(newData, ".priority");
          if (!hasExplicitPriority) {
            newDataNode = newDataNode.updatePriority(currentNode.getPriority());
          }
          const oldWriteId = transaction.currentWriteId;
          const serverValues = repoGenerateServerValues(repo);
          const newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);
          transaction.currentOutputSnapshotRaw = newDataNode;
          transaction.currentOutputSnapshotResolved = newNodeResolved;
          transaction.currentWriteId = repoGetNextWriteId(repo);
          setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);
          events22 = events22.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));
          events22 = events22.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));
        } else {
          abortTransaction = true;
          abortReason = "nodata";
          events22 = events22.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
        }
      }
    }
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events22);
    events22 = [];
    if (abortTransaction) {
      queue[i].status = 2;
      (function(unwatcher) {
        setTimeout(unwatcher, Math.floor(0));
      })(queue[i].unwatcher);
      if (queue[i].onComplete) {
        if (abortReason === "nodata") {
          callbacks.push(() => queue[i].onComplete(null, false, queue[i].currentInputSnapshot));
        } else {
          callbacks.push(() => queue[i].onComplete(new Error(abortReason), false, null));
        }
      }
    }
  }
  repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);
  for (let i = 0; i < callbacks.length; i++) {
    exceptionGuard(callbacks[i]);
  }
  repoSendReadyTransactions(repo, repo.transactionQueueTree_);
}
function repoGetAncestorTransactionNode(repo, path) {
  let front;
  let transactionNode = repo.transactionQueueTree_;
  front = pathGetFront(path);
  while (front !== null && treeGetValue(transactionNode) === void 0) {
    transactionNode = treeSubTree(transactionNode, front);
    path = pathPopFront(path);
    front = pathGetFront(path);
  }
  return transactionNode;
}
function repoBuildTransactionQueue(repo, transactionNode) {
  const transactionQueue = [];
  repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);
  transactionQueue.sort((a, b) => a.order - b.order);
  return transactionQueue;
}
function repoAggregateTransactionQueuesForNode(repo, node, queue) {
  const nodeQueue = treeGetValue(node);
  if (nodeQueue) {
    for (let i = 0; i < nodeQueue.length; i++) {
      queue.push(nodeQueue[i]);
    }
  }
  treeForEachChild(node, (child) => {
    repoAggregateTransactionQueuesForNode(repo, child, queue);
  });
}
function repoPruneCompletedTransactionsBelowNode(repo, node) {
  const queue = treeGetValue(node);
  if (queue) {
    let to2 = 0;
    for (let from = 0; from < queue.length; from++) {
      if (queue[from].status !== 2) {
        queue[to2] = queue[from];
        to2++;
      }
    }
    queue.length = to2;
    treeSetValue(node, queue.length > 0 ? queue : void 0);
  }
  treeForEachChild(node, (childNode) => {
    repoPruneCompletedTransactionsBelowNode(repo, childNode);
  });
}
function repoAbortTransactions(repo, path) {
  const affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path));
  const transactionNode = treeSubTree(repo.transactionQueueTree_, path);
  treeForEachAncestor(transactionNode, (node) => {
    repoAbortTransactionsOnNode(repo, node);
  });
  repoAbortTransactionsOnNode(repo, transactionNode);
  treeForEachDescendant(transactionNode, (node) => {
    repoAbortTransactionsOnNode(repo, node);
  });
  return affectedPath;
}
function repoAbortTransactionsOnNode(repo, node) {
  const queue = treeGetValue(node);
  if (queue) {
    const callbacks = [];
    let events22 = [];
    let lastSent = -1;
    for (let i = 0; i < queue.length; i++) {
      if (queue[i].status === 3)
        ;
      else if (queue[i].status === 1) {
        assert(lastSent === i - 1, "All SENT items should be at beginning of queue.");
        lastSent = i;
        queue[i].status = 3;
        queue[i].abortReason = "set";
      } else {
        assert(queue[i].status === 0, "Unexpected transaction status in abort");
        queue[i].unwatcher();
        events22 = events22.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId, true));
        if (queue[i].onComplete) {
          callbacks.push(queue[i].onComplete.bind(null, new Error("set"), false, null));
        }
      }
    }
    if (lastSent === -1) {
      treeSetValue(node, void 0);
    } else {
      queue.length = lastSent + 1;
    }
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events22);
    for (let i = 0; i < callbacks.length; i++) {
      exceptionGuard(callbacks[i]);
    }
  }
}
function decodePath(pathString) {
  let pathStringDecoded = "";
  const pieces = pathString.split("/");
  for (let i = 0; i < pieces.length; i++) {
    if (pieces[i].length > 0) {
      let piece = pieces[i];
      try {
        piece = decodeURIComponent(piece.replace(/\+/g, " "));
      } catch (e) {
      }
      pathStringDecoded += "/" + piece;
    }
  }
  return pathStringDecoded;
}
function decodeQuery(queryString) {
  const results = {};
  if (queryString.charAt(0) === "?") {
    queryString = queryString.substring(1);
  }
  for (const segment of queryString.split("&")) {
    if (segment.length === 0) {
      continue;
    }
    const kv = segment.split("=");
    if (kv.length === 2) {
      results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
    } else {
      warn(`Invalid query segment '${segment}' in query '${queryString}'`);
    }
  }
  return results;
}
function repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url2, nodeAdmin) {
  let dbUrl = url2 || app.options.databaseURL;
  if (dbUrl === void 0) {
    if (!app.options.projectId) {
      fatal("Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp().");
    }
    log("Using default host for project ", app.options.projectId);
    dbUrl = `${app.options.projectId}-default-rtdb.firebaseio.com`;
  }
  let parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
  let repoInfo = parsedUrl.repoInfo;
  let isEmulator;
  let dbEmulatorHost = void 0;
  if (typeof process !== "undefined") {
    dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];
  }
  if (dbEmulatorHost) {
    isEmulator = true;
    dbUrl = `http://${dbEmulatorHost}?ns=${repoInfo.namespace}`;
    parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
    repoInfo = parsedUrl.repoInfo;
  } else {
    isEmulator = !parsedUrl.repoInfo.secure;
  }
  const authTokenProvider = nodeAdmin && isEmulator ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER) : new FirebaseAuthTokenProvider(app.name, app.options, authProvider);
  validateUrl("Invalid Firebase Database URL", parsedUrl);
  if (!pathIsEmpty(parsedUrl.path)) {
    fatal("Database URL must point to the root of a Firebase Database (not including a child path).");
  }
  const repo = repoManagerCreateRepo(repoInfo, app, authTokenProvider, new AppCheckTokenProvider(app.name, appCheckProvider));
  return new Database(repo, app);
}
function repoManagerDeleteRepo(repo, appName) {
  const appRepos = repos[appName];
  if (!appRepos || appRepos[repo.key] !== repo) {
    fatal(`Database ${appName}(${repo.repoInfo_}) has already been deleted.`);
  }
  repoInterrupt(repo);
  delete appRepos[repo.key];
}
function repoManagerCreateRepo(repoInfo, app, authTokenProvider, appCheckProvider) {
  let appRepos = repos[app.name];
  if (!appRepos) {
    appRepos = {};
    repos[app.name] = appRepos;
  }
  let repo = appRepos[repoInfo.toURLString()];
  if (repo) {
    fatal("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.");
  }
  repo = new Repo(repoInfo, useRestClient, authTokenProvider, appCheckProvider);
  appRepos[repoInfo.toURLString()] = repo;
  return repo;
}
function registerDatabase(variant) {
  setSDKVersion(SDK_VERSION);
  _registerComponent(new Component("database", (container, { instanceIdentifier: url2 }) => {
    const app = container.getProvider("app").getImmediate();
    const authProvider = container.getProvider("auth-internal");
    const appCheckProvider = container.getProvider("app-check-internal");
    return repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url2);
  }, "PUBLIC").setMultipleInstances(true));
  registerVersion(name5, version5, variant);
  registerVersion(name5, version5, "esm2017");
}
async function mountNewTrack({ track, participant }) {
  switch (track.kind) {
    case "audio":
      if (participant.local)
        return;
      else {
        const audioElement = document.createElement("audio");
        audioElement.srcObject = new MediaStream([track]);
        audioElement.setAttribute("id", "audio" + participant.user_id);
        audioElement.setAttribute("playsinline", true);
        audioElement.setAttribute("autoplay", true);
        document.getElementById("container-for-audio-elements").appendChild(audioElement);
      }
      break;
  }
}
async function unmountTrack({ track, participant }) {
  const trackElement = document.getElementById(track.id);
  if (trackElement) {
    trackElement.srcObject = null;
    trackElement.remove();
  }
}
function load2({ page: page2 }) {
  return {
    props: {
      classID: page2.params.class,
      roomID: page2.params.room
    }
  };
}
var import_node_fetch7, import_util2, import_buffer, import_stream2, import_crypto2, import_url2, import_assert, import_net, import_tls, import_daily_js, import_cookie7, I2, Svg, CommonIcon, Icon, Autocomplete, ClassDropdownMenu, cssClasses2, strings2, MDCDismissibleDrawerFoundation, MDCModalDrawerFoundation, Drawer, AppContent, Content, css$1, LeftDrawer, safeBuffer, events2, R2, ReflectApply, ReflectOwnKeys, NumberIsNaN, defaultMaxListeners, streams$1, Stream$3, util$b, IO, Messages, Headers$3, headers, Buffer$9, StreamReader, stream_reader, Buffer$8, Emitter, util$a, streams, Headers$2, Reader, Base$7, instance$b, key$b, base, httpParser, assert2, kOnHeaders, kOnHeadersComplete, kOnBody, kOnMessageComplete, compatMode0_12, methods, method_connect, headerState, stateFinishAllowed, headerExp, headerContinueExp, requestExp, responseExp, NodeHTTPParser, Buffer$7, TYPES, HttpParser$3, VERSION, http_parser, TOKEN, NOTOKEN, QUOTED, PARAM, EXT, EXT_LIST, NUMBER, hasOwnProperty, Parser$1, Offers, parser, RingBuffer$2, ring_buffer, RingBuffer$1, Functor$1, functor, RingBuffer, Pledge$2, pledge, Functor, Pledge$1, Cell$1, cell, Cell, Pledge, Pipeline$1, pipeline2, Parser, Pipeline, Extensions$1, instance$a, key$a, websocket_extensions, Frame$1, instance$9, key$9, frame, Buffer$6, Message$1, instance$8, key$8, message, Buffer$5, crypto$2, util$9, Extensions, Base$6, Frame, Message, Hybi$2, instance$7, key$7, hybi, Buffer$4, Stream$2, url$2, util$8, Base$5, Headers$1, HttpParser$2, PORTS, Proxy$1, instance$6, key$6, proxy, Buffer$3, crypto$1, url$1, util$7, HttpParser$1, Base$4, Hybi$1, Proxy2, Client$2, instance$5, key$5, client$1, Buffer$2, Base$3, util$6, Draft75$2, instance$4, key$4, draft75, Buffer$1, Base$2, Draft75$1, crypto, util$5, numberFromKey, spacesInKey, Draft76$1, instance$3, key$3, draft76, util$4, HttpParser, Base$1, Draft75, Draft76, Hybi, Server$1, instance$2, key$2, server, Base, Client$1, Server, Driver, driver$4, Event$3, event, Event$2, EventTarget$2, event_target, Stream$1, util$3, driver$3, EventTarget$1, Event$1, API$3, instance$1, method$1, key$1, api, util$2, net, tls, url, driver$2, API$2, DEFAULT_PORTS, SECURE_PROTOCOLS, Client, client, Stream2, util$1, driver$1, Headers3, API$1, EventTarget, Event3, EventSource, instance, method, key, eventsource, util, driver, API, WebSocket$1, websocket, PROTOCOL_VERSION, VERSION_PARAM, TRANSPORT_SESSION_PARAM, REFERER_PARAM, FORGE_REF, FORGE_DOMAIN_RE, LAST_SESSION_PARAM, APPLICATION_ID_PARAM, APP_CHECK_TOKEN_PARAM, WEBSOCKET, LONG_POLLING, DOMStorageWrapper, MemoryStorage, createStoragefor, PersistentStorage, SessionStorage, logClient2, LUIDGenerator, sha1, buildLogMessage_, logger2, firstLog_, enableLogging$1, log, logWrapper, error, fatal, warn, warnIfPageIsSecure, isInvalidJSONNumber, executeWhenDOMReady, MIN_NAME, MAX_NAME, nameCompare, stringCompare, requireKey, ObjectToUniqueKey, splitStringBySize, doubleToIEEE754String, isChromeExtensionContentScript, isWindowsStoreApp, INTEGER_REGEXP_, INTEGER_32_MIN, INTEGER_32_MAX, tryParseInt, exceptionGuard, beingCrawled, setTimeoutNonBlocking, RepoInfo, StatsCollection, collections, reporters, SDK_VERSION2, WEBSOCKET_MAX_FRAME_SIZE, WEBSOCKET_KEEPALIVE_INTERVAL, WebSocketImpl, WebSocketConnection, name5, version5, AppCheckTokenProvider, FirebaseAuthTokenProvider, EmulatorTokenProvider, PacketReceiver, FIREBASE_LONGPOLL_START_PARAM, FIREBASE_LONGPOLL_CLOSE_COMMAND, FIREBASE_LONGPOLL_COMMAND_CB_NAME, FIREBASE_LONGPOLL_DATA_CB_NAME, FIREBASE_LONGPOLL_ID_PARAM, FIREBASE_LONGPOLL_PW_PARAM, FIREBASE_LONGPOLL_SERIAL_PARAM, FIREBASE_LONGPOLL_CALLBACK_ID_PARAM, FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM, FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET, FIREBASE_LONGPOLL_DATA_PARAM, FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM, MAX_URL_DATA_SIZE, SEG_HEADER_SIZE, MAX_PAYLOAD_SIZE, KEEPALIVE_REQUEST_INTERVAL, LP_CONNECT_TIMEOUT, BrowserPollConnection, FirebaseIFrameScriptHolder, TransportManager, UPGRADE_TIMEOUT, DELAY_BEFORE_SENDING_EXTRA_REQUESTS, BYTES_SENT_HEALTHY_OVERRIDE, BYTES_RECEIVED_HEALTHY_OVERRIDE, MESSAGE_TYPE, MESSAGE_DATA, CONTROL_SHUTDOWN, CONTROL_RESET, CONTROL_ERROR, CONTROL_PONG, SWITCH_ACK, END_TRANSMISSION, PING, SERVER_HELLO, Connection, ServerActions, EventEmitter, OnlineMonitor, MAX_PATH_DEPTH, MAX_PATH_LENGTH_BYTES, Path, ValidationPath, VisibilityMonitor, RECONNECT_MIN_DELAY, RECONNECT_MAX_DELAY_DEFAULT, GET_CONNECT_TIMEOUT, RECONNECT_MAX_DELAY_FOR_ADMINS, RECONNECT_DELAY_MULTIPLIER, RECONNECT_DELAY_RESET_TIMEOUT, SERVER_KILL_INTERRUPT_REASON, INVALID_TOKEN_THRESHOLD, PersistentConnection, NamedNode, Index, __EMPTY_NODE, KeyIndex, KEY_INDEX, SortedMapIterator, LLRBNode, LLRBEmptyNode, SortedMap, MAX_NODE$2, priorityHashText, validatePriorityNode, __childrenNodeConstructor, LeafNode, nodeFromJSON$1, MAX_NODE$1, PriorityIndex, PRIORITY_INDEX, LOG_2, Base12Num, buildChildSet, _defaultIndexMap, fallbackObject, IndexMap, EMPTY_NODE, ChildrenNode, MaxNode, MAX_NODE, USE_HINZE, PathIndex, ValueIndex, VALUE_INDEX, QueryParams, ReadonlyRestClient, SnapshotHolder, StatsListener, FIRST_STATS_MIN_TIME, FIRST_STATS_MAX_TIME, REPORT_STATS_INTERVAL, StatsReporter, OperationType, AckUserWrite, Overwrite, Merge, CacheNode, emptyChildrenSingleton, EmptyChildren, ImmutableTree, CompoundWrite, ChildChangeAccumulator, NoCompleteChildSource_, NO_COMPLETE_CHILD_SOURCE, WriteTreeCompleteChildSource, referenceConstructor$1, referenceConstructor, SyncTree, ExistingValueProvider, DeferredValueProvider, generateWithValues, resolveDeferredLeafValue, resolveScalarDeferredValue, resolveComplexDeferredValue, resolveDeferredValueTree, resolveDeferredValueSnapshot, Tree, INVALID_KEY_REGEX_, INVALID_PATH_REGEX_, MAX_LEAF_SIZE_, isValidKey2, isValidPathString, isValidRootPathString, validateFirebaseData, validateUrl, EventQueue, INTERRUPT_REASON, MAX_TRANSACTION_RETRIES, Repo, parseRepoInfo, parseDatabaseURL, QueryImpl, ReferenceImpl, FIREBASE_DATABASE_EMULATOR_HOST_VAR, repos, useRestClient, Database, RenderlessMyDocUpdater, API_KEY_SECRET, DailyVideoConference, css6, _layout2;
var init_layout_cdc2bbe6 = __esm({
  ".svelte-kit/output/server/chunks/__layout-cdc2bbe6.js"() {
    init_shims();
    init_app_dafecf1b();
    init_SelectionGroupIcon_51f30423();
    init_index_node_esm_4a860b07();
    init_store_85fd0788();
    init_index_c327074d_b42dfde1();
    import_node_fetch7 = __toModule(require_lib2());
    import_util2 = __toModule(require("util"));
    import_buffer = __toModule(require("buffer"));
    import_stream2 = __toModule(require("stream"));
    import_crypto2 = __toModule(require("crypto"));
    import_url2 = __toModule(require("url"));
    import_assert = __toModule(require("assert"));
    import_net = __toModule(require("net"));
    import_tls = __toModule(require("tls"));
    import_daily_js = __toModule(require_daily_iframe());
    import_cookie7 = __toModule(require_cookie());
    init_dist();
    I2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
      let { use = [] } = $$props;
      forwardEventsBuilder(get_current_component());
      let element;
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<i${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</i>`;
    });
    Svg = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
      let { use = [] } = $$props;
      forwardEventsBuilder(get_current_component());
      let element;
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<svg${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</svg>`;
    });
    CommonIcon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "class", "on", "component", "getElement"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { on: on2 = false } = $$props;
      let element;
      let { component = I2 } = $$props;
      const context = getContext("SMUI:icon:context");
      function getElement() {
        return element.getElement();
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.on === void 0 && $$bindings.on && on2 !== void 0)
        $$bindings.on(on2);
      if ($$props.component === void 0 && $$bindings.component && component !== void 0)
        $$bindings.component(component);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `${validate_component(component || missing_component, "svelte:component").$$render($$result, Object.assign({ use: [forwardEvents, ...use] }, {
          class: classMap({
            [className]: true,
            "mdc-button__icon": context === "button",
            "mdc-fab__icon": context === "fab",
            "mdc-icon-button__icon": context === "icon-button",
            "mdc-icon-button__icon--on": context === "icon-button" && on2,
            "mdc-tab__icon": context === "tab",
            "mdc-banner__icon": context === "banner",
            "mdc-segmented-button__icon": context === "segmented-button"
          })
        }, { "aria-hidden": "true" }, component === Svg ? { focusable: "false", tabindex: "-1" } : {}, $$restProps, { this: element }), {
          this: ($$value) => {
            element = $$value;
            $$settled = false;
          }
        }, {
          default: () => `${slots.default ? slots.default({}) : ``}`
        })}`;
      } while (!$$settled);
      return $$rendered;
    });
    Icon = CommonIcon;
    Autocomplete = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let menuOpen;
      let $$restProps = compute_rest_props($$props, [
        "use",
        "class",
        "options",
        "value",
        "getOptionDisabled",
        "getOptionLabel",
        "text",
        "label",
        "disabled",
        "toggle",
        "combobox",
        "clearOnBlur",
        "selectOnExactMatch",
        "showMenuWithNoInput",
        "noMatchesActionDisabled",
        "search",
        "menu$class",
        "menu$anchor",
        "menu$anchorCorner",
        "focus",
        "blur",
        "getElement"
      ]);
      forwardEventsBuilder(get_current_component());
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { options: options2 = [] } = $$props;
      let { value = void 0 } = $$props;
      let { getOptionDisabled = () => false } = $$props;
      let { getOptionLabel = (option) => option == null ? "" : `${option}` } = $$props;
      let { text = getOptionLabel(value) } = $$props;
      let { label = void 0 } = $$props;
      let { disabled = false } = $$props;
      let { toggle = false } = $$props;
      let { combobox = false } = $$props;
      let { clearOnBlur = !combobox } = $$props;
      let { selectOnExactMatch = true } = $$props;
      let { showMenuWithNoInput = true } = $$props;
      let { noMatchesActionDisabled = true } = $$props;
      let { search = async (input) => {
        const linput = input.toLowerCase();
        const fullOptions = typeof options2 == "function" ? await options2() : options2 || [];
        if (linput === "") {
          return fullOptions;
        }
        const result = fullOptions.filter((item) => getOptionLabel(item).toLowerCase().includes(linput));
        result.sort((a, b) => {
          const aString = getOptionLabel(a).toLowerCase();
          const bString = getOptionLabel(b).toLowerCase();
          if (aString.startsWith(linput) && !bString.startsWith(linput)) {
            return -1;
          } else if (bString.startsWith(linput) && !aString.startsWith(linput)) {
            return 1;
          }
          return 0;
        });
        return result;
      } } = $$props;
      let { menu$class = "" } = $$props;
      let { menu$anchor = false } = $$props;
      let { menu$anchorCorner = "BOTTOM_START" } = $$props;
      let element;
      let inputContainer;
      let loading = false;
      let error22 = false;
      let focused = false;
      let matches2 = [];
      let focusedIndex = -1;
      let previousText = void 0;
      let previousValue = value;
      let previousFocusedIndex = void 0;
      function selectOption(option, setText = true) {
        if (setText) {
          text = getOptionLabel(option);
        }
        value = option;
        if (!setText) {
          previousValue = option;
        }
        dispatch(element, "SMUIAutocomplete:selected", option);
      }
      function deselectOption(option, setText = true) {
        if (setText) {
          text = "";
        }
        value = void 0;
        if (!setText) {
          previousValue = void 0;
        }
        dispatch(element, "SMUIAutocomplete:deselected", option);
      }
      function getActiveMenuItems() {
        {
          return [];
        }
      }
      function focus() {
      }
      function blur() {
      }
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.options === void 0 && $$bindings.options && options2 !== void 0)
        $$bindings.options(options2);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      if ($$props.getOptionDisabled === void 0 && $$bindings.getOptionDisabled && getOptionDisabled !== void 0)
        $$bindings.getOptionDisabled(getOptionDisabled);
      if ($$props.getOptionLabel === void 0 && $$bindings.getOptionLabel && getOptionLabel !== void 0)
        $$bindings.getOptionLabel(getOptionLabel);
      if ($$props.text === void 0 && $$bindings.text && text !== void 0)
        $$bindings.text(text);
      if ($$props.label === void 0 && $$bindings.label && label !== void 0)
        $$bindings.label(label);
      if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
        $$bindings.disabled(disabled);
      if ($$props.toggle === void 0 && $$bindings.toggle && toggle !== void 0)
        $$bindings.toggle(toggle);
      if ($$props.combobox === void 0 && $$bindings.combobox && combobox !== void 0)
        $$bindings.combobox(combobox);
      if ($$props.clearOnBlur === void 0 && $$bindings.clearOnBlur && clearOnBlur !== void 0)
        $$bindings.clearOnBlur(clearOnBlur);
      if ($$props.selectOnExactMatch === void 0 && $$bindings.selectOnExactMatch && selectOnExactMatch !== void 0)
        $$bindings.selectOnExactMatch(selectOnExactMatch);
      if ($$props.showMenuWithNoInput === void 0 && $$bindings.showMenuWithNoInput && showMenuWithNoInput !== void 0)
        $$bindings.showMenuWithNoInput(showMenuWithNoInput);
      if ($$props.noMatchesActionDisabled === void 0 && $$bindings.noMatchesActionDisabled && noMatchesActionDisabled !== void 0)
        $$bindings.noMatchesActionDisabled(noMatchesActionDisabled);
      if ($$props.search === void 0 && $$bindings.search && search !== void 0)
        $$bindings.search(search);
      if ($$props.menu$class === void 0 && $$bindings.menu$class && menu$class !== void 0)
        $$bindings.menu$class(menu$class);
      if ($$props.menu$anchor === void 0 && $$bindings.menu$anchor && menu$anchor !== void 0)
        $$bindings.menu$anchor(menu$anchor);
      if ($$props.menu$anchorCorner === void 0 && $$bindings.menu$anchorCorner && menu$anchorCorner !== void 0)
        $$bindings.menu$anchorCorner(menu$anchorCorner);
      if ($$props.focus === void 0 && $$bindings.focus && focus !== void 0)
        $$bindings.focus(focus);
      if ($$props.blur === void 0 && $$bindings.blur && blur !== void 0)
        $$bindings.blur(blur);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          if (!combobox && previousValue !== value) {
            text = getOptionLabel(value);
            previousValue = value;
          } else if (combobox) {
            value = text;
          }
        }
        {
          if (previousText !== text) {
            if (!combobox && value != null && getOptionLabel(value) !== text) {
              deselectOption(value, false);
            }
            (async () => {
              loading = true;
              error22 = false;
              try {
                const searchResult = await search(text);
                if (searchResult !== false) {
                  matches2 = searchResult;
                  if (selectOnExactMatch) {
                    const exactMatch = matches2.find((match) => getOptionLabel(match) === text);
                    if (exactMatch && value !== exactMatch) {
                      selectOption(exactMatch);
                    }
                  }
                }
              } catch (e) {
                error22 = true;
              }
              loading = false;
            })();
            previousText = text;
          }
        }
        menuOpen = focused;
        {
          if (previousFocusedIndex !== focusedIndex) {
            const activeItems = getActiveMenuItems();
            activeItems.forEach((item, i) => {
              if (i !== focusedIndex) {
                item.activated = false;
              }
            });
            previousFocusedIndex = focusedIndex;
          }
        }
        $$rendered = `<div${spread([
          {
            class: escape_attribute_value(classMap({
              [className]: true,
              "smui-autocomplete": true
            }))
          },
          escape_object(exclude($$restProps, ["menu$", "textfield$", "list$"]))
        ])}${add_attribute("this", element, 0)}><div${add_attribute("this", inputContainer, 0)}>${slots.default ? slots.default({}) : `
      ${validate_component(Textfield, "Textfield").$$render($$result, Object.assign({ label }, { disabled }, prefixFilter($$restProps, "textfield$"), { value: text }), {
          value: ($$value) => {
            text = $$value;
            $$settled = false;
          }
        }, {})}
    `}</div>
  ${validate_component(Menu, "Menu").$$render($$result, Object.assign({
          class: classMap({
            [menu$class]: true,
            "smui-autocomplete__menu": true
          })
        }, { managed: true }, { open: menuOpen }, { anchor: menu$anchor }, { anchorCorner: menu$anchorCorner }, prefixFilter($$restProps, "menu$"), { anchorElement: element }), {
          anchorElement: ($$value) => {
            element = $$value;
            $$settled = false;
          }
        }, {
          default: () => `${validate_component(List, "List").$$render($$result, Object.assign(prefixFilter($$restProps, "list$")), {}, {
            default: () => `${loading ? `${validate_component(Item, "Item").$$render($$result, { disabled: true }, {}, {
              default: () => `${slots.loading ? slots.loading({}) : `
            ${validate_component(Text, "Text").$$render($$result, {}, {}, { default: () => `Loading...` })}
          `}`
            })}` : `${error22 ? `${validate_component(Item, "Item").$$render($$result, { disabled: true }, {}, {
              default: () => `${slots.error ? slots.error({}) : `
            ${validate_component(Text, "Text").$$render($$result, {}, {}, {
                default: () => `Error while fetching suggestions.`
              })}
          `}`
            })}` : `${matches2.length ? each(matches2, (match, i) => `${validate_component(Item, "Item").$$render($$result, {
              disabled: getOptionDisabled(match),
              selected: match === value
            }, {}, {
              default: () => `${slots.match ? slots.match({ match }) : `
              ${validate_component(Text, "Text").$$render($$result, {}, {}, {
                default: () => `${escape(getOptionLabel(match))}`
              })}
            `}
          `
            })}`) : `${validate_component(Item, "Item").$$render($$result, { disabled: noMatchesActionDisabled }, {}, {
              default: () => `${slots["no-matches"] ? slots["no-matches"]({}) : `
              ${validate_component(Text, "Text").$$render($$result, {}, {}, { default: () => `No matches found.` })}
            `}
          `
            })}`}`}`}`
          })}`
        })}
</div>`;
      } while (!$$settled);
      return $$rendered;
    });
    ClassDropdownMenu = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let filteredClasses;
      let $user, $$unsubscribe_user;
      $$unsubscribe_user = subscribe(user, (value) => $user = value);
      let { nameOfClass } = $$props;
      let { descriptionOfClass } = $$props;
      let anchor;
      let allClasses = [];
      let valueStandard = "";
      let menu;
      async function join({ mitClass }) {
        console.log("join mitClass =", mitClass);
        for (const userClass of $user.enrolledClasses) {
          if (userClass.id === mitClass.id) {
            alert(`You are already in ${mitClass.name}`);
            return;
          }
        }
        const db2 = Oa();
        _h(va(db2, `users/${$user.uid}`), {
          enrolledClasses: Ph(mitClass),
          mostRecentClassID: mitClass.id
        });
        _h(va(db2, `classes/${mitClass.id}`), { numOfMembers: Vh(1) });
        goto(`/${mitClass.id}/${mitClass.id}`);
      }
      if ($$props.nameOfClass === void 0 && $$bindings.nameOfClass && nameOfClass !== void 0)
        $$bindings.nameOfClass(nameOfClass);
      if ($$props.descriptionOfClass === void 0 && $$bindings.descriptionOfClass && descriptionOfClass !== void 0)
        $$bindings.descriptionOfClass(descriptionOfClass);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          if (valueStandard) {
            join({ mitClass: valueStandard });
          }
        }
        filteredClasses = allClasses;
        $$rendered = `<div${add_attribute("this", anchor, 0)}><div style="${"display: flex; align-items: center;"}"><div><h1 class="${"my-truncated-text"}" style="${"width: 150px; font-family: Roboto, sans-serif; font-weight: 400; margin-left: 6px; margin-top: 5px; margin-bottom: 0px; font-size: 2.0rem"}">${escape(nameOfClass)}</h1>
      <div class="${"my-truncated-text"}" style="${"width: 150px; font-family: Roboto, sans-serif; font-size: 0.875rem; color: rgba(0,0,0,.6); margin-left: " + escape(6 + 2) + "px; margin-bottom: 12px"}">${escape(descriptionOfClass)}</div></div>
    
    ${validate_component(Icon, "Icon").$$render($$result, { class: "material-icons" }, {}, { default: () => `arrow_drop_down` })}</div>

  
  
  ${validate_component(Menu, "Menu").$$render($$result, {
          anchor: false,
          anchorCorner: "BOTTOM_LEFT",
          style: "left: 70px; top: 5px; width: 240px; overflow: visible;",
          this: menu,
          anchorElement: anchor
        }, {
          this: ($$value) => {
            menu = $$value;
            $$settled = false;
          },
          anchorElement: ($$value) => {
            anchor = $$value;
            $$settled = false;
          }
        }, {
          default: () => `${validate_component(List, "List").$$render($$result, {}, {}, {
            default: () => `${$user.enrolledClasses ? `${each($user.enrolledClasses, (mitClass) => `${mitClass.name !== nameOfClass ? `${validate_component(Item, "Item").$$render($$result, {}, {}, {
              default: () => `<div class="${"my-truncated-text"}">${escape(mitClass.name)} (${escape(mitClass.description)})
              </div>
            `
            })}` : ``}`)}` : ``}

      <div style="${"margin-left: 12px; margin-bottom: 4px; margin-top: 16px;"}">${allClasses.length > 0 ? `${validate_component(Autocomplete, "Autocomplete").$$render($$result, {
              options: filteredClasses,
              getOptionLabel: (option) => option ? `${option.name} (${option.description})` : "",
              textfield$variant: "outlined",
              label: "Search class",
              menu$style: "max-height: 226px;",
              value: valueStandard
            }, {
              value: ($$value) => {
                valueStandard = $$value;
                $$settled = false;
              }
            }, {})}
          
          ` : ``}</div>`
          })}`
        })}</div>
 
`;
      } while (!$$settled);
      $$unsubscribe_user();
      return $$rendered;
    });
    cssClasses2 = {
      ANIMATE: "mdc-drawer--animate",
      CLOSING: "mdc-drawer--closing",
      DISMISSIBLE: "mdc-drawer--dismissible",
      MODAL: "mdc-drawer--modal",
      OPEN: "mdc-drawer--open",
      OPENING: "mdc-drawer--opening",
      ROOT: "mdc-drawer"
    };
    strings2 = {
      APP_CONTENT_SELECTOR: ".mdc-drawer-app-content",
      CLOSE_EVENT: "MDCDrawer:closed",
      OPEN_EVENT: "MDCDrawer:opened",
      SCRIM_SELECTOR: ".mdc-drawer-scrim",
      LIST_SELECTOR: ".mdc-list,.mdc-deprecated-list",
      LIST_ITEM_ACTIVATED_SELECTOR: ".mdc-list-item--activated,.mdc-deprecated-list-item--activated"
    };
    MDCDismissibleDrawerFoundation = function(_super) {
      __extends(MDCDismissibleDrawerFoundation2, _super);
      function MDCDismissibleDrawerFoundation2(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCDismissibleDrawerFoundation2.defaultAdapter), adapter)) || this;
        _this.animationFrame = 0;
        _this.animationTimer = 0;
        return _this;
      }
      Object.defineProperty(MDCDismissibleDrawerFoundation2, "strings", {
        get: function() {
          return strings2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCDismissibleDrawerFoundation2, "cssClasses", {
        get: function() {
          return cssClasses2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCDismissibleDrawerFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            hasClass: function() {
              return false;
            },
            elementHasClass: function() {
              return false;
            },
            notifyClose: function() {
              return void 0;
            },
            notifyOpen: function() {
              return void 0;
            },
            saveFocus: function() {
              return void 0;
            },
            restoreFocus: function() {
              return void 0;
            },
            focusActiveNavigationItem: function() {
              return void 0;
            },
            trapFocus: function() {
              return void 0;
            },
            releaseFocus: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCDismissibleDrawerFoundation2.prototype.destroy = function() {
        if (this.animationFrame) {
          cancelAnimationFrame(this.animationFrame);
        }
        if (this.animationTimer) {
          clearTimeout(this.animationTimer);
        }
      };
      MDCDismissibleDrawerFoundation2.prototype.open = function() {
        var _this = this;
        if (this.isOpen() || this.isOpening() || this.isClosing()) {
          return;
        }
        this.adapter.addClass(cssClasses2.OPEN);
        this.adapter.addClass(cssClasses2.ANIMATE);
        this.runNextAnimationFrame(function() {
          _this.adapter.addClass(cssClasses2.OPENING);
        });
        this.adapter.saveFocus();
      };
      MDCDismissibleDrawerFoundation2.prototype.close = function() {
        if (!this.isOpen() || this.isOpening() || this.isClosing()) {
          return;
        }
        this.adapter.addClass(cssClasses2.CLOSING);
      };
      MDCDismissibleDrawerFoundation2.prototype.isOpen = function() {
        return this.adapter.hasClass(cssClasses2.OPEN);
      };
      MDCDismissibleDrawerFoundation2.prototype.isOpening = function() {
        return this.adapter.hasClass(cssClasses2.OPENING) || this.adapter.hasClass(cssClasses2.ANIMATE);
      };
      MDCDismissibleDrawerFoundation2.prototype.isClosing = function() {
        return this.adapter.hasClass(cssClasses2.CLOSING);
      };
      MDCDismissibleDrawerFoundation2.prototype.handleKeydown = function(evt) {
        var keyCode = evt.keyCode, key = evt.key;
        var isEscape = key === "Escape" || keyCode === 27;
        if (isEscape) {
          this.close();
        }
      };
      MDCDismissibleDrawerFoundation2.prototype.handleTransitionEnd = function(evt) {
        var OPENING = cssClasses2.OPENING, CLOSING = cssClasses2.CLOSING, OPEN = cssClasses2.OPEN, ANIMATE = cssClasses2.ANIMATE, ROOT = cssClasses2.ROOT;
        var isRootElement = this.isElement(evt.target) && this.adapter.elementHasClass(evt.target, ROOT);
        if (!isRootElement) {
          return;
        }
        if (this.isClosing()) {
          this.adapter.removeClass(OPEN);
          this.closed();
          this.adapter.restoreFocus();
          this.adapter.notifyClose();
        } else {
          this.adapter.focusActiveNavigationItem();
          this.opened();
          this.adapter.notifyOpen();
        }
        this.adapter.removeClass(ANIMATE);
        this.adapter.removeClass(OPENING);
        this.adapter.removeClass(CLOSING);
      };
      MDCDismissibleDrawerFoundation2.prototype.opened = function() {
      };
      MDCDismissibleDrawerFoundation2.prototype.closed = function() {
      };
      MDCDismissibleDrawerFoundation2.prototype.runNextAnimationFrame = function(callback) {
        var _this = this;
        cancelAnimationFrame(this.animationFrame);
        this.animationFrame = requestAnimationFrame(function() {
          _this.animationFrame = 0;
          clearTimeout(_this.animationTimer);
          _this.animationTimer = setTimeout(callback, 0);
        });
      };
      MDCDismissibleDrawerFoundation2.prototype.isElement = function(element) {
        return Boolean(element.classList);
      };
      return MDCDismissibleDrawerFoundation2;
    }(MDCFoundation);
    MDCModalDrawerFoundation = function(_super) {
      __extends(MDCModalDrawerFoundation2, _super);
      function MDCModalDrawerFoundation2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      MDCModalDrawerFoundation2.prototype.handleScrimClick = function() {
        this.close();
      };
      MDCModalDrawerFoundation2.prototype.opened = function() {
        this.adapter.trapFocus();
      };
      MDCModalDrawerFoundation2.prototype.closed = function() {
        this.adapter.releaseFocus();
      };
      return MDCModalDrawerFoundation2;
    }(MDCDismissibleDrawerFoundation);
    Drawer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "class", "variant", "open", "fixed", "setOpen", "isOpen", "getElement"]);
      forwardEventsBuilder(get_current_component());
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { variant = void 0 } = $$props;
      let { open = false } = $$props;
      let { fixed = true } = $$props;
      let element;
      let instance2 = void 0;
      let internalClasses = {};
      let previousFocus = null;
      let focusTrap;
      let scrim = false;
      setContext("SMUI:list:nav", true);
      setContext("SMUI:list:item:nav", true);
      setContext("SMUI:list:wrapFocus", true);
      let oldVariant = variant;
      onDestroy(() => {
        instance2 && instance2.destroy();
        scrim && scrim.removeEventListener("SMUIDrawerScrim:click", handleScrimClick);
      });
      function getInstance() {
        var _a2, _b;
        if (scrim) {
          scrim.removeEventListener("SMUIDrawerScrim:click", handleScrimClick);
        }
        if (variant === "modal") {
          scrim = (_b = (_a2 = element.parentNode) === null || _a2 === void 0 ? void 0 : _a2.querySelector(".mdc-drawer-scrim")) !== null && _b !== void 0 ? _b : false;
          if (scrim) {
            scrim.addEventListener("SMUIDrawerScrim:click", handleScrimClick);
          }
        }
        const Foundation = variant === "dismissible" ? MDCDismissibleDrawerFoundation : variant === "modal" ? MDCModalDrawerFoundation : void 0;
        return Foundation ? new Foundation({
          addClass,
          removeClass,
          hasClass,
          elementHasClass: (element2, className2) => element2.classList.contains(className2),
          saveFocus: () => previousFocus = document.activeElement,
          restoreFocus: () => {
            if (previousFocus && "focus" in previousFocus && element.contains(document.activeElement)) {
              previousFocus.focus();
            }
          },
          focusActiveNavigationItem: () => {
            const activeNavItemEl = element.querySelector(".mdc-list-item--activated,.mdc-deprecated-list-item--activated");
            if (activeNavItemEl) {
              activeNavItemEl.focus();
            }
          },
          notifyClose: () => {
            open = false;
            dispatch(element, "SMUIDrawer:closed", void 0, void 0, true);
          },
          notifyOpen: () => {
            open = true;
            dispatch(element, "SMUIDrawer:opened", void 0, void 0, true);
          },
          trapFocus: () => focusTrap.trapFocus(),
          releaseFocus: () => focusTrap.releaseFocus()
        }) : void 0;
      }
      function hasClass(className2) {
        return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
      }
      function addClass(className2) {
        if (!internalClasses[className2]) {
          internalClasses[className2] = true;
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          internalClasses[className2] = false;
        }
      }
      function handleScrimClick() {
        instance2 && "handleScrimClick" in instance2 && instance2.handleScrimClick();
      }
      function setOpen(value) {
        open = value;
      }
      function isOpen() {
        return open;
      }
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.variant === void 0 && $$bindings.variant && variant !== void 0)
        $$bindings.variant(variant);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      if ($$props.fixed === void 0 && $$bindings.fixed && fixed !== void 0)
        $$bindings.fixed(fixed);
      if ($$props.setOpen === void 0 && $$bindings.setOpen && setOpen !== void 0)
        $$bindings.setOpen(setOpen);
      if ($$props.isOpen === void 0 && $$bindings.isOpen && isOpen !== void 0)
        $$bindings.isOpen(isOpen);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      {
        if (oldVariant !== variant) {
          oldVariant = variant;
          instance2 && instance2.destroy();
          internalClasses = {};
          instance2 = getInstance();
          instance2 && instance2.init();
        }
      }
      {
        if (instance2 && instance2.isOpen() !== open) {
          if (open) {
            instance2.open();
          } else {
            instance2.close();
          }
        }
      }
      return `<aside${spread([
        {
          class: escape_attribute_value(classMap({
            [className]: true,
            "mdc-drawer": true,
            "mdc-drawer--dismissible": variant === "dismissible",
            "mdc-drawer--modal": variant === "modal",
            "smui-drawer__absolute": variant === "modal" && !fixed,
            ...internalClasses
          }))
        },
        escape_object($$restProps)
      ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</aside>`;
    });
    AppContent = classAdderBuilder({
      class: "mdc-drawer-app-content",
      component: Div
    });
    Content = classAdderBuilder({
      class: "mdc-drawer__content",
      component: Div
    });
    classAdderBuilder({
      class: "mdc-drawer__header",
      component: Div
    });
    classAdderBuilder({
      class: "mdc-drawer__title",
      component: H1
    });
    classAdderBuilder({
      class: "mdc-drawer__subtitle",
      component: H2
    });
    classAdderBuilder({
      class: "smui-card__content",
      component: Div
    });
    classAdderBuilder({
      class: "mdc-card__media-content",
      component: Div
    });
    classAdderBuilder({
      class: "mdc-card__action-buttons",
      component: Div
    });
    classAdderBuilder({
      class: "mdc-card__action-icons",
      component: Div
    });
    css$1 = {
      code: ".drawer-container.svelte-ek1cfd{height:100vh;position:relative;display:flex}.svelte-ek1cfd .app-content{flex:auto;overflow:auto;position:relative;flex-grow:1}.main-content.svelte-ek1cfd{overflow:auto;padding:16px;height:100%;box-sizing:border-box}.logo-image.svelte-ek1cfd:hover{cursor:pointer}",
      map: null
    };
    LeftDrawer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $user, $$unsubscribe_user;
      $$unsubscribe_user = subscribe(user, (value) => $user = value);
      let { nameOfClass } = $$props;
      let { descriptionOfClass } = $$props;
      if ($$props.nameOfClass === void 0 && $$bindings.nameOfClass && nameOfClass !== void 0)
        $$bindings.nameOfClass(nameOfClass);
      if ($$props.descriptionOfClass === void 0 && $$bindings.descriptionOfClass && descriptionOfClass !== void 0)
        $$bindings.descriptionOfClass(descriptionOfClass);
      $$result.css.add(css$1);
      $$unsubscribe_user();
      return `<div class="${"drawer-container svelte-ek1cfd"}">${validate_component(Drawer, "Drawer").$$render($$result, {
        style: "overflow-y: scroll; height: 100%;",
        class: "mdc-elevation--z" + 5
      }, {}, {
        default: () => `${validate_component(Content, "Content").$$render($$result, {}, {}, {
          default: () => `<div style="${"margin-bottom: 12px; padding-top: 2px; padding-bottom: 0; padding-left: 8px;"}" class="${"mdc-elevation--z" + escape(4) + " svelte-ek1cfd"}"><div style="${"display: flex; align-items: center"}" class="${"svelte-ek1cfd"}"><img src="${"/logo.png"}" width="${"60"}" height="${"54"}" alt="${"web-logo"}" class="${"logo-image svelte-ek1cfd"}">
          <div class="${"svelte-ek1cfd"}">${$user.uid ? `${validate_component(ClassDropdownMenu, "ClassDropdownMenu").$$render($$result, { nameOfClass, descriptionOfClass }, {}, {})}` : `<div style="${"font-family: Roboto, sans-serif; font-weight: 400; margin-left: 6px; margin-top: 5px; margin-bottom: 0px; font-size: 2.0rem"}" class="${"svelte-ek1cfd"}">${escape(nameOfClass)}</div>
              <div style="${"font-family: Roboto,sans-serif; font-size: 0.875rem; color: rgba(0,0,0,.6); margin-left: 8px; margin-bottom: 12px"}" class="${"svelte-ek1cfd"}">${escape(descriptionOfClass)}</div>`}</div></div></div>
      ${validate_component(List, "List").$$render($$result, {}, {}, {
            default: () => `${slots.default ? slots.default({}) : `

        `}`
          })}`
        })}`
      })}
 
  ${validate_component(AppContent, "AppContent").$$render($$result, { class: "app-content" }, {}, {
        default: () => `<main class="${"main-content svelte-ek1cfd"}" id="${"main-content"}" style="${"padding: 0"}"></main>`
      })}
</div>`;
    });
    safeBuffer = { exports: {} };
    (function(module2, exports) {
      var buffer = import_buffer.default;
      var Buffer2 = buffer.Buffer;
      function copyProps(src2, dst) {
        for (var key in src2) {
          dst[key] = src2[key];
        }
      }
      if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
        module2.exports = buffer;
      } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer2(arg, encodingOrOffset, length);
      }
      copyProps(Buffer2, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer2(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer2(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer2(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    })(safeBuffer, safeBuffer.exports);
    events2 = { exports: {} };
    R2 = typeof Reflect === "object" ? Reflect : null;
    ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    if (R2 && typeof R2.ownKeys === "function") {
      ReflectOwnKeys = R2.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    events2.exports = EventEmitter$1;
    events2.exports.once = once2;
    EventEmitter$1.EventEmitter = EventEmitter$1;
    EventEmitter$1.prototype._events = void 0;
    EventEmitter$1.prototype._eventsCount = 0;
    EventEmitter$1.prototype._maxListeners = void 0;
    defaultMaxListeners = 10;
    Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter$1.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter$1.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events22 = this._events;
      if (events22 !== void 0)
        doError = doError && events22.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events22[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners2 = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners2[i], this, args);
      }
      return true;
    };
    EventEmitter$1.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
    EventEmitter$1.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    EventEmitter$1.prototype.once = function once(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter$1.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter$1.prototype.removeListener = function removeListener(type, listener) {
      var list, events22, position, i, originalListener;
      checkListener(listener);
      events22 = this._events;
      if (events22 === void 0)
        return this;
      list = events22[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events22[type];
          if (events22.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events22[type] = list[0];
        if (events22.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
    EventEmitter$1.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners2, events22, i;
      events22 = this._events;
      if (events22 === void 0)
        return this;
      if (events22.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events22[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events22[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events22);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events22[type];
      if (typeof listeners2 === "function") {
        this.removeListener(type, listeners2);
      } else if (listeners2 !== void 0) {
        for (i = listeners2.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners2[i]);
        }
      }
      return this;
    };
    EventEmitter$1.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter$1.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter$1.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter$1.prototype.listenerCount = listenerCount;
    EventEmitter$1.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    streams$1 = {};
    Stream$3 = import_stream2.default.Stream;
    util$b = import_util2.default;
    IO = function(driver2) {
      this.readable = this.writable = true;
      this._paused = false;
      this._driver = driver2;
    };
    util$b.inherits(IO, Stream$3);
    IO.prototype.pause = function() {
      this._paused = true;
      this._driver.messages._paused = true;
    };
    IO.prototype.resume = function() {
      this._paused = false;
      this.emit("drain");
      var messages = this._driver.messages;
      messages._paused = false;
      messages.emit("drain");
    };
    IO.prototype.write = function(chunk) {
      if (!this.writable)
        return false;
      this._driver.parse(chunk);
      return !this._paused;
    };
    IO.prototype.end = function(chunk) {
      if (!this.writable)
        return;
      if (chunk !== void 0)
        this.write(chunk);
      this.writable = false;
      var messages = this._driver.messages;
      if (messages.readable) {
        messages.readable = messages.writable = false;
        messages.emit("end");
      }
    };
    IO.prototype.destroy = function() {
      this.end();
    };
    Messages = function(driver2) {
      this.readable = this.writable = true;
      this._paused = false;
      this._driver = driver2;
    };
    util$b.inherits(Messages, Stream$3);
    Messages.prototype.pause = function() {
      this._driver.io._paused = true;
    };
    Messages.prototype.resume = function() {
      this._driver.io._paused = false;
      this._driver.io.emit("drain");
    };
    Messages.prototype.write = function(message2) {
      if (!this.writable)
        return false;
      if (typeof message2 === "string")
        this._driver.text(message2);
      else
        this._driver.binary(message2);
      return !this._paused;
    };
    Messages.prototype.end = function(message2) {
      if (message2 !== void 0)
        this.write(message2);
    };
    Messages.prototype.destroy = function() {
    };
    streams$1.IO = IO;
    streams$1.Messages = Messages;
    Headers$3 = function() {
      this.clear();
    };
    Headers$3.prototype.ALLOWED_DUPLICATES = ["set-cookie", "set-cookie2", "warning", "www-authenticate"];
    Headers$3.prototype.clear = function() {
      this._sent = {};
      this._lines = [];
    };
    Headers$3.prototype.set = function(name22, value) {
      if (value === void 0)
        return;
      name22 = this._strip(name22);
      value = this._strip(value);
      var key = name22.toLowerCase();
      if (!this._sent.hasOwnProperty(key) || this.ALLOWED_DUPLICATES.indexOf(key) >= 0) {
        this._sent[key] = true;
        this._lines.push(name22 + ": " + value + "\r\n");
      }
    };
    Headers$3.prototype.toString = function() {
      return this._lines.join("");
    };
    Headers$3.prototype._strip = function(string) {
      return string.toString().replace(/^ */, "").replace(/ *$/, "");
    };
    headers = Headers$3;
    Buffer$9 = safeBuffer.exports.Buffer;
    StreamReader = function() {
      this._queue = [];
      this._queueSize = 0;
      this._offset = 0;
    };
    StreamReader.prototype.put = function(buffer) {
      if (!buffer || buffer.length === 0)
        return;
      if (!Buffer$9.isBuffer(buffer))
        buffer = Buffer$9.from(buffer);
      this._queue.push(buffer);
      this._queueSize += buffer.length;
    };
    StreamReader.prototype.read = function(length) {
      if (length > this._queueSize)
        return null;
      if (length === 0)
        return Buffer$9.alloc(0);
      this._queueSize -= length;
      var queue = this._queue, remain = length, first = queue[0], buffers, buffer;
      if (first.length >= length) {
        if (first.length === length) {
          return queue.shift();
        } else {
          buffer = first.slice(0, length);
          queue[0] = first.slice(length);
          return buffer;
        }
      }
      for (var i = 0, n = queue.length; i < n; i++) {
        if (remain < queue[i].length)
          break;
        remain -= queue[i].length;
      }
      buffers = queue.splice(0, i);
      if (remain > 0 && queue.length > 0) {
        buffers.push(queue[0].slice(0, remain));
        queue[0] = queue[0].slice(remain);
      }
      return Buffer$9.concat(buffers, length);
    };
    StreamReader.prototype.eachByte = function(callback, context) {
      var buffer, n, index;
      while (this._queue.length > 0) {
        buffer = this._queue[0];
        n = buffer.length;
        while (this._offset < n) {
          index = this._offset;
          this._offset += 1;
          callback.call(context, buffer[index]);
        }
        this._offset = 0;
        this._queue.shift();
      }
    };
    stream_reader = StreamReader;
    Buffer$8 = safeBuffer.exports.Buffer;
    Emitter = events2.exports.EventEmitter;
    util$a = import_util2.default;
    streams = streams$1;
    Headers$2 = headers;
    Reader = stream_reader;
    Base$7 = function(request, url2, options2) {
      Emitter.call(this);
      Base$7.validateOptions(options2 || {}, ["maxLength", "masking", "requireMasking", "protocols"]);
      this._request = request;
      this._reader = new Reader();
      this._options = options2 || {};
      this._maxLength = this._options.maxLength || this.MAX_LENGTH;
      this._headers = new Headers$2();
      this.__queue = [];
      this.readyState = 0;
      this.url = url2;
      this.io = new streams.IO(this);
      this.messages = new streams.Messages(this);
      this._bindEventListeners();
    };
    util$a.inherits(Base$7, Emitter);
    Base$7.isWebSocket = function(request) {
      var connection = request.headers.connection || "", upgrade = request.headers.upgrade || "";
      return request.method === "GET" && connection.toLowerCase().split(/ *, */).indexOf("upgrade") >= 0 && upgrade.toLowerCase() === "websocket";
    };
    Base$7.validateOptions = function(options2, validKeys) {
      for (var key in options2) {
        if (validKeys.indexOf(key) < 0)
          throw new Error("Unrecognized option: " + key);
      }
    };
    instance$b = {
      MAX_LENGTH: 67108863,
      STATES: ["connecting", "open", "closing", "closed"],
      _bindEventListeners: function() {
        var self2 = this;
        this.messages.on("error", function() {
        });
        this.on("message", function(event2) {
          var messages = self2.messages;
          if (messages.readable)
            messages.emit("data", event2.data);
        });
        this.on("error", function(error22) {
          var messages = self2.messages;
          if (messages.readable)
            messages.emit("error", error22);
        });
        this.on("close", function() {
          var messages = self2.messages;
          if (!messages.readable)
            return;
          messages.readable = messages.writable = false;
          messages.emit("end");
        });
      },
      getState: function() {
        return this.STATES[this.readyState] || null;
      },
      addExtension: function(extension) {
        return false;
      },
      setHeader: function(name22, value) {
        if (this.readyState > 0)
          return false;
        this._headers.set(name22, value);
        return true;
      },
      start: function() {
        if (this.readyState !== 0)
          return false;
        if (!Base$7.isWebSocket(this._request))
          return this._failHandshake(new Error("Not a WebSocket request"));
        var response;
        try {
          response = this._handshakeResponse();
        } catch (error22) {
          return this._failHandshake(error22);
        }
        this._write(response);
        if (this._stage !== -1)
          this._open();
        return true;
      },
      _failHandshake: function(error22) {
        var headers2 = new Headers$2();
        headers2.set("Content-Type", "text/plain");
        headers2.set("Content-Length", Buffer$8.byteLength(error22.message, "utf8"));
        headers2 = ["HTTP/1.1 400 Bad Request", headers2.toString(), error22.message];
        this._write(Buffer$8.from(headers2.join("\r\n"), "utf8"));
        this._fail("protocol_error", error22.message);
        return false;
      },
      text: function(message2) {
        return this.frame(message2);
      },
      binary: function(message2) {
        return false;
      },
      ping: function() {
        return false;
      },
      pong: function() {
        return false;
      },
      close: function(reason, code) {
        if (this.readyState !== 1)
          return false;
        this.readyState = 3;
        this.emit("close", new Base$7.CloseEvent(null, null));
        return true;
      },
      _open: function() {
        this.readyState = 1;
        this.__queue.forEach(function(args) {
          this.frame.apply(this, args);
        }, this);
        this.__queue = [];
        this.emit("open", new Base$7.OpenEvent());
      },
      _queue: function(message2) {
        this.__queue.push(message2);
        return true;
      },
      _write: function(chunk) {
        var io2 = this.io;
        if (io2.readable)
          io2.emit("data", chunk);
      },
      _fail: function(type, message2) {
        this.readyState = 2;
        this.emit("error", new Error(message2));
        this.close();
      }
    };
    for (key$b in instance$b)
      Base$7.prototype[key$b] = instance$b[key$b];
    Base$7.ConnectEvent = function() {
    };
    Base$7.OpenEvent = function() {
    };
    Base$7.CloseEvent = function(code, reason) {
      this.code = code;
      this.reason = reason;
    };
    Base$7.MessageEvent = function(data) {
      this.data = data;
    };
    Base$7.PingEvent = function(data) {
      this.data = data;
    };
    Base$7.PongEvent = function(data) {
      this.data = data;
    };
    base = Base$7;
    httpParser = {};
    assert2 = import_assert.default;
    httpParser.HTTPParser = HTTPParser;
    HTTPParser.prototype.initialize = function(type, async_resource) {
      assert2.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);
      this.type = type;
      this.state = type + "_LINE";
      this.info = {
        headers: [],
        upgrade: false
      };
      this.trailers = [];
      this.line = "";
      this.isChunked = false;
      this.connection = "";
      this.headerSize = 0;
      this.body_bytes = null;
      this.isUserCall = false;
      this.hadError = false;
    };
    HTTPParser.encoding = "ascii";
    HTTPParser.maxHeaderSize = 80 * 1024;
    HTTPParser.REQUEST = "REQUEST";
    HTTPParser.RESPONSE = "RESPONSE";
    kOnHeaders = HTTPParser.kOnHeaders = 1;
    kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;
    kOnBody = HTTPParser.kOnBody = 3;
    kOnMessageComplete = HTTPParser.kOnMessageComplete = 4;
    HTTPParser.prototype[kOnHeaders] = HTTPParser.prototype[kOnHeadersComplete] = HTTPParser.prototype[kOnBody] = HTTPParser.prototype[kOnMessageComplete] = function() {
    };
    compatMode0_12 = true;
    Object.defineProperty(HTTPParser, "kOnExecute", {
      get: function() {
        compatMode0_12 = false;
        return 99;
      }
    });
    methods = httpParser.methods = HTTPParser.methods = [
      "DELETE",
      "GET",
      "HEAD",
      "POST",
      "PUT",
      "CONNECT",
      "OPTIONS",
      "TRACE",
      "COPY",
      "LOCK",
      "MKCOL",
      "MOVE",
      "PROPFIND",
      "PROPPATCH",
      "SEARCH",
      "UNLOCK",
      "BIND",
      "REBIND",
      "UNBIND",
      "ACL",
      "REPORT",
      "MKACTIVITY",
      "CHECKOUT",
      "MERGE",
      "M-SEARCH",
      "NOTIFY",
      "SUBSCRIBE",
      "UNSUBSCRIBE",
      "PATCH",
      "PURGE",
      "MKCALENDAR",
      "LINK",
      "UNLINK"
    ];
    method_connect = methods.indexOf("CONNECT");
    HTTPParser.prototype.reinitialize = HTTPParser;
    HTTPParser.prototype.close = HTTPParser.prototype.pause = HTTPParser.prototype.resume = HTTPParser.prototype.free = function() {
    };
    HTTPParser.prototype._compatMode0_11 = false;
    HTTPParser.prototype.getAsyncId = function() {
      return 0;
    };
    headerState = {
      REQUEST_LINE: true,
      RESPONSE_LINE: true,
      HEADER: true
    };
    HTTPParser.prototype.execute = function(chunk, start2, length) {
      if (!(this instanceof HTTPParser)) {
        throw new TypeError("not a HTTPParser");
      }
      start2 = start2 || 0;
      length = typeof length === "number" ? length : chunk.length;
      this.chunk = chunk;
      this.offset = start2;
      var end = this.end = start2 + length;
      try {
        while (this.offset < end) {
          if (this[this.state]()) {
            break;
          }
        }
      } catch (err) {
        if (this.isUserCall) {
          throw err;
        }
        this.hadError = true;
        return err;
      }
      this.chunk = null;
      length = this.offset - start2;
      if (headerState[this.state]) {
        this.headerSize += length;
        if (this.headerSize > HTTPParser.maxHeaderSize) {
          return new Error("max header size exceeded");
        }
      }
      return length;
    };
    stateFinishAllowed = {
      REQUEST_LINE: true,
      RESPONSE_LINE: true,
      BODY_RAW: true
    };
    HTTPParser.prototype.finish = function() {
      if (this.hadError) {
        return;
      }
      if (!stateFinishAllowed[this.state]) {
        return new Error("invalid state for EOF");
      }
      if (this.state === "BODY_RAW") {
        this.userCall()(this[kOnMessageComplete]());
      }
    };
    HTTPParser.prototype.consume = HTTPParser.prototype.unconsume = HTTPParser.prototype.getCurrentBuffer = function() {
    };
    HTTPParser.prototype.userCall = function() {
      this.isUserCall = true;
      var self2 = this;
      return function(ret) {
        self2.isUserCall = false;
        return ret;
      };
    };
    HTTPParser.prototype.nextRequest = function() {
      this.userCall()(this[kOnMessageComplete]());
      this.reinitialize(this.type);
    };
    HTTPParser.prototype.consumeLine = function() {
      var end = this.end, chunk = this.chunk;
      for (var i = this.offset; i < end; i++) {
        if (chunk[i] === 10) {
          var line = this.line + chunk.toString(HTTPParser.encoding, this.offset, i);
          if (line.charAt(line.length - 1) === "\r") {
            line = line.substr(0, line.length - 1);
          }
          this.line = "";
          this.offset = i + 1;
          return line;
        }
      }
      this.line += chunk.toString(HTTPParser.encoding, this.offset, this.end);
      this.offset = this.end;
    };
    headerExp = /^([^: \t]+):[ \t]*((?:.*[^ \t])|)/;
    headerContinueExp = /^[ \t]+(.*[^ \t])/;
    HTTPParser.prototype.parseHeader = function(line, headers2) {
      if (line.indexOf("\r") !== -1) {
        throw parseErrorCode("HPE_LF_EXPECTED");
      }
      var match = headerExp.exec(line);
      var k2 = match && match[1];
      if (k2) {
        headers2.push(k2);
        headers2.push(match[2]);
      } else {
        var matchContinue = headerContinueExp.exec(line);
        if (matchContinue && headers2.length) {
          if (headers2[headers2.length - 1]) {
            headers2[headers2.length - 1] += " ";
          }
          headers2[headers2.length - 1] += matchContinue[1];
        }
      }
    };
    requestExp = /^([A-Z-]+) ([^ ]+) HTTP\/(\d)\.(\d)$/;
    HTTPParser.prototype.REQUEST_LINE = function() {
      var line = this.consumeLine();
      if (!line) {
        return;
      }
      var match = requestExp.exec(line);
      if (match === null) {
        throw parseErrorCode("HPE_INVALID_CONSTANT");
      }
      this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);
      if (this.info.method === -1) {
        throw new Error("invalid request method");
      }
      this.info.url = match[2];
      this.info.versionMajor = +match[3];
      this.info.versionMinor = +match[4];
      this.body_bytes = 0;
      this.state = "HEADER";
    };
    responseExp = /^HTTP\/(\d)\.(\d) (\d{3}) ?(.*)$/;
    HTTPParser.prototype.RESPONSE_LINE = function() {
      var line = this.consumeLine();
      if (!line) {
        return;
      }
      var match = responseExp.exec(line);
      if (match === null) {
        throw parseErrorCode("HPE_INVALID_CONSTANT");
      }
      this.info.versionMajor = +match[1];
      this.info.versionMinor = +match[2];
      var statusCode = this.info.statusCode = +match[3];
      this.info.statusMessage = match[4];
      if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {
        this.body_bytes = 0;
      }
      this.state = "HEADER";
    };
    HTTPParser.prototype.shouldKeepAlive = function() {
      if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {
        if (this.connection.indexOf("close") !== -1) {
          return false;
        }
      } else if (this.connection.indexOf("keep-alive") === -1) {
        return false;
      }
      if (this.body_bytes !== null || this.isChunked) {
        return true;
      }
      return false;
    };
    HTTPParser.prototype.HEADER = function() {
      var line = this.consumeLine();
      if (line === void 0) {
        return;
      }
      var info = this.info;
      if (line) {
        this.parseHeader(line, info.headers);
      } else {
        var headers2 = info.headers;
        var hasContentLength = false;
        var currentContentLengthValue;
        var hasUpgradeHeader = false;
        for (var i = 0; i < headers2.length; i += 2) {
          switch (headers2[i].toLowerCase()) {
            case "transfer-encoding":
              this.isChunked = headers2[i + 1].toLowerCase() === "chunked";
              break;
            case "content-length":
              currentContentLengthValue = +headers2[i + 1];
              if (hasContentLength) {
                if (currentContentLengthValue !== this.body_bytes) {
                  throw parseErrorCode("HPE_UNEXPECTED_CONTENT_LENGTH");
                }
              } else {
                hasContentLength = true;
                this.body_bytes = currentContentLengthValue;
              }
              break;
            case "connection":
              this.connection += headers2[i + 1].toLowerCase();
              break;
            case "upgrade":
              hasUpgradeHeader = true;
              break;
          }
        }
        if (this.isChunked && hasContentLength) {
          hasContentLength = false;
          this.body_bytes = null;
        }
        if (hasUpgradeHeader && this.connection.indexOf("upgrade") != -1) {
          info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;
        } else {
          info.upgrade = info.method === method_connect;
        }
        if (this.isChunked && info.upgrade) {
          this.isChunked = false;
        }
        info.shouldKeepAlive = this.shouldKeepAlive();
        var skipBody;
        if (compatMode0_12) {
          skipBody = this.userCall()(this[kOnHeadersComplete](info));
        } else {
          skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor, info.versionMinor, info.headers, info.method, info.url, info.statusCode, info.statusMessage, info.upgrade, info.shouldKeepAlive));
        }
        if (skipBody === 2) {
          this.nextRequest();
          return true;
        } else if (this.isChunked && !skipBody) {
          this.state = "BODY_CHUNKHEAD";
        } else if (skipBody || this.body_bytes === 0) {
          this.nextRequest();
          return info.upgrade;
        } else if (this.body_bytes === null) {
          this.state = "BODY_RAW";
        } else {
          this.state = "BODY_SIZED";
        }
      }
    };
    HTTPParser.prototype.BODY_CHUNKHEAD = function() {
      var line = this.consumeLine();
      if (line === void 0) {
        return;
      }
      this.body_bytes = parseInt(line, 16);
      if (!this.body_bytes) {
        this.state = "BODY_CHUNKTRAILERS";
      } else {
        this.state = "BODY_CHUNK";
      }
    };
    HTTPParser.prototype.BODY_CHUNK = function() {
      var length = Math.min(this.end - this.offset, this.body_bytes);
      this.userCall()(this[kOnBody](this.chunk, this.offset, length));
      this.offset += length;
      this.body_bytes -= length;
      if (!this.body_bytes) {
        this.state = "BODY_CHUNKEMPTYLINE";
      }
    };
    HTTPParser.prototype.BODY_CHUNKEMPTYLINE = function() {
      var line = this.consumeLine();
      if (line === void 0) {
        return;
      }
      assert2.equal(line, "");
      this.state = "BODY_CHUNKHEAD";
    };
    HTTPParser.prototype.BODY_CHUNKTRAILERS = function() {
      var line = this.consumeLine();
      if (line === void 0) {
        return;
      }
      if (line) {
        this.parseHeader(line, this.trailers);
      } else {
        if (this.trailers.length) {
          this.userCall()(this[kOnHeaders](this.trailers, ""));
        }
        this.nextRequest();
      }
    };
    HTTPParser.prototype.BODY_RAW = function() {
      var length = this.end - this.offset;
      this.userCall()(this[kOnBody](this.chunk, this.offset, length));
      this.offset = this.end;
    };
    HTTPParser.prototype.BODY_SIZED = function() {
      var length = Math.min(this.end - this.offset, this.body_bytes);
      this.userCall()(this[kOnBody](this.chunk, this.offset, length));
      this.offset += length;
      this.body_bytes -= length;
      if (!this.body_bytes) {
        this.nextRequest();
      }
    };
    ["Headers", "HeadersComplete", "Body", "MessageComplete"].forEach(function(name22) {
      var k2 = HTTPParser["kOn" + name22];
      Object.defineProperty(HTTPParser.prototype, "on" + name22, {
        get: function() {
          return this[k2];
        },
        set: function(to2) {
          this._compatMode0_11 = true;
          method_connect = "CONNECT";
          return this[k2] = to2;
        }
      });
    });
    NodeHTTPParser = httpParser.HTTPParser;
    Buffer$7 = safeBuffer.exports.Buffer;
    TYPES = {
      request: NodeHTTPParser.REQUEST || "request",
      response: NodeHTTPParser.RESPONSE || "response"
    };
    HttpParser$3 = function(type) {
      this._type = type;
      this._parser = new NodeHTTPParser(TYPES[type]);
      this._complete = false;
      this.headers = {};
      var current = null, self2 = this;
      this._parser.onHeaderField = function(b, start2, length) {
        current = b.toString("utf8", start2, start2 + length).toLowerCase();
      };
      this._parser.onHeaderValue = function(b, start2, length) {
        var value = b.toString("utf8", start2, start2 + length);
        if (self2.headers.hasOwnProperty(current))
          self2.headers[current] += ", " + value;
        else
          self2.headers[current] = value;
      };
      this._parser.onHeadersComplete = this._parser[NodeHTTPParser.kOnHeadersComplete] = function(majorVersion, minorVersion, headers2, method, pathname, statusCode) {
        var info = arguments[0];
        if (typeof info === "object") {
          method = info.method;
          pathname = info.url;
          statusCode = info.statusCode;
          headers2 = info.headers;
        }
        self2.method = typeof method === "number" ? HttpParser$3.METHODS[method] : method;
        self2.statusCode = statusCode;
        self2.url = pathname;
        if (!headers2)
          return;
        for (var i = 0, n = headers2.length, key, value; i < n; i += 2) {
          key = headers2[i].toLowerCase();
          value = headers2[i + 1];
          if (self2.headers.hasOwnProperty(key))
            self2.headers[key] += ", " + value;
          else
            self2.headers[key] = value;
        }
        self2._complete = true;
      };
    };
    HttpParser$3.METHODS = {
      0: "DELETE",
      1: "GET",
      2: "HEAD",
      3: "POST",
      4: "PUT",
      5: "CONNECT",
      6: "OPTIONS",
      7: "TRACE",
      8: "COPY",
      9: "LOCK",
      10: "MKCOL",
      11: "MOVE",
      12: "PROPFIND",
      13: "PROPPATCH",
      14: "SEARCH",
      15: "UNLOCK",
      16: "BIND",
      17: "REBIND",
      18: "UNBIND",
      19: "ACL",
      20: "REPORT",
      21: "MKACTIVITY",
      22: "CHECKOUT",
      23: "MERGE",
      24: "M-SEARCH",
      25: "NOTIFY",
      26: "SUBSCRIBE",
      27: "UNSUBSCRIBE",
      28: "PATCH",
      29: "PURGE",
      30: "MKCALENDAR",
      31: "LINK",
      32: "UNLINK"
    };
    VERSION = process.version ? process.version.match(/[0-9]+/g).map(function(n) {
      return parseInt(n, 10);
    }) : [];
    if (VERSION[0] === 0 && VERSION[1] === 12) {
      HttpParser$3.METHODS[16] = "REPORT";
      HttpParser$3.METHODS[17] = "MKACTIVITY";
      HttpParser$3.METHODS[18] = "CHECKOUT";
      HttpParser$3.METHODS[19] = "MERGE";
      HttpParser$3.METHODS[20] = "M-SEARCH";
      HttpParser$3.METHODS[21] = "NOTIFY";
      HttpParser$3.METHODS[22] = "SUBSCRIBE";
      HttpParser$3.METHODS[23] = "UNSUBSCRIBE";
      HttpParser$3.METHODS[24] = "PATCH";
      HttpParser$3.METHODS[25] = "PURGE";
    }
    HttpParser$3.prototype.isComplete = function() {
      return this._complete;
    };
    HttpParser$3.prototype.parse = function(chunk) {
      var consumed = this._parser.execute(chunk, 0, chunk.length);
      if (typeof consumed !== "number") {
        this.error = consumed;
        this._complete = true;
        return;
      }
      if (this._complete)
        this.body = consumed < chunk.length ? chunk.slice(consumed) : Buffer$7.alloc(0);
    };
    http_parser = HttpParser$3;
    TOKEN = /([!#\$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+)/;
    NOTOKEN = /([^!#\$%&'\*\+\-\.\^_`\|~0-9A-Za-z])/g;
    QUOTED = /"((?:\\[\x00-\x7f]|[^\x00-\x08\x0a-\x1f\x7f"\\])*)"/;
    PARAM = new RegExp(TOKEN.source + "(?:=(?:" + TOKEN.source + "|" + QUOTED.source + "))?");
    EXT = new RegExp(TOKEN.source + "(?: *; *" + PARAM.source + ")*", "g");
    EXT_LIST = new RegExp("^" + EXT.source + "(?: *, *" + EXT.source + ")*$");
    NUMBER = /^-?(0|[1-9][0-9]*)(\.[0-9]+)?$/;
    hasOwnProperty = Object.prototype.hasOwnProperty;
    Parser$1 = {
      parseHeader: function(header) {
        var offers = new Offers();
        if (header === "" || header === void 0)
          return offers;
        if (!EXT_LIST.test(header))
          throw new SyntaxError("Invalid Sec-WebSocket-Extensions header: " + header);
        var values = header.match(EXT);
        values.forEach(function(value) {
          var params = value.match(new RegExp(PARAM.source, "g")), name22 = params.shift(), offer = {};
          params.forEach(function(param) {
            var args = param.match(PARAM), key = args[1], data;
            if (args[2] !== void 0) {
              data = args[2];
            } else if (args[3] !== void 0) {
              data = args[3].replace(/\\/g, "");
            } else {
              data = true;
            }
            if (NUMBER.test(data))
              data = parseFloat(data);
            if (hasOwnProperty.call(offer, key)) {
              offer[key] = [].concat(offer[key]);
              offer[key].push(data);
            } else {
              offer[key] = data;
            }
          }, this);
          offers.push(name22, offer);
        }, this);
        return offers;
      },
      serializeParams: function(name22, params) {
        var values = [];
        var print = function(key2, value) {
          if (value instanceof Array) {
            value.forEach(function(v2) {
              print(key2, v2);
            });
          } else if (value === true) {
            values.push(key2);
          } else if (typeof value === "number") {
            values.push(key2 + "=" + value);
          } else if (NOTOKEN.test(value)) {
            values.push(key2 + '="' + value.replace(/"/g, '\\"') + '"');
          } else {
            values.push(key2 + "=" + value);
          }
        };
        for (var key in params)
          print(key, params[key]);
        return [name22].concat(values).join("; ");
      }
    };
    Offers = function() {
      this._byName = {};
      this._inOrder = [];
    };
    Offers.prototype.push = function(name22, params) {
      if (!hasOwnProperty.call(this._byName, name22))
        this._byName[name22] = [];
      this._byName[name22].push(params);
      this._inOrder.push({ name: name22, params });
    };
    Offers.prototype.eachOffer = function(callback, context) {
      var list = this._inOrder;
      for (var i = 0, n = list.length; i < n; i++)
        callback.call(context, list[i].name, list[i].params);
    };
    Offers.prototype.byName = function(name22) {
      return this._byName[name22] || [];
    };
    Offers.prototype.toArray = function() {
      return this._inOrder.slice();
    };
    parser = Parser$1;
    RingBuffer$2 = function(bufferSize) {
      this._bufferSize = bufferSize;
      this.clear();
    };
    RingBuffer$2.prototype.clear = function() {
      this._buffer = new Array(this._bufferSize);
      this._ringOffset = 0;
      this._ringSize = this._bufferSize;
      this._head = 0;
      this._tail = 0;
      this.length = 0;
    };
    RingBuffer$2.prototype.push = function(value) {
      var expandBuffer = false, expandRing = false;
      if (this._ringSize < this._bufferSize) {
        expandBuffer = this._tail === 0;
      } else if (this._ringOffset === this._ringSize) {
        expandBuffer = true;
        expandRing = this._tail === 0;
      }
      if (expandBuffer) {
        this._tail = this._bufferSize;
        this._buffer = this._buffer.concat(new Array(this._bufferSize));
        this._bufferSize = this._buffer.length;
        if (expandRing)
          this._ringSize = this._bufferSize;
      }
      this._buffer[this._tail] = value;
      this.length += 1;
      if (this._tail < this._ringSize)
        this._ringOffset += 1;
      this._tail = (this._tail + 1) % this._bufferSize;
    };
    RingBuffer$2.prototype.peek = function() {
      if (this.length === 0)
        return void 0;
      return this._buffer[this._head];
    };
    RingBuffer$2.prototype.shift = function() {
      if (this.length === 0)
        return void 0;
      var value = this._buffer[this._head];
      this._buffer[this._head] = void 0;
      this.length -= 1;
      this._ringOffset -= 1;
      if (this._ringOffset === 0 && this.length > 0) {
        this._head = this._ringSize;
        this._ringOffset = this.length;
        this._ringSize = this._bufferSize;
      } else {
        this._head = (this._head + 1) % this._ringSize;
      }
      return value;
    };
    ring_buffer = RingBuffer$2;
    RingBuffer$1 = ring_buffer;
    Functor$1 = function(session, method) {
      this._session = session;
      this._method = method;
      this._queue = new RingBuffer$1(Functor$1.QUEUE_SIZE);
      this._stopped = false;
      this.pending = 0;
    };
    Functor$1.QUEUE_SIZE = 8;
    Functor$1.prototype.call = function(error22, message2, callback, context) {
      if (this._stopped)
        return;
      var record = { error: error22, message: message2, callback, context, done: false }, called = false, self2 = this;
      this._queue.push(record);
      if (record.error) {
        record.done = true;
        this._stop();
        return this._flushQueue();
      }
      var handler = function(err, msg) {
        if (!(called ^ (called = true)))
          return;
        if (err) {
          self2._stop();
          record.error = err;
          record.message = null;
        } else {
          record.message = msg;
        }
        record.done = true;
        self2._flushQueue();
      };
      try {
        this._session[this._method](message2, handler);
      } catch (err) {
        handler(err);
      }
    };
    Functor$1.prototype._stop = function() {
      this.pending = this._queue.length;
      this._stopped = true;
    };
    Functor$1.prototype._flushQueue = function() {
      var queue = this._queue, record;
      while (queue.length > 0 && queue.peek().done) {
        record = queue.shift();
        if (record.error) {
          this.pending = 0;
          queue.clear();
        } else {
          this.pending -= 1;
        }
        record.callback.call(record.context, record.error, record.message);
      }
    };
    functor = Functor$1;
    RingBuffer = ring_buffer;
    Pledge$2 = function() {
      this._complete = false;
      this._callbacks = new RingBuffer(Pledge$2.QUEUE_SIZE);
    };
    Pledge$2.QUEUE_SIZE = 4;
    Pledge$2.all = function(list) {
      var pledge2 = new Pledge$2(), pending = list.length, n = pending;
      if (pending === 0)
        pledge2.done();
      while (n--)
        list[n].then(function() {
          pending -= 1;
          if (pending === 0)
            pledge2.done();
        });
      return pledge2;
    };
    Pledge$2.prototype.then = function(callback) {
      if (this._complete)
        callback();
      else
        this._callbacks.push(callback);
    };
    Pledge$2.prototype.done = function() {
      this._complete = true;
      var callbacks = this._callbacks, callback;
      while (callback = callbacks.shift())
        callback();
    };
    pledge = Pledge$2;
    Functor = functor;
    Pledge$1 = pledge;
    Cell$1 = function(tuple) {
      this._ext = tuple[0];
      this._session = tuple[1];
      this._functors = {
        incoming: new Functor(this._session, "processIncomingMessage"),
        outgoing: new Functor(this._session, "processOutgoingMessage")
      };
    };
    Cell$1.prototype.pending = function(direction) {
      var functor2 = this._functors[direction];
      if (!functor2._stopped)
        functor2.pending += 1;
    };
    Cell$1.prototype.incoming = function(error22, message2, callback, context) {
      this._exec("incoming", error22, message2, callback, context);
    };
    Cell$1.prototype.outgoing = function(error22, message2, callback, context) {
      this._exec("outgoing", error22, message2, callback, context);
    };
    Cell$1.prototype.close = function() {
      this._closed = this._closed || new Pledge$1();
      this._doClose();
      return this._closed;
    };
    Cell$1.prototype._exec = function(direction, error22, message2, callback, context) {
      this._functors[direction].call(error22, message2, function(err, msg) {
        if (err)
          err.message = this._ext.name + ": " + err.message;
        callback.call(context, err, msg);
        this._doClose();
      }, this);
    };
    Cell$1.prototype._doClose = function() {
      var fin = this._functors.incoming, fout = this._functors.outgoing;
      if (!this._closed || fin.pending + fout.pending !== 0)
        return;
      if (this._session)
        this._session.close();
      this._session = null;
      this._closed.done();
    };
    cell = Cell$1;
    Cell = cell;
    Pledge = pledge;
    Pipeline$1 = function(sessions) {
      this._cells = sessions.map(function(session) {
        return new Cell(session);
      });
      this._stopped = { incoming: false, outgoing: false };
    };
    Pipeline$1.prototype.processIncomingMessage = function(message2, callback, context) {
      if (this._stopped.incoming)
        return;
      this._loop("incoming", this._cells.length - 1, -1, -1, message2, callback, context);
    };
    Pipeline$1.prototype.processOutgoingMessage = function(message2, callback, context) {
      if (this._stopped.outgoing)
        return;
      this._loop("outgoing", 0, this._cells.length, 1, message2, callback, context);
    };
    Pipeline$1.prototype.close = function(callback, context) {
      this._stopped = { incoming: true, outgoing: true };
      var closed = this._cells.map(function(a) {
        return a.close();
      });
      if (callback)
        Pledge.all(closed).then(function() {
          callback.call(context);
        });
    };
    Pipeline$1.prototype._loop = function(direction, start2, end, step, message2, callback, context) {
      var cells = this._cells, n = cells.length, self2 = this;
      while (n--)
        cells[n].pending(direction);
      var pipe = function(index, error22, msg) {
        if (index === end)
          return callback.call(context, error22, msg);
        cells[index][direction](error22, msg, function(err, m) {
          if (err)
            self2._stopped[direction] = true;
          pipe(index + step, err, m);
        });
      };
      pipe(start2, null, message2);
    };
    pipeline2 = Pipeline$1;
    Parser = parser;
    Pipeline = pipeline2;
    Extensions$1 = function() {
      this._rsv1 = this._rsv2 = this._rsv3 = null;
      this._byName = {};
      this._inOrder = [];
      this._sessions = [];
      this._index = {};
    };
    Extensions$1.MESSAGE_OPCODES = [1, 2];
    instance$a = {
      add: function(ext) {
        if (typeof ext.name !== "string")
          throw new TypeError("extension.name must be a string");
        if (ext.type !== "permessage")
          throw new TypeError('extension.type must be "permessage"');
        if (typeof ext.rsv1 !== "boolean")
          throw new TypeError("extension.rsv1 must be true or false");
        if (typeof ext.rsv2 !== "boolean")
          throw new TypeError("extension.rsv2 must be true or false");
        if (typeof ext.rsv3 !== "boolean")
          throw new TypeError("extension.rsv3 must be true or false");
        if (this._byName.hasOwnProperty(ext.name))
          throw new TypeError('An extension with name "' + ext.name + '" is already registered');
        this._byName[ext.name] = ext;
        this._inOrder.push(ext);
      },
      generateOffer: function() {
        var sessions = [], offer = [], index = {};
        this._inOrder.forEach(function(ext) {
          var session = ext.createClientSession();
          if (!session)
            return;
          var record = [ext, session];
          sessions.push(record);
          index[ext.name] = record;
          var offers = session.generateOffer();
          offers = offers ? [].concat(offers) : [];
          offers.forEach(function(off) {
            offer.push(Parser.serializeParams(ext.name, off));
          }, this);
        }, this);
        this._sessions = sessions;
        this._index = index;
        return offer.length > 0 ? offer.join(", ") : null;
      },
      activate: function(header) {
        var responses = Parser.parseHeader(header), sessions = [];
        responses.eachOffer(function(name22, params) {
          var record = this._index[name22];
          if (!record)
            throw new Error('Server sent an extension response for unknown extension "' + name22 + '"');
          var ext = record[0], session = record[1], reserved2 = this._reserved(ext);
          if (reserved2)
            throw new Error("Server sent two extension responses that use the RSV" + reserved2[0] + ' bit: "' + reserved2[1] + '" and "' + ext.name + '"');
          if (session.activate(params) !== true)
            throw new Error("Server sent unacceptable extension parameters: " + Parser.serializeParams(name22, params));
          this._reserve(ext);
          sessions.push(record);
        }, this);
        this._sessions = sessions;
        this._pipeline = new Pipeline(sessions);
      },
      generateResponse: function(header) {
        var sessions = [], response = [], offers = Parser.parseHeader(header);
        this._inOrder.forEach(function(ext) {
          var offer = offers.byName(ext.name);
          if (offer.length === 0 || this._reserved(ext))
            return;
          var session = ext.createServerSession(offer);
          if (!session)
            return;
          this._reserve(ext);
          sessions.push([ext, session]);
          response.push(Parser.serializeParams(ext.name, session.generateResponse()));
        }, this);
        this._sessions = sessions;
        this._pipeline = new Pipeline(sessions);
        return response.length > 0 ? response.join(", ") : null;
      },
      validFrameRsv: function(frame2) {
        var allowed = { rsv1: false, rsv2: false, rsv3: false }, ext;
        if (Extensions$1.MESSAGE_OPCODES.indexOf(frame2.opcode) >= 0) {
          for (var i = 0, n = this._sessions.length; i < n; i++) {
            ext = this._sessions[i][0];
            allowed.rsv1 = allowed.rsv1 || ext.rsv1;
            allowed.rsv2 = allowed.rsv2 || ext.rsv2;
            allowed.rsv3 = allowed.rsv3 || ext.rsv3;
          }
        }
        return (allowed.rsv1 || !frame2.rsv1) && (allowed.rsv2 || !frame2.rsv2) && (allowed.rsv3 || !frame2.rsv3);
      },
      processIncomingMessage: function(message2, callback, context) {
        this._pipeline.processIncomingMessage(message2, callback, context);
      },
      processOutgoingMessage: function(message2, callback, context) {
        this._pipeline.processOutgoingMessage(message2, callback, context);
      },
      close: function(callback, context) {
        if (!this._pipeline)
          return callback.call(context);
        this._pipeline.close(callback, context);
      },
      _reserve: function(ext) {
        this._rsv1 = this._rsv1 || ext.rsv1 && ext.name;
        this._rsv2 = this._rsv2 || ext.rsv2 && ext.name;
        this._rsv3 = this._rsv3 || ext.rsv3 && ext.name;
      },
      _reserved: function(ext) {
        if (this._rsv1 && ext.rsv1)
          return [1, this._rsv1];
        if (this._rsv2 && ext.rsv2)
          return [2, this._rsv2];
        if (this._rsv3 && ext.rsv3)
          return [3, this._rsv3];
        return false;
      }
    };
    for (key$a in instance$a)
      Extensions$1.prototype[key$a] = instance$a[key$a];
    websocket_extensions = Extensions$1;
    Frame$1 = function() {
    };
    instance$9 = {
      final: false,
      rsv1: false,
      rsv2: false,
      rsv3: false,
      opcode: null,
      masked: false,
      maskingKey: null,
      lengthBytes: 1,
      length: 0,
      payload: null
    };
    for (key$9 in instance$9)
      Frame$1.prototype[key$9] = instance$9[key$9];
    frame = Frame$1;
    Buffer$6 = safeBuffer.exports.Buffer;
    Message$1 = function() {
      this.rsv1 = false;
      this.rsv2 = false;
      this.rsv3 = false;
      this.opcode = null;
      this.length = 0;
      this._chunks = [];
    };
    instance$8 = {
      read: function() {
        return this.data = this.data || Buffer$6.concat(this._chunks, this.length);
      },
      pushFrame: function(frame2) {
        this.rsv1 = this.rsv1 || frame2.rsv1;
        this.rsv2 = this.rsv2 || frame2.rsv2;
        this.rsv3 = this.rsv3 || frame2.rsv3;
        if (this.opcode === null)
          this.opcode = frame2.opcode;
        this._chunks.push(frame2.payload);
        this.length += frame2.length;
      }
    };
    for (key$8 in instance$8)
      Message$1.prototype[key$8] = instance$8[key$8];
    message = Message$1;
    Buffer$5 = safeBuffer.exports.Buffer;
    crypto$2 = import_crypto2.default;
    util$9 = import_util2.default;
    Extensions = websocket_extensions;
    Base$6 = base;
    Frame = frame;
    Message = message;
    Hybi$2 = function(request, url2, options2) {
      Base$6.apply(this, arguments);
      this._extensions = new Extensions();
      this._stage = 0;
      this._masking = this._options.masking;
      this._protocols = this._options.protocols || [];
      this._requireMasking = this._options.requireMasking;
      this._pingCallbacks = {};
      if (typeof this._protocols === "string")
        this._protocols = this._protocols.split(/ *, */);
      if (!this._request)
        return;
      var protos = this._request.headers["sec-websocket-protocol"], supported = this._protocols;
      if (protos !== void 0) {
        if (typeof protos === "string")
          protos = protos.split(/ *, */);
        this.protocol = protos.filter(function(p2) {
          return supported.indexOf(p2) >= 0;
        })[0];
      }
      this.version = "hybi-" + Hybi$2.VERSION;
    };
    util$9.inherits(Hybi$2, Base$6);
    Hybi$2.VERSION = "13";
    Hybi$2.mask = function(payload, mask, offset) {
      if (!mask || mask.length === 0)
        return payload;
      offset = offset || 0;
      for (var i = 0, n = payload.length - offset; i < n; i++) {
        payload[offset + i] = payload[offset + i] ^ mask[i % 4];
      }
      return payload;
    };
    Hybi$2.generateAccept = function(key) {
      var sha12 = crypto$2.createHash("sha1");
      sha12.update(key + Hybi$2.GUID);
      return sha12.digest("base64");
    };
    Hybi$2.GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    instance$7 = {
      FIN: 128,
      MASK: 128,
      RSV1: 64,
      RSV2: 32,
      RSV3: 16,
      OPCODE: 15,
      LENGTH: 127,
      OPCODES: {
        continuation: 0,
        text: 1,
        binary: 2,
        close: 8,
        ping: 9,
        pong: 10
      },
      OPCODE_CODES: [0, 1, 2, 8, 9, 10],
      MESSAGE_OPCODES: [0, 1, 2],
      OPENING_OPCODES: [1, 2],
      ERRORS: {
        normal_closure: 1e3,
        going_away: 1001,
        protocol_error: 1002,
        unacceptable: 1003,
        encoding_error: 1007,
        policy_violation: 1008,
        too_large: 1009,
        extension_error: 1010,
        unexpected_condition: 1011
      },
      ERROR_CODES: [1e3, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011],
      DEFAULT_ERROR_CODE: 1e3,
      MIN_RESERVED_ERROR: 3e3,
      MAX_RESERVED_ERROR: 4999,
      UTF8_MATCH: /^([\x00-\x7F]|[\xC2-\xDF][\x80-\xBF]|\xE0[\xA0-\xBF][\x80-\xBF]|[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}|\xED[\x80-\x9F][\x80-\xBF]|\xF0[\x90-\xBF][\x80-\xBF]{2}|[\xF1-\xF3][\x80-\xBF]{3}|\xF4[\x80-\x8F][\x80-\xBF]{2})*$/,
      addExtension: function(extension) {
        this._extensions.add(extension);
        return true;
      },
      parse: function(chunk) {
        this._reader.put(chunk);
        var buffer = true;
        while (buffer) {
          switch (this._stage) {
            case 0:
              buffer = this._reader.read(1);
              if (buffer)
                this._parseOpcode(buffer[0]);
              break;
            case 1:
              buffer = this._reader.read(1);
              if (buffer)
                this._parseLength(buffer[0]);
              break;
            case 2:
              buffer = this._reader.read(this._frame.lengthBytes);
              if (buffer)
                this._parseExtendedLength(buffer);
              break;
            case 3:
              buffer = this._reader.read(4);
              if (buffer) {
                this._stage = 4;
                this._frame.maskingKey = buffer;
              }
              break;
            case 4:
              buffer = this._reader.read(this._frame.length);
              if (buffer) {
                this._stage = 0;
                this._emitFrame(buffer);
              }
              break;
            default:
              buffer = null;
          }
        }
      },
      text: function(message2) {
        if (this.readyState > 1)
          return false;
        return this.frame(message2, "text");
      },
      binary: function(message2) {
        if (this.readyState > 1)
          return false;
        return this.frame(message2, "binary");
      },
      ping: function(message2, callback) {
        if (this.readyState > 1)
          return false;
        message2 = message2 || "";
        if (callback)
          this._pingCallbacks[message2] = callback;
        return this.frame(message2, "ping");
      },
      pong: function(message2) {
        if (this.readyState > 1)
          return false;
        message2 = message2 || "";
        return this.frame(message2, "pong");
      },
      close: function(reason, code) {
        reason = reason || "";
        code = code || this.ERRORS.normal_closure;
        if (this.readyState <= 0) {
          this.readyState = 3;
          this.emit("close", new Base$6.CloseEvent(code, reason));
          return true;
        } else if (this.readyState === 1) {
          this.readyState = 2;
          this._extensions.close(function() {
            this.frame(reason, "close", code);
          }, this);
          return true;
        } else {
          return false;
        }
      },
      frame: function(buffer, type, code) {
        if (this.readyState <= 0)
          return this._queue([buffer, type, code]);
        if (this.readyState > 2)
          return false;
        if (buffer instanceof Array)
          buffer = Buffer$5.from(buffer);
        if (typeof buffer === "number")
          buffer = buffer.toString();
        var message2 = new Message(), isText = typeof buffer === "string", payload, copy;
        message2.rsv1 = message2.rsv2 = message2.rsv3 = false;
        message2.opcode = this.OPCODES[type || (isText ? "text" : "binary")];
        payload = isText ? Buffer$5.from(buffer, "utf8") : buffer;
        if (code) {
          copy = payload;
          payload = Buffer$5.allocUnsafe(2 + copy.length);
          payload.writeUInt16BE(code, 0);
          copy.copy(payload, 2);
        }
        message2.data = payload;
        var onMessageReady = function(message3) {
          var frame2 = new Frame();
          frame2.final = true;
          frame2.rsv1 = message3.rsv1;
          frame2.rsv2 = message3.rsv2;
          frame2.rsv3 = message3.rsv3;
          frame2.opcode = message3.opcode;
          frame2.masked = !!this._masking;
          frame2.length = message3.data.length;
          frame2.payload = message3.data;
          if (frame2.masked)
            frame2.maskingKey = crypto$2.randomBytes(4);
          this._sendFrame(frame2);
        };
        if (this.MESSAGE_OPCODES.indexOf(message2.opcode) >= 0)
          this._extensions.processOutgoingMessage(message2, function(error22, message3) {
            if (error22)
              return this._fail("extension_error", error22.message);
            onMessageReady.call(this, message3);
          }, this);
        else
          onMessageReady.call(this, message2);
        return true;
      },
      _sendFrame: function(frame2) {
        var length = frame2.length, header = length <= 125 ? 2 : length <= 65535 ? 4 : 10, offset = header + (frame2.masked ? 4 : 0), buffer = Buffer$5.allocUnsafe(offset + length), masked = frame2.masked ? this.MASK : 0;
        buffer[0] = (frame2.final ? this.FIN : 0) | (frame2.rsv1 ? this.RSV1 : 0) | (frame2.rsv2 ? this.RSV2 : 0) | (frame2.rsv3 ? this.RSV3 : 0) | frame2.opcode;
        if (length <= 125) {
          buffer[1] = masked | length;
        } else if (length <= 65535) {
          buffer[1] = masked | 126;
          buffer.writeUInt16BE(length, 2);
        } else {
          buffer[1] = masked | 127;
          buffer.writeUInt32BE(Math.floor(length / 4294967296), 2);
          buffer.writeUInt32BE(length % 4294967296, 6);
        }
        frame2.payload.copy(buffer, offset);
        if (frame2.masked) {
          frame2.maskingKey.copy(buffer, header);
          Hybi$2.mask(buffer, frame2.maskingKey, offset);
        }
        this._write(buffer);
      },
      _handshakeResponse: function() {
        var secKey = this._request.headers["sec-websocket-key"], version22 = this._request.headers["sec-websocket-version"];
        if (version22 !== Hybi$2.VERSION)
          throw new Error("Unsupported WebSocket version: " + version22);
        if (typeof secKey !== "string")
          throw new Error("Missing handshake request header: Sec-WebSocket-Key");
        this._headers.set("Upgrade", "websocket");
        this._headers.set("Connection", "Upgrade");
        this._headers.set("Sec-WebSocket-Accept", Hybi$2.generateAccept(secKey));
        if (this.protocol)
          this._headers.set("Sec-WebSocket-Protocol", this.protocol);
        var extensions = this._extensions.generateResponse(this._request.headers["sec-websocket-extensions"]);
        if (extensions)
          this._headers.set("Sec-WebSocket-Extensions", extensions);
        var start2 = "HTTP/1.1 101 Switching Protocols", headers2 = [start2, this._headers.toString(), ""];
        return Buffer$5.from(headers2.join("\r\n"), "utf8");
      },
      _shutdown: function(code, reason, error22) {
        delete this._frame;
        delete this._message;
        this._stage = 5;
        var sendCloseFrame = this.readyState === 1;
        this.readyState = 2;
        this._extensions.close(function() {
          if (sendCloseFrame)
            this.frame(reason, "close", code);
          this.readyState = 3;
          if (error22)
            this.emit("error", new Error(reason));
          this.emit("close", new Base$6.CloseEvent(code, reason));
        }, this);
      },
      _fail: function(type, message2) {
        if (this.readyState > 1)
          return;
        this._shutdown(this.ERRORS[type], message2, true);
      },
      _parseOpcode: function(octet) {
        var rsvs = [this.RSV1, this.RSV2, this.RSV3].map(function(rsv) {
          return (octet & rsv) === rsv;
        });
        var frame2 = this._frame = new Frame();
        frame2.final = (octet & this.FIN) === this.FIN;
        frame2.rsv1 = rsvs[0];
        frame2.rsv2 = rsvs[1];
        frame2.rsv3 = rsvs[2];
        frame2.opcode = octet & this.OPCODE;
        this._stage = 1;
        if (!this._extensions.validFrameRsv(frame2))
          return this._fail("protocol_error", "One or more reserved bits are on: reserved1 = " + (frame2.rsv1 ? 1 : 0) + ", reserved2 = " + (frame2.rsv2 ? 1 : 0) + ", reserved3 = " + (frame2.rsv3 ? 1 : 0));
        if (this.OPCODE_CODES.indexOf(frame2.opcode) < 0)
          return this._fail("protocol_error", "Unrecognized frame opcode: " + frame2.opcode);
        if (this.MESSAGE_OPCODES.indexOf(frame2.opcode) < 0 && !frame2.final)
          return this._fail("protocol_error", "Received fragmented control frame: opcode = " + frame2.opcode);
        if (this._message && this.OPENING_OPCODES.indexOf(frame2.opcode) >= 0)
          return this._fail("protocol_error", "Received new data frame but previous continuous frame is unfinished");
      },
      _parseLength: function(octet) {
        var frame2 = this._frame;
        frame2.masked = (octet & this.MASK) === this.MASK;
        frame2.length = octet & this.LENGTH;
        if (frame2.length >= 0 && frame2.length <= 125) {
          this._stage = frame2.masked ? 3 : 4;
          if (!this._checkFrameLength())
            return;
        } else {
          this._stage = 2;
          frame2.lengthBytes = frame2.length === 126 ? 2 : 8;
        }
        if (this._requireMasking && !frame2.masked)
          return this._fail("unacceptable", "Received unmasked frame but masking is required");
      },
      _parseExtendedLength: function(buffer) {
        var frame2 = this._frame;
        frame2.length = this._readUInt(buffer);
        this._stage = frame2.masked ? 3 : 4;
        if (this.MESSAGE_OPCODES.indexOf(frame2.opcode) < 0 && frame2.length > 125)
          return this._fail("protocol_error", "Received control frame having too long payload: " + frame2.length);
        if (!this._checkFrameLength())
          return;
      },
      _checkFrameLength: function() {
        var length = this._message ? this._message.length : 0;
        if (length + this._frame.length > this._maxLength) {
          this._fail("too_large", "WebSocket frame length too large");
          return false;
        } else {
          return true;
        }
      },
      _emitFrame: function(buffer) {
        var frame2 = this._frame, payload = frame2.payload = Hybi$2.mask(buffer, frame2.maskingKey), opcode = frame2.opcode, message2, code, reason, callbacks, callback;
        delete this._frame;
        if (opcode === this.OPCODES.continuation) {
          if (!this._message)
            return this._fail("protocol_error", "Received unexpected continuation frame");
          this._message.pushFrame(frame2);
        }
        if (opcode === this.OPCODES.text || opcode === this.OPCODES.binary) {
          this._message = new Message();
          this._message.pushFrame(frame2);
        }
        if (frame2.final && this.MESSAGE_OPCODES.indexOf(opcode) >= 0)
          return this._emitMessage(this._message);
        if (opcode === this.OPCODES.close) {
          code = payload.length >= 2 ? payload.readUInt16BE(0) : null;
          reason = payload.length > 2 ? this._encode(payload.slice(2)) : null;
          if (!(payload.length === 0) && !(code !== null && code >= this.MIN_RESERVED_ERROR && code <= this.MAX_RESERVED_ERROR) && this.ERROR_CODES.indexOf(code) < 0)
            code = this.ERRORS.protocol_error;
          if (payload.length > 125 || payload.length > 2 && !reason)
            code = this.ERRORS.protocol_error;
          this._shutdown(code || this.DEFAULT_ERROR_CODE, reason || "");
        }
        if (opcode === this.OPCODES.ping) {
          this.frame(payload, "pong");
          this.emit("ping", new Base$6.PingEvent(payload.toString()));
        }
        if (opcode === this.OPCODES.pong) {
          callbacks = this._pingCallbacks;
          message2 = this._encode(payload);
          callback = callbacks[message2];
          delete callbacks[message2];
          if (callback)
            callback();
          this.emit("pong", new Base$6.PongEvent(payload.toString()));
        }
      },
      _emitMessage: function(message2) {
        var message2 = this._message;
        message2.read();
        delete this._message;
        this._extensions.processIncomingMessage(message2, function(error22, message3) {
          if (error22)
            return this._fail("extension_error", error22.message);
          var payload = message3.data;
          if (message3.opcode === this.OPCODES.text)
            payload = this._encode(payload);
          if (payload === null)
            return this._fail("encoding_error", "Could not decode a text frame as UTF-8");
          else
            this.emit("message", new Base$6.MessageEvent(payload));
        }, this);
      },
      _encode: function(buffer) {
        try {
          var string = buffer.toString("binary", 0, buffer.length);
          if (!this.UTF8_MATCH.test(string))
            return null;
        } catch (e) {
        }
        return buffer.toString("utf8", 0, buffer.length);
      },
      _readUInt: function(buffer) {
        if (buffer.length === 2)
          return buffer.readUInt16BE(0);
        return buffer.readUInt32BE(0) * 4294967296 + buffer.readUInt32BE(4);
      }
    };
    for (key$7 in instance$7)
      Hybi$2.prototype[key$7] = instance$7[key$7];
    hybi = Hybi$2;
    Buffer$4 = safeBuffer.exports.Buffer;
    Stream$2 = import_stream2.default.Stream;
    url$2 = import_url2.default;
    util$8 = import_util2.default;
    Base$5 = base;
    Headers$1 = headers;
    HttpParser$2 = http_parser;
    PORTS = { "ws:": 80, "wss:": 443 };
    Proxy$1 = function(client2, origin, options2) {
      this._client = client2;
      this._http = new HttpParser$2("response");
      this._origin = typeof client2.url === "object" ? client2.url : url$2.parse(client2.url);
      this._url = typeof origin === "object" ? origin : url$2.parse(origin);
      this._options = options2 || {};
      this._state = 0;
      this.readable = this.writable = true;
      this._paused = false;
      this._headers = new Headers$1();
      this._headers.set("Host", this._origin.host);
      this._headers.set("Connection", "keep-alive");
      this._headers.set("Proxy-Connection", "keep-alive");
      var auth = this._url.auth && Buffer$4.from(this._url.auth, "utf8").toString("base64");
      if (auth)
        this._headers.set("Proxy-Authorization", "Basic " + auth);
    };
    util$8.inherits(Proxy$1, Stream$2);
    instance$6 = {
      setHeader: function(name22, value) {
        if (this._state !== 0)
          return false;
        this._headers.set(name22, value);
        return true;
      },
      start: function() {
        if (this._state !== 0)
          return false;
        this._state = 1;
        var origin = this._origin, port = origin.port || PORTS[origin.protocol], start2 = "CONNECT " + origin.hostname + ":" + port + " HTTP/1.1";
        var headers2 = [start2, this._headers.toString(), ""];
        this.emit("data", Buffer$4.from(headers2.join("\r\n"), "utf8"));
        return true;
      },
      pause: function() {
        this._paused = true;
      },
      resume: function() {
        this._paused = false;
        this.emit("drain");
      },
      write: function(chunk) {
        if (!this.writable)
          return false;
        this._http.parse(chunk);
        if (!this._http.isComplete())
          return !this._paused;
        this.statusCode = this._http.statusCode;
        this.headers = this._http.headers;
        if (this.statusCode === 200) {
          this.emit("connect", new Base$5.ConnectEvent());
        } else {
          var message2 = "Can't establish a connection to the server at " + this._origin.href;
          this.emit("error", new Error(message2));
        }
        this.end();
        return !this._paused;
      },
      end: function(chunk) {
        if (!this.writable)
          return;
        if (chunk !== void 0)
          this.write(chunk);
        this.readable = this.writable = false;
        this.emit("close");
        this.emit("end");
      },
      destroy: function() {
        this.end();
      }
    };
    for (key$6 in instance$6)
      Proxy$1.prototype[key$6] = instance$6[key$6];
    proxy = Proxy$1;
    Buffer$3 = safeBuffer.exports.Buffer;
    crypto$1 = import_crypto2.default;
    url$1 = import_url2.default;
    util$7 = import_util2.default;
    HttpParser$1 = http_parser;
    Base$4 = base;
    Hybi$1 = hybi;
    Proxy2 = proxy;
    Client$2 = function(_url, options2) {
      this.version = "hybi-" + Hybi$1.VERSION;
      Hybi$1.call(this, null, _url, options2);
      this.readyState = -1;
      this._key = Client$2.generateKey();
      this._accept = Hybi$1.generateAccept(this._key);
      this._http = new HttpParser$1("response");
      var uri = url$1.parse(this.url), auth = uri.auth && Buffer$3.from(uri.auth, "utf8").toString("base64");
      if (this.VALID_PROTOCOLS.indexOf(uri.protocol) < 0)
        throw new Error(this.url + " is not a valid WebSocket URL");
      this._pathname = (uri.pathname || "/") + (uri.search || "");
      this._headers.set("Host", uri.host);
      this._headers.set("Upgrade", "websocket");
      this._headers.set("Connection", "Upgrade");
      this._headers.set("Sec-WebSocket-Key", this._key);
      this._headers.set("Sec-WebSocket-Version", Hybi$1.VERSION);
      if (this._protocols.length > 0)
        this._headers.set("Sec-WebSocket-Protocol", this._protocols.join(", "));
      if (auth)
        this._headers.set("Authorization", "Basic " + auth);
    };
    util$7.inherits(Client$2, Hybi$1);
    Client$2.generateKey = function() {
      return crypto$1.randomBytes(16).toString("base64");
    };
    instance$5 = {
      VALID_PROTOCOLS: ["ws:", "wss:"],
      proxy: function(origin, options2) {
        return new Proxy2(this, origin, options2);
      },
      start: function() {
        if (this.readyState !== -1)
          return false;
        this._write(this._handshakeRequest());
        this.readyState = 0;
        return true;
      },
      parse: function(chunk) {
        if (this.readyState === 3)
          return;
        if (this.readyState > 0)
          return Hybi$1.prototype.parse.call(this, chunk);
        this._http.parse(chunk);
        if (!this._http.isComplete())
          return;
        this._validateHandshake();
        if (this.readyState === 3)
          return;
        this._open();
        this.parse(this._http.body);
      },
      _handshakeRequest: function() {
        var extensions = this._extensions.generateOffer();
        if (extensions)
          this._headers.set("Sec-WebSocket-Extensions", extensions);
        var start2 = "GET " + this._pathname + " HTTP/1.1", headers2 = [start2, this._headers.toString(), ""];
        return Buffer$3.from(headers2.join("\r\n"), "utf8");
      },
      _failHandshake: function(message2) {
        message2 = "Error during WebSocket handshake: " + message2;
        this.readyState = 3;
        this.emit("error", new Error(message2));
        this.emit("close", new Base$4.CloseEvent(this.ERRORS.protocol_error, message2));
      },
      _validateHandshake: function() {
        this.statusCode = this._http.statusCode;
        this.headers = this._http.headers;
        if (this._http.error)
          return this._failHandshake(this._http.error.message);
        if (this._http.statusCode !== 101)
          return this._failHandshake("Unexpected response code: " + this._http.statusCode);
        var headers2 = this._http.headers, upgrade = headers2["upgrade"] || "", connection = headers2["connection"] || "", accept = headers2["sec-websocket-accept"] || "", protocol = headers2["sec-websocket-protocol"] || "";
        if (upgrade === "")
          return this._failHandshake("'Upgrade' header is missing");
        if (upgrade.toLowerCase() !== "websocket")
          return this._failHandshake("'Upgrade' header value is not 'WebSocket'");
        if (connection === "")
          return this._failHandshake("'Connection' header is missing");
        if (connection.toLowerCase() !== "upgrade")
          return this._failHandshake("'Connection' header value is not 'Upgrade'");
        if (accept !== this._accept)
          return this._failHandshake("Sec-WebSocket-Accept mismatch");
        this.protocol = null;
        if (protocol !== "") {
          if (this._protocols.indexOf(protocol) < 0)
            return this._failHandshake("Sec-WebSocket-Protocol mismatch");
          else
            this.protocol = protocol;
        }
        try {
          this._extensions.activate(this.headers["sec-websocket-extensions"]);
        } catch (e) {
          return this._failHandshake(e.message);
        }
      }
    };
    for (key$5 in instance$5)
      Client$2.prototype[key$5] = instance$5[key$5];
    client$1 = Client$2;
    Buffer$2 = safeBuffer.exports.Buffer;
    Base$3 = base;
    util$6 = import_util2.default;
    Draft75$2 = function(request, url2, options2) {
      Base$3.apply(this, arguments);
      this._stage = 0;
      this.version = "hixie-75";
      this._headers.set("Upgrade", "WebSocket");
      this._headers.set("Connection", "Upgrade");
      this._headers.set("WebSocket-Origin", this._request.headers.origin);
      this._headers.set("WebSocket-Location", this.url);
    };
    util$6.inherits(Draft75$2, Base$3);
    instance$4 = {
      close: function() {
        if (this.readyState === 3)
          return false;
        this.readyState = 3;
        this.emit("close", new Base$3.CloseEvent(null, null));
        return true;
      },
      parse: function(chunk) {
        if (this.readyState > 1)
          return;
        this._reader.put(chunk);
        this._reader.eachByte(function(octet) {
          var message2;
          switch (this._stage) {
            case -1:
              this._body.push(octet);
              this._sendHandshakeBody();
              break;
            case 0:
              this._parseLeadingByte(octet);
              break;
            case 1:
              this._length = (octet & 127) + 128 * this._length;
              if (this._closing && this._length === 0) {
                return this.close();
              } else if ((octet & 128) !== 128) {
                if (this._length === 0) {
                  this._stage = 0;
                } else {
                  this._skipped = 0;
                  this._stage = 2;
                }
              }
              break;
            case 2:
              if (octet === 255) {
                this._stage = 0;
                message2 = Buffer$2.from(this._buffer).toString("utf8", 0, this._buffer.length);
                this.emit("message", new Base$3.MessageEvent(message2));
              } else {
                if (this._length) {
                  this._skipped += 1;
                  if (this._skipped === this._length)
                    this._stage = 0;
                } else {
                  this._buffer.push(octet);
                  if (this._buffer.length > this._maxLength)
                    return this.close();
                }
              }
              break;
          }
        }, this);
      },
      frame: function(buffer) {
        if (this.readyState === 0)
          return this._queue([buffer]);
        if (this.readyState > 1)
          return false;
        if (typeof buffer !== "string")
          buffer = buffer.toString();
        var length = Buffer$2.byteLength(buffer), frame2 = Buffer$2.allocUnsafe(length + 2);
        frame2[0] = 0;
        frame2.write(buffer, 1);
        frame2[frame2.length - 1] = 255;
        this._write(frame2);
        return true;
      },
      _handshakeResponse: function() {
        var start2 = "HTTP/1.1 101 Web Socket Protocol Handshake", headers2 = [start2, this._headers.toString(), ""];
        return Buffer$2.from(headers2.join("\r\n"), "utf8");
      },
      _parseLeadingByte: function(octet) {
        if ((octet & 128) === 128) {
          this._length = 0;
          this._stage = 1;
        } else {
          delete this._length;
          delete this._skipped;
          this._buffer = [];
          this._stage = 2;
        }
      }
    };
    for (key$4 in instance$4)
      Draft75$2.prototype[key$4] = instance$4[key$4];
    draft75 = Draft75$2;
    Buffer$1 = safeBuffer.exports.Buffer;
    Base$2 = base;
    Draft75$1 = draft75;
    crypto = import_crypto2.default;
    util$5 = import_util2.default;
    numberFromKey = function(key) {
      return parseInt((key.match(/[0-9]/g) || []).join(""), 10);
    };
    spacesInKey = function(key) {
      return (key.match(/ /g) || []).length;
    };
    Draft76$1 = function(request, url2, options2) {
      Draft75$1.apply(this, arguments);
      this._stage = -1;
      this._body = [];
      this.version = "hixie-76";
      this._headers.clear();
      this._headers.set("Upgrade", "WebSocket");
      this._headers.set("Connection", "Upgrade");
      this._headers.set("Sec-WebSocket-Origin", this._request.headers.origin);
      this._headers.set("Sec-WebSocket-Location", this.url);
    };
    util$5.inherits(Draft76$1, Draft75$1);
    instance$3 = {
      BODY_SIZE: 8,
      start: function() {
        if (!Draft75$1.prototype.start.call(this))
          return false;
        this._started = true;
        this._sendHandshakeBody();
        return true;
      },
      close: function() {
        if (this.readyState === 3)
          return false;
        if (this.readyState === 1)
          this._write(Buffer$1.from([255, 0]));
        this.readyState = 3;
        this.emit("close", new Base$2.CloseEvent(null, null));
        return true;
      },
      _handshakeResponse: function() {
        var headers2 = this._request.headers, key1 = headers2["sec-websocket-key1"], key2 = headers2["sec-websocket-key2"];
        if (!key1)
          throw new Error("Missing required header: Sec-WebSocket-Key1");
        if (!key2)
          throw new Error("Missing required header: Sec-WebSocket-Key2");
        var number1 = numberFromKey(key1), spaces1 = spacesInKey(key1), number2 = numberFromKey(key2), spaces2 = spacesInKey(key2);
        if (number1 % spaces1 !== 0 || number2 % spaces2 !== 0)
          throw new Error("Client sent invalid Sec-WebSocket-Key headers");
        this._keyValues = [number1 / spaces1, number2 / spaces2];
        var start2 = "HTTP/1.1 101 WebSocket Protocol Handshake", headers2 = [start2, this._headers.toString(), ""];
        return Buffer$1.from(headers2.join("\r\n"), "binary");
      },
      _handshakeSignature: function() {
        if (this._body.length < this.BODY_SIZE)
          return null;
        var md5 = crypto.createHash("md5"), buffer = Buffer$1.allocUnsafe(8 + this.BODY_SIZE);
        buffer.writeUInt32BE(this._keyValues[0], 0);
        buffer.writeUInt32BE(this._keyValues[1], 4);
        Buffer$1.from(this._body).copy(buffer, 8, 0, this.BODY_SIZE);
        md5.update(buffer);
        return Buffer$1.from(md5.digest("binary"), "binary");
      },
      _sendHandshakeBody: function() {
        if (!this._started)
          return;
        var signature = this._handshakeSignature();
        if (!signature)
          return;
        this._write(signature);
        this._stage = 0;
        this._open();
        if (this._body.length > this.BODY_SIZE)
          this.parse(this._body.slice(this.BODY_SIZE));
      },
      _parseLeadingByte: function(octet) {
        if (octet !== 255)
          return Draft75$1.prototype._parseLeadingByte.call(this, octet);
        this._closing = true;
        this._length = 0;
        this._stage = 1;
      }
    };
    for (key$3 in instance$3)
      Draft76$1.prototype[key$3] = instance$3[key$3];
    draft76 = Draft76$1;
    util$4 = import_util2.default;
    HttpParser = http_parser;
    Base$1 = base;
    Draft75 = draft75;
    Draft76 = draft76;
    Hybi = hybi;
    Server$1 = function(options2) {
      Base$1.call(this, null, null, options2);
      this._http = new HttpParser("request");
    };
    util$4.inherits(Server$1, Base$1);
    instance$2 = {
      EVENTS: ["open", "message", "error", "close", "ping", "pong"],
      _bindEventListeners: function() {
        this.messages.on("error", function() {
        });
        this.on("error", function() {
        });
      },
      parse: function(chunk) {
        if (this._delegate)
          return this._delegate.parse(chunk);
        this._http.parse(chunk);
        if (!this._http.isComplete())
          return;
        this.method = this._http.method;
        this.url = this._http.url;
        this.headers = this._http.headers;
        this.body = this._http.body;
        var self2 = this;
        this._delegate = Server$1.http(this, this._options);
        this._delegate.messages = this.messages;
        this._delegate.io = this.io;
        this._open();
        this.EVENTS.forEach(function(event2) {
          this._delegate.on(event2, function(e) {
            self2.emit(event2, e);
          });
        }, this);
        this.protocol = this._delegate.protocol;
        this.version = this._delegate.version;
        this.parse(this._http.body);
        this.emit("connect", new Base$1.ConnectEvent());
      },
      _open: function() {
        this.__queue.forEach(function(msg) {
          this._delegate[msg[0]].apply(this._delegate, msg[1]);
        }, this);
        this.__queue = [];
      }
    };
    ["addExtension", "setHeader", "start", "frame", "text", "binary", "ping", "close"].forEach(function(method) {
      instance$2[method] = function() {
        if (this._delegate) {
          return this._delegate[method].apply(this._delegate, arguments);
        } else {
          this.__queue.push([method, arguments]);
          return true;
        }
      };
    });
    for (key$2 in instance$2)
      Server$1.prototype[key$2] = instance$2[key$2];
    Server$1.isSecureRequest = function(request) {
      if (request.connection && request.connection.authorized !== void 0)
        return true;
      if (request.socket && request.socket.secure)
        return true;
      var headers2 = request.headers;
      if (!headers2)
        return false;
      if (headers2["https"] === "on")
        return true;
      if (headers2["x-forwarded-ssl"] === "on")
        return true;
      if (headers2["x-forwarded-scheme"] === "https")
        return true;
      if (headers2["x-forwarded-proto"] === "https")
        return true;
      return false;
    };
    Server$1.determineUrl = function(request) {
      var scheme2 = this.isSecureRequest(request) ? "wss:" : "ws:";
      return scheme2 + "//" + request.headers.host + request.url;
    };
    Server$1.http = function(request, options2) {
      options2 = options2 || {};
      if (options2.requireMasking === void 0)
        options2.requireMasking = true;
      var headers2 = request.headers, version22 = headers2["sec-websocket-version"], key = headers2["sec-websocket-key"], key1 = headers2["sec-websocket-key1"], key2 = headers2["sec-websocket-key2"], url2 = this.determineUrl(request);
      if (version22 || key)
        return new Hybi(request, url2, options2);
      else if (key1 || key2)
        return new Draft76(request, url2, options2);
      else
        return new Draft75(request, url2, options2);
    };
    server = Server$1;
    Base = base;
    Client$1 = client$1;
    Server = server;
    Driver = {
      client: function(url2, options2) {
        options2 = options2 || {};
        if (options2.masking === void 0)
          options2.masking = true;
        return new Client$1(url2, options2);
      },
      server: function(options2) {
        options2 = options2 || {};
        if (options2.requireMasking === void 0)
          options2.requireMasking = true;
        return new Server(options2);
      },
      http: function() {
        return Server.http.apply(Server, arguments);
      },
      isSecureRequest: function(request) {
        return Server.isSecureRequest(request);
      },
      isWebSocket: function(request) {
        return Base.isWebSocket(request);
      },
      validateOptions: function(options2, validKeys) {
        Base.validateOptions(options2, validKeys);
      }
    };
    driver$4 = Driver;
    Event$3 = function(eventType, options2) {
      this.type = eventType;
      for (var key in options2)
        this[key] = options2[key];
    };
    Event$3.prototype.initEvent = function(eventType, canBubble, cancelable) {
      this.type = eventType;
      this.bubbles = canBubble;
      this.cancelable = cancelable;
    };
    Event$3.prototype.stopPropagation = function() {
    };
    Event$3.prototype.preventDefault = function() {
    };
    Event$3.CAPTURING_PHASE = 1;
    Event$3.AT_TARGET = 2;
    Event$3.BUBBLING_PHASE = 3;
    event = Event$3;
    Event$2 = event;
    EventTarget$2 = {
      onopen: null,
      onmessage: null,
      onerror: null,
      onclose: null,
      addEventListener: function(eventType, listener, useCapture) {
        this.on(eventType, listener);
      },
      removeEventListener: function(eventType, listener, useCapture) {
        this.removeListener(eventType, listener);
      },
      dispatchEvent: function(event2) {
        event2.target = event2.currentTarget = this;
        event2.eventPhase = Event$2.AT_TARGET;
        if (this["on" + event2.type])
          this["on" + event2.type](event2);
        this.emit(event2.type, event2);
      }
    };
    event_target = EventTarget$2;
    Stream$1 = import_stream2.default.Stream;
    util$3 = import_util2.default;
    driver$3 = driver$4;
    EventTarget$1 = event_target;
    Event$1 = event;
    API$3 = function(options2) {
      options2 = options2 || {};
      driver$3.validateOptions(options2, ["headers", "extensions", "maxLength", "ping", "proxy", "tls", "ca"]);
      this.readable = this.writable = true;
      var headers2 = options2.headers;
      if (headers2) {
        for (var name22 in headers2)
          this._driver.setHeader(name22, headers2[name22]);
      }
      var extensions = options2.extensions;
      if (extensions) {
        [].concat(extensions).forEach(this._driver.addExtension, this._driver);
      }
      this._ping = options2.ping;
      this._pingId = 0;
      this.readyState = API$3.CONNECTING;
      this.bufferedAmount = 0;
      this.protocol = "";
      this.url = this._driver.url;
      this.version = this._driver.version;
      var self2 = this;
      this._driver.on("open", function(e) {
        self2._open();
      });
      this._driver.on("message", function(e) {
        self2._receiveMessage(e.data);
      });
      this._driver.on("close", function(e) {
        self2._beginClose(e.reason, e.code);
      });
      this._driver.on("error", function(error22) {
        self2._emitError(error22.message);
      });
      this.on("error", function() {
      });
      this._driver.messages.on("drain", function() {
        self2.emit("drain");
      });
      if (this._ping)
        this._pingTimer = setInterval(function() {
          self2._pingId += 1;
          self2.ping(self2._pingId.toString());
        }, this._ping * 1e3);
      this._configureStream();
      if (!this._proxy) {
        this._stream.pipe(this._driver.io);
        this._driver.io.pipe(this._stream);
      }
    };
    util$3.inherits(API$3, Stream$1);
    API$3.CONNECTING = 0;
    API$3.OPEN = 1;
    API$3.CLOSING = 2;
    API$3.CLOSED = 3;
    API$3.CLOSE_TIMEOUT = 3e4;
    instance$1 = {
      write: function(data) {
        return this.send(data);
      },
      end: function(data) {
        if (data !== void 0)
          this.send(data);
        this.close();
      },
      pause: function() {
        return this._driver.messages.pause();
      },
      resume: function() {
        return this._driver.messages.resume();
      },
      send: function(data) {
        if (this.readyState > API$3.OPEN)
          return false;
        if (!(data instanceof Buffer))
          data = String(data);
        return this._driver.messages.write(data);
      },
      ping: function(message2, callback) {
        if (this.readyState > API$3.OPEN)
          return false;
        return this._driver.ping(message2, callback);
      },
      close: function(code, reason) {
        if (code === void 0)
          code = 1e3;
        if (reason === void 0)
          reason = "";
        if (code !== 1e3 && (code < 3e3 || code > 4999))
          throw new Error("Failed to execute 'close' on WebSocket: The code must be either 1000, or between 3000 and 4999. " + code + " is neither.");
        if (this.readyState < API$3.CLOSING) {
          var self2 = this;
          this._closeTimer = setTimeout(function() {
            self2._beginClose("", 1006);
          }, API$3.CLOSE_TIMEOUT);
        }
        if (this.readyState !== API$3.CLOSED)
          this.readyState = API$3.CLOSING;
        this._driver.close(reason, code);
      },
      _configureStream: function() {
        var self2 = this;
        this._stream.setTimeout(0);
        this._stream.setNoDelay(true);
        ["close", "end"].forEach(function(event2) {
          this._stream.on(event2, function() {
            self2._finalizeClose();
          });
        }, this);
        this._stream.on("error", function(error22) {
          self2._emitError("Network error: " + self2.url + ": " + error22.message);
          self2._finalizeClose();
        });
      },
      _open: function() {
        if (this.readyState !== API$3.CONNECTING)
          return;
        this.readyState = API$3.OPEN;
        this.protocol = this._driver.protocol || "";
        var event2 = new Event$1("open");
        event2.initEvent("open", false, false);
        this.dispatchEvent(event2);
      },
      _receiveMessage: function(data) {
        if (this.readyState > API$3.OPEN)
          return false;
        if (this.readable)
          this.emit("data", data);
        var event2 = new Event$1("message", { data });
        event2.initEvent("message", false, false);
        this.dispatchEvent(event2);
      },
      _emitError: function(message2) {
        if (this.readyState >= API$3.CLOSING)
          return;
        var event2 = new Event$1("error", { message: message2 });
        event2.initEvent("error", false, false);
        this.dispatchEvent(event2);
      },
      _beginClose: function(reason, code) {
        if (this.readyState === API$3.CLOSED)
          return;
        this.readyState = API$3.CLOSING;
        this._closeParams = [reason, code];
        if (this._stream) {
          this._stream.destroy();
          if (!this._stream.readable)
            this._finalizeClose();
        }
      },
      _finalizeClose: function() {
        if (this.readyState === API$3.CLOSED)
          return;
        this.readyState = API$3.CLOSED;
        if (this._closeTimer)
          clearTimeout(this._closeTimer);
        if (this._pingTimer)
          clearInterval(this._pingTimer);
        if (this._stream)
          this._stream.end();
        if (this.readable)
          this.emit("end");
        this.readable = this.writable = false;
        var reason = this._closeParams ? this._closeParams[0] : "", code = this._closeParams ? this._closeParams[1] : 1006;
        var event2 = new Event$1("close", { code, reason });
        event2.initEvent("close", false, false);
        this.dispatchEvent(event2);
      }
    };
    for (method$1 in instance$1)
      API$3.prototype[method$1] = instance$1[method$1];
    for (key$1 in EventTarget$1)
      API$3.prototype[key$1] = EventTarget$1[key$1];
    api = API$3;
    util$2 = import_util2.default;
    net = import_net.default;
    tls = import_tls.default;
    url = import_url2.default;
    driver$2 = driver$4;
    API$2 = api;
    DEFAULT_PORTS = { "http:": 80, "https:": 443, "ws:": 80, "wss:": 443 };
    SECURE_PROTOCOLS = ["https:", "wss:"];
    Client = function(_url, protocols, options2) {
      options2 = options2 || {};
      this.url = _url;
      this._driver = driver$2.client(this.url, { maxLength: options2.maxLength, protocols });
      ["open", "error"].forEach(function(event2) {
        this._driver.on(event2, function() {
          self2.headers = self2._driver.headers;
          self2.statusCode = self2._driver.statusCode;
        });
      }, this);
      var proxy2 = options2.proxy || {}, endpoint = url.parse(proxy2.origin || this.url), port = endpoint.port || DEFAULT_PORTS[endpoint.protocol], secure = SECURE_PROTOCOLS.indexOf(endpoint.protocol) >= 0, onConnect = function() {
        self2._onConnect();
      }, netOptions = options2.net || {}, originTLS = options2.tls || {}, socketTLS = proxy2.origin ? proxy2.tls || {} : originTLS, self2 = this;
      netOptions.host = socketTLS.host = endpoint.hostname;
      netOptions.port = socketTLS.port = port;
      originTLS.ca = originTLS.ca || options2.ca;
      socketTLS.servername = socketTLS.servername || endpoint.hostname;
      this._stream = secure ? tls.connect(socketTLS, onConnect) : net.connect(netOptions, onConnect);
      if (proxy2.origin)
        this._configureProxy(proxy2, originTLS);
      API$2.call(this, options2);
    };
    util$2.inherits(Client, API$2);
    Client.prototype._onConnect = function() {
      var worker = this._proxy || this._driver;
      worker.start();
    };
    Client.prototype._configureProxy = function(proxy2, originTLS) {
      var uri = url.parse(this.url), secure = SECURE_PROTOCOLS.indexOf(uri.protocol) >= 0, self2 = this, name22;
      this._proxy = this._driver.proxy(proxy2.origin);
      if (proxy2.headers) {
        for (name22 in proxy2.headers)
          this._proxy.setHeader(name22, proxy2.headers[name22]);
      }
      this._proxy.pipe(this._stream, { end: false });
      this._stream.pipe(this._proxy);
      this._proxy.on("connect", function() {
        if (secure) {
          var options2 = { socket: self2._stream, servername: uri.hostname };
          for (name22 in originTLS)
            options2[name22] = originTLS[name22];
          self2._stream = tls.connect(options2);
          self2._configureStream();
        }
        self2._driver.io.pipe(self2._stream);
        self2._stream.pipe(self2._driver.io);
        self2._driver.start();
      });
      this._proxy.on("error", function(error22) {
        self2._driver.emit("error", error22);
      });
    };
    client = Client;
    Stream2 = import_stream2.default.Stream;
    util$1 = import_util2.default;
    driver$1 = driver$4;
    Headers3 = headers;
    API$1 = api;
    EventTarget = event_target;
    Event3 = event;
    EventSource = function(request, response, options2) {
      this.writable = true;
      options2 = options2 || {};
      this._stream = response.socket;
      this._ping = options2.ping || this.DEFAULT_PING;
      this._retry = options2.retry || this.DEFAULT_RETRY;
      var scheme2 = driver$1.isSecureRequest(request) ? "https:" : "http:";
      this.url = scheme2 + "//" + request.headers.host + request.url;
      this.lastEventId = request.headers["last-event-id"] || "";
      this.readyState = API$1.CONNECTING;
      var headers2 = new Headers3(), self2 = this;
      if (options2.headers) {
        for (var key in options2.headers)
          headers2.set(key, options2.headers[key]);
      }
      if (!this._stream || !this._stream.writable)
        return;
      process.nextTick(function() {
        self2._open();
      });
      this._stream.setTimeout(0);
      this._stream.setNoDelay(true);
      var handshake = "HTTP/1.1 200 OK\r\nContent-Type: text/event-stream\r\nCache-Control: no-cache, no-store\r\nConnection: close\r\n" + headers2.toString() + "\r\nretry: " + Math.floor(this._retry * 1e3) + "\r\n\r\n";
      this._write(handshake);
      this._stream.on("drain", function() {
        self2.emit("drain");
      });
      if (this._ping)
        this._pingTimer = setInterval(function() {
          self2.ping();
        }, this._ping * 1e3);
      ["error", "end"].forEach(function(event2) {
        self2._stream.on(event2, function() {
          self2.close();
        });
      });
    };
    util$1.inherits(EventSource, Stream2);
    EventSource.isEventSource = function(request) {
      if (request.method !== "GET")
        return false;
      var accept = (request.headers.accept || "").split(/\s*,\s*/);
      return accept.indexOf("text/event-stream") >= 0;
    };
    instance = {
      DEFAULT_PING: 10,
      DEFAULT_RETRY: 5,
      _write: function(chunk) {
        if (!this.writable)
          return false;
        try {
          return this._stream.write(chunk, "utf8");
        } catch (e) {
          return false;
        }
      },
      _open: function() {
        if (this.readyState !== API$1.CONNECTING)
          return;
        this.readyState = API$1.OPEN;
        var event2 = new Event3("open");
        event2.initEvent("open", false, false);
        this.dispatchEvent(event2);
      },
      write: function(message2) {
        return this.send(message2);
      },
      end: function(message2) {
        if (message2 !== void 0)
          this.write(message2);
        this.close();
      },
      send: function(message2, options2) {
        if (this.readyState > API$1.OPEN)
          return false;
        message2 = String(message2).replace(/(\r\n|\r|\n)/g, "$1data: ");
        options2 = options2 || {};
        var frame2 = "";
        if (options2.event)
          frame2 += "event: " + options2.event + "\r\n";
        if (options2.id)
          frame2 += "id: " + options2.id + "\r\n";
        frame2 += "data: " + message2 + "\r\n\r\n";
        return this._write(frame2);
      },
      ping: function() {
        return this._write(":\r\n\r\n");
      },
      close: function() {
        if (this.readyState > API$1.OPEN)
          return false;
        this.readyState = API$1.CLOSED;
        this.writable = false;
        if (this._pingTimer)
          clearInterval(this._pingTimer);
        if (this._stream)
          this._stream.end();
        var event2 = new Event3("close");
        event2.initEvent("close", false, false);
        this.dispatchEvent(event2);
        return true;
      }
    };
    for (method in instance)
      EventSource.prototype[method] = instance[method];
    for (key in EventTarget)
      EventSource.prototype[key] = EventTarget[key];
    eventsource = EventSource;
    util = import_util2.default;
    driver = driver$4;
    API = api;
    WebSocket$1 = function(request, socket, body, protocols, options2) {
      options2 = options2 || {};
      this._stream = socket;
      this._driver = driver.http(request, { maxLength: options2.maxLength, protocols });
      var self2 = this;
      if (!this._stream || !this._stream.writable)
        return;
      if (!this._stream.readable)
        return this._stream.end();
      var catchup = function() {
        self2._stream.removeListener("data", catchup);
      };
      this._stream.on("data", catchup);
      API.call(this, options2);
      process.nextTick(function() {
        self2._driver.start();
        self2._driver.io.write(body);
      });
    };
    util.inherits(WebSocket$1, API);
    WebSocket$1.isWebSocket = function(request) {
      return driver.isWebSocket(request);
    };
    WebSocket$1.validateOptions = function(options2, validKeys) {
      driver.validateOptions(options2, validKeys);
    };
    WebSocket$1.WebSocket = WebSocket$1;
    WebSocket$1.Client = client;
    WebSocket$1.EventSource = eventsource;
    websocket = WebSocket$1;
    PROTOCOL_VERSION = "5";
    VERSION_PARAM = "v";
    TRANSPORT_SESSION_PARAM = "s";
    REFERER_PARAM = "r";
    FORGE_REF = "f";
    FORGE_DOMAIN_RE = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;
    LAST_SESSION_PARAM = "ls";
    APPLICATION_ID_PARAM = "p";
    APP_CHECK_TOKEN_PARAM = "ac";
    WEBSOCKET = "websocket";
    LONG_POLLING = "long_polling";
    DOMStorageWrapper = class {
      constructor(domStorage_) {
        this.domStorage_ = domStorage_;
        this.prefix_ = "firebase:";
      }
      set(key, value) {
        if (value == null) {
          this.domStorage_.removeItem(this.prefixedName_(key));
        } else {
          this.domStorage_.setItem(this.prefixedName_(key), stringify(value));
        }
      }
      get(key) {
        const storedVal = this.domStorage_.getItem(this.prefixedName_(key));
        if (storedVal == null) {
          return null;
        } else {
          return jsonEval(storedVal);
        }
      }
      remove(key) {
        this.domStorage_.removeItem(this.prefixedName_(key));
      }
      prefixedName_(name22) {
        return this.prefix_ + name22;
      }
      toString() {
        return this.domStorage_.toString();
      }
    };
    MemoryStorage = class {
      constructor() {
        this.cache_ = {};
        this.isInMemoryStorage = true;
      }
      set(key, value) {
        if (value == null) {
          delete this.cache_[key];
        } else {
          this.cache_[key] = value;
        }
      }
      get(key) {
        if (contains(this.cache_, key)) {
          return this.cache_[key];
        }
        return null;
      }
      remove(key) {
        delete this.cache_[key];
      }
    };
    createStoragefor = function(domStorageName) {
      try {
        if (typeof window !== "undefined" && typeof window[domStorageName] !== "undefined") {
          const domStorage = window[domStorageName];
          domStorage.setItem("firebase:sentinel", "cache");
          domStorage.removeItem("firebase:sentinel");
          return new DOMStorageWrapper(domStorage);
        }
      } catch (e) {
      }
      return new MemoryStorage();
    };
    PersistentStorage = createStoragefor("localStorage");
    SessionStorage = createStoragefor("sessionStorage");
    logClient2 = new Logger("@firebase/database");
    LUIDGenerator = function() {
      let id2 = 1;
      return function() {
        return id2++;
      };
    }();
    sha1 = function(str) {
      const utf8Bytes = stringToByteArray(str);
      const sha12 = new Sha1();
      sha12.update(utf8Bytes);
      const sha1Bytes = sha12.digest();
      return base64.encodeByteArray(sha1Bytes);
    };
    buildLogMessage_ = function(...varArgs) {
      let message2 = "";
      for (let i = 0; i < varArgs.length; i++) {
        const arg = varArgs[i];
        if (Array.isArray(arg) || arg && typeof arg === "object" && typeof arg.length === "number") {
          message2 += buildLogMessage_.apply(null, arg);
        } else if (typeof arg === "object") {
          message2 += stringify(arg);
        } else {
          message2 += arg;
        }
        message2 += " ";
      }
      return message2;
    };
    logger2 = null;
    firstLog_ = true;
    enableLogging$1 = function(logger_, persistent) {
      assert(!persistent || logger_ === true || logger_ === false, "Can't turn on custom loggers persistently.");
      if (logger_ === true) {
        logClient2.logLevel = LogLevel.VERBOSE;
        logger2 = logClient2.log.bind(logClient2);
        if (persistent) {
          SessionStorage.set("logging_enabled", true);
        }
      } else if (typeof logger_ === "function") {
        logger2 = logger_;
      } else {
        logger2 = null;
        SessionStorage.remove("logging_enabled");
      }
    };
    log = function(...varArgs) {
      if (firstLog_ === true) {
        firstLog_ = false;
        if (logger2 === null && SessionStorage.get("logging_enabled") === true) {
          enableLogging$1(true);
        }
      }
      if (logger2) {
        const message2 = buildLogMessage_.apply(null, varArgs);
        logger2(message2);
      }
    };
    logWrapper = function(prefix) {
      return function(...varArgs) {
        log(prefix, ...varArgs);
      };
    };
    error = function(...varArgs) {
      const message2 = "FIREBASE INTERNAL ERROR: " + buildLogMessage_(...varArgs);
      logClient2.error(message2);
    };
    fatal = function(...varArgs) {
      const message2 = `FIREBASE FATAL ERROR: ${buildLogMessage_(...varArgs)}`;
      logClient2.error(message2);
      throw new Error(message2);
    };
    warn = function(...varArgs) {
      const message2 = "FIREBASE WARNING: " + buildLogMessage_(...varArgs);
      logClient2.warn(message2);
    };
    warnIfPageIsSecure = function() {
      if (typeof window !== "undefined" && window.location && window.location.protocol && window.location.protocol.indexOf("https:") !== -1) {
        warn("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
      }
    };
    isInvalidJSONNumber = function(data) {
      return typeof data === "number" && (data !== data || data === Number.POSITIVE_INFINITY || data === Number.NEGATIVE_INFINITY);
    };
    executeWhenDOMReady = function(fn2) {
      if (isNodeSdk() || document.readyState === "complete") {
        fn2();
      } else {
        let called = false;
        const wrappedFn = function() {
          if (!document.body) {
            setTimeout(wrappedFn, Math.floor(10));
            return;
          }
          if (!called) {
            called = true;
            fn2();
          }
        };
        if (document.addEventListener) {
          document.addEventListener("DOMContentLoaded", wrappedFn, false);
          window.addEventListener("load", wrappedFn, false);
        } else if (document.attachEvent) {
          document.attachEvent("onreadystatechange", () => {
            if (document.readyState === "complete") {
              wrappedFn();
            }
          });
          window.attachEvent("onload", wrappedFn);
        }
      }
    };
    MIN_NAME = "[MIN_NAME]";
    MAX_NAME = "[MAX_NAME]";
    nameCompare = function(a, b) {
      if (a === b) {
        return 0;
      } else if (a === MIN_NAME || b === MAX_NAME) {
        return -1;
      } else if (b === MIN_NAME || a === MAX_NAME) {
        return 1;
      } else {
        const aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);
        if (aAsInt !== null) {
          if (bAsInt !== null) {
            return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;
          } else {
            return -1;
          }
        } else if (bAsInt !== null) {
          return 1;
        } else {
          return a < b ? -1 : 1;
        }
      }
    };
    stringCompare = function(a, b) {
      if (a === b) {
        return 0;
      } else if (a < b) {
        return -1;
      } else {
        return 1;
      }
    };
    requireKey = function(key, obj) {
      if (obj && key in obj) {
        return obj[key];
      } else {
        throw new Error("Missing required key (" + key + ") in object: " + stringify(obj));
      }
    };
    ObjectToUniqueKey = function(obj) {
      if (typeof obj !== "object" || obj === null) {
        return stringify(obj);
      }
      const keys = [];
      for (const k2 in obj) {
        keys.push(k2);
      }
      keys.sort();
      let key = "{";
      for (let i = 0; i < keys.length; i++) {
        if (i !== 0) {
          key += ",";
        }
        key += stringify(keys[i]);
        key += ":";
        key += ObjectToUniqueKey(obj[keys[i]]);
      }
      key += "}";
      return key;
    };
    splitStringBySize = function(str, segsize) {
      const len = str.length;
      if (len <= segsize) {
        return [str];
      }
      const dataSegs = [];
      for (let c = 0; c < len; c += segsize) {
        if (c + segsize > len) {
          dataSegs.push(str.substring(c, len));
        } else {
          dataSegs.push(str.substring(c, c + segsize));
        }
      }
      return dataSegs;
    };
    doubleToIEEE754String = function(v2) {
      assert(!isInvalidJSONNumber(v2), "Invalid JSON number");
      const ebits = 11, fbits = 52;
      const bias = (1 << ebits - 1) - 1;
      let s2, e, f, ln2, i;
      if (v2 === 0) {
        e = 0;
        f = 0;
        s2 = 1 / v2 === -Infinity ? 1 : 0;
      } else {
        s2 = v2 < 0;
        v2 = Math.abs(v2);
        if (v2 >= Math.pow(2, 1 - bias)) {
          ln2 = Math.min(Math.floor(Math.log(v2) / Math.LN2), bias);
          e = ln2 + bias;
          f = Math.round(v2 * Math.pow(2, fbits - ln2) - Math.pow(2, fbits));
        } else {
          e = 0;
          f = Math.round(v2 / Math.pow(2, 1 - bias - fbits));
        }
      }
      const bits = [];
      for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = Math.floor(f / 2);
      }
      for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = Math.floor(e / 2);
      }
      bits.push(s2 ? 1 : 0);
      bits.reverse();
      const str = bits.join("");
      let hexByteString = "";
      for (i = 0; i < 64; i += 8) {
        let hexByte = parseInt(str.substr(i, 8), 2).toString(16);
        if (hexByte.length === 1) {
          hexByte = "0" + hexByte;
        }
        hexByteString = hexByteString + hexByte;
      }
      return hexByteString.toLowerCase();
    };
    isChromeExtensionContentScript = function() {
      return !!(typeof window === "object" && window["chrome"] && window["chrome"]["extension"] && !/^chrome/.test(window.location.href));
    };
    isWindowsStoreApp = function() {
      return typeof Windows === "object" && typeof Windows.UI === "object";
    };
    INTEGER_REGEXP_ = new RegExp("^-?(0*)\\d{1,10}$");
    INTEGER_32_MIN = -2147483648;
    INTEGER_32_MAX = 2147483647;
    tryParseInt = function(str) {
      if (INTEGER_REGEXP_.test(str)) {
        const intVal = Number(str);
        if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) {
          return intVal;
        }
      }
      return null;
    };
    exceptionGuard = function(fn2) {
      try {
        fn2();
      } catch (e) {
        setTimeout(() => {
          const stack = e.stack || "";
          warn("Exception was thrown by user callback.", stack);
          throw e;
        }, Math.floor(0));
      }
    };
    beingCrawled = function() {
      const userAgent = typeof window === "object" && window["navigator"] && window["navigator"]["userAgent"] || "";
      return userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0;
    };
    setTimeoutNonBlocking = function(fn2, time) {
      const timeout = setTimeout(fn2, time);
      if (typeof timeout === "object" && timeout["unref"]) {
        timeout["unref"]();
      }
      return timeout;
    };
    RepoInfo = class {
      constructor(host, secure, namespace, webSocketOnly, nodeAdmin = false, persistenceKey = "", includeNamespaceInQueryParams = false) {
        this.secure = secure;
        this.namespace = namespace;
        this.webSocketOnly = webSocketOnly;
        this.nodeAdmin = nodeAdmin;
        this.persistenceKey = persistenceKey;
        this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;
        this._host = host.toLowerCase();
        this._domain = this._host.substr(this._host.indexOf(".") + 1);
        this.internalHost = PersistentStorage.get("host:" + host) || this._host;
      }
      isCacheableHost() {
        return this.internalHost.substr(0, 2) === "s-";
      }
      isCustomHost() {
        return this._domain !== "firebaseio.com" && this._domain !== "firebaseio-demo.com";
      }
      get host() {
        return this._host;
      }
      set host(newHost) {
        if (newHost !== this.internalHost) {
          this.internalHost = newHost;
          if (this.isCacheableHost()) {
            PersistentStorage.set("host:" + this._host, this.internalHost);
          }
        }
      }
      toString() {
        let str = this.toURLString();
        if (this.persistenceKey) {
          str += "<" + this.persistenceKey + ">";
        }
        return str;
      }
      toURLString() {
        const protocol = this.secure ? "https://" : "http://";
        const query = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : "";
        return `${protocol}${this.host}/${query}`;
      }
    };
    StatsCollection = class {
      constructor() {
        this.counters_ = {};
      }
      incrementCounter(name22, amount = 1) {
        if (!contains(this.counters_, name22)) {
          this.counters_[name22] = 0;
        }
        this.counters_[name22] += amount;
      }
      get() {
        return deepCopy(this.counters_);
      }
    };
    collections = {};
    reporters = {};
    SDK_VERSION2 = "";
    WEBSOCKET_MAX_FRAME_SIZE = 16384;
    WEBSOCKET_KEEPALIVE_INTERVAL = 45e3;
    WebSocketImpl = null;
    if (typeof MozWebSocket !== "undefined") {
      WebSocketImpl = MozWebSocket;
    } else if (typeof WebSocket !== "undefined") {
      WebSocketImpl = WebSocket;
    }
    WebSocketConnection = class {
      constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.applicationId = applicationId;
        this.appCheckToken = appCheckToken;
        this.authToken = authToken;
        this.keepaliveTimer = null;
        this.frames = null;
        this.totalFrames = 0;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.log_ = logWrapper(this.connId);
        this.stats_ = statsManagerGetCollection(repoInfo);
        this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken);
        this.nodeAdmin = repoInfo.nodeAdmin;
      }
      static connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken) {
        const urlParams = {};
        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
        if (!isNodeSdk() && typeof location !== "undefined" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {
          urlParams[REFERER_PARAM] = FORGE_REF;
        }
        if (transportSessionId) {
          urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;
        }
        if (lastSessionId) {
          urlParams[LAST_SESSION_PARAM] = lastSessionId;
        }
        if (appCheckToken) {
          urlParams[APP_CHECK_TOKEN_PARAM] = appCheckToken;
        }
        return repoInfoConnectionURL(repoInfo, WEBSOCKET, urlParams);
      }
      open(onMessage, onDisconnect) {
        this.onDisconnect = onDisconnect;
        this.onMessage = onMessage;
        this.log_("Websocket connecting to " + this.connURL);
        this.everConnected_ = false;
        PersistentStorage.set("previous_websocket_failure", true);
        try {
          if (isNodeSdk()) {
            const device = this.nodeAdmin ? "AdminNode" : "Node";
            const options2 = {
              headers: {
                "User-Agent": `Firebase/${PROTOCOL_VERSION}/${SDK_VERSION2}/${process.platform}/${device}`,
                "X-Firebase-GMPID": this.applicationId || ""
              }
            };
            if (this.authToken) {
              options2.headers["Authorization"] = `Bearer ${this.authToken}`;
            }
            if (this.appCheckToken) {
              options2.headers["X-Firebase-AppCheck"] = this.appCheckToken;
            }
            const env = process["env"];
            const proxy2 = this.connURL.indexOf("wss://") === 0 ? env["HTTPS_PROXY"] || env["https_proxy"] : env["HTTP_PROXY"] || env["http_proxy"];
            if (proxy2) {
              options2["proxy"] = { origin: proxy2 };
            }
            this.mySock = new WebSocketImpl(this.connURL, [], options2);
          } else {
            const options2 = {
              headers: {
                "X-Firebase-GMPID": this.applicationId || "",
                "X-Firebase-AppCheck": this.appCheckToken || ""
              }
            };
            this.mySock = new WebSocketImpl(this.connURL, [], options2);
          }
        } catch (e) {
          this.log_("Error instantiating WebSocket.");
          const error22 = e.message || e.data;
          if (error22) {
            this.log_(error22);
          }
          this.onClosed_();
          return;
        }
        this.mySock.onopen = () => {
          this.log_("Websocket connected.");
          this.everConnected_ = true;
        };
        this.mySock.onclose = () => {
          this.log_("Websocket connection was disconnected.");
          this.mySock = null;
          this.onClosed_();
        };
        this.mySock.onmessage = (m) => {
          this.handleIncomingFrame(m);
        };
        this.mySock.onerror = (e) => {
          this.log_("WebSocket error.  Closing connection.");
          const error22 = e.message || e.data;
          if (error22) {
            this.log_(error22);
          }
          this.onClosed_();
        };
      }
      start() {
      }
      static forceDisallow() {
        WebSocketConnection.forceDisallow_ = true;
      }
      static isAvailable() {
        let isOldAndroid = false;
        if (typeof navigator !== "undefined" && navigator.userAgent) {
          const oldAndroidRegex = /Android ([0-9]{0,}\.[0-9]{0,})/;
          const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);
          if (oldAndroidMatch && oldAndroidMatch.length > 1) {
            if (parseFloat(oldAndroidMatch[1]) < 4.4) {
              isOldAndroid = true;
            }
          }
        }
        return !isOldAndroid && WebSocketImpl !== null && !WebSocketConnection.forceDisallow_;
      }
      static previouslyFailed() {
        return PersistentStorage.isInMemoryStorage || PersistentStorage.get("previous_websocket_failure") === true;
      }
      markConnectionHealthy() {
        PersistentStorage.remove("previous_websocket_failure");
      }
      appendFrame_(data) {
        this.frames.push(data);
        if (this.frames.length === this.totalFrames) {
          const fullMess = this.frames.join("");
          this.frames = null;
          const jsonMess = jsonEval(fullMess);
          this.onMessage(jsonMess);
        }
      }
      handleNewFrameCount_(frameCount) {
        this.totalFrames = frameCount;
        this.frames = [];
      }
      extractFrameCount_(data) {
        assert(this.frames === null, "We already have a frame buffer");
        if (data.length <= 6) {
          const frameCount = Number(data);
          if (!isNaN(frameCount)) {
            this.handleNewFrameCount_(frameCount);
            return null;
          }
        }
        this.handleNewFrameCount_(1);
        return data;
      }
      handleIncomingFrame(mess) {
        if (this.mySock === null) {
          return;
        }
        const data = mess["data"];
        this.bytesReceived += data.length;
        this.stats_.incrementCounter("bytes_received", data.length);
        this.resetKeepAlive();
        if (this.frames !== null) {
          this.appendFrame_(data);
        } else {
          const remainingData = this.extractFrameCount_(data);
          if (remainingData !== null) {
            this.appendFrame_(remainingData);
          }
        }
      }
      send(data) {
        this.resetKeepAlive();
        const dataStr = stringify(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter("bytes_sent", dataStr.length);
        const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);
        if (dataSegs.length > 1) {
          this.sendString_(String(dataSegs.length));
        }
        for (let i = 0; i < dataSegs.length; i++) {
          this.sendString_(dataSegs[i]);
        }
      }
      shutdown_() {
        this.isClosed_ = true;
        if (this.keepaliveTimer) {
          clearInterval(this.keepaliveTimer);
          this.keepaliveTimer = null;
        }
        if (this.mySock) {
          this.mySock.close();
          this.mySock = null;
        }
      }
      onClosed_() {
        if (!this.isClosed_) {
          this.log_("WebSocket is closing itself");
          this.shutdown_();
          if (this.onDisconnect) {
            this.onDisconnect(this.everConnected_);
            this.onDisconnect = null;
          }
        }
      }
      close() {
        if (!this.isClosed_) {
          this.log_("WebSocket is being closed");
          this.shutdown_();
        }
      }
      resetKeepAlive() {
        clearInterval(this.keepaliveTimer);
        this.keepaliveTimer = setInterval(() => {
          if (this.mySock) {
            this.sendString_("0");
          }
          this.resetKeepAlive();
        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));
      }
      sendString_(str) {
        try {
          this.mySock.send(str);
        } catch (e) {
          this.log_("Exception thrown from WebSocket.send():", e.message || e.data, "Closing connection.");
          setTimeout(this.onClosed_.bind(this), 0);
        }
      }
    };
    WebSocketConnection.responsesRequiredToBeHealthy = 2;
    WebSocketConnection.healthyTimeout = 3e4;
    name5 = "@firebase/database";
    version5 = "0.12.4";
    AppCheckTokenProvider = class {
      constructor(appName_, appCheckProvider) {
        this.appName_ = appName_;
        this.appCheckProvider = appCheckProvider;
        this.appCheck = appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.getImmediate({ optional: true });
        if (!this.appCheck) {
          appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.get().then((appCheck) => this.appCheck = appCheck);
        }
      }
      getToken(forceRefresh) {
        if (!this.appCheck) {
          return new Promise((resolve2, reject2) => {
            setTimeout(() => {
              if (this.appCheck) {
                this.getToken(forceRefresh).then(resolve2, reject2);
              } else {
                resolve2(null);
              }
            }, 0);
          });
        }
        return this.appCheck.getToken(forceRefresh);
      }
      addTokenChangeListener(listener) {
        var _a2;
        (_a2 = this.appCheckProvider) === null || _a2 === void 0 ? void 0 : _a2.get().then((appCheck) => appCheck.addTokenListener(listener));
      }
      notifyForInvalidToken() {
        warn(`Provided AppCheck credentials for the app named "${this.appName_}" are invalid. This usually indicates your app was not initialized correctly.`);
      }
    };
    FirebaseAuthTokenProvider = class {
      constructor(appName_, firebaseOptions_, authProvider_) {
        this.appName_ = appName_;
        this.firebaseOptions_ = firebaseOptions_;
        this.authProvider_ = authProvider_;
        this.auth_ = null;
        this.auth_ = authProvider_.getImmediate({ optional: true });
        if (!this.auth_) {
          authProvider_.onInit((auth) => this.auth_ = auth);
        }
      }
      getToken(forceRefresh) {
        if (!this.auth_) {
          return new Promise((resolve2, reject2) => {
            setTimeout(() => {
              if (this.auth_) {
                this.getToken(forceRefresh).then(resolve2, reject2);
              } else {
                resolve2(null);
              }
            }, 0);
          });
        }
        return this.auth_.getToken(forceRefresh).catch((error22) => {
          if (error22 && error22.code === "auth/token-not-initialized") {
            log("Got auth/token-not-initialized error.  Treating as null token.");
            return null;
          } else {
            return Promise.reject(error22);
          }
        });
      }
      addTokenChangeListener(listener) {
        if (this.auth_) {
          this.auth_.addAuthTokenListener(listener);
        } else {
          this.authProvider_.get().then((auth) => auth.addAuthTokenListener(listener));
        }
      }
      removeTokenChangeListener(listener) {
        this.authProvider_.get().then((auth) => auth.removeAuthTokenListener(listener));
      }
      notifyForInvalidToken() {
        let errorMessage = 'Provided authentication credentials for the app named "' + this.appName_ + '" are invalid. This usually indicates your app was not initialized correctly. ';
        if ("credential" in this.firebaseOptions_) {
          errorMessage += 'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.';
        } else if ("serviceAccount" in this.firebaseOptions_) {
          errorMessage += 'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.';
        } else {
          errorMessage += 'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.';
        }
        warn(errorMessage);
      }
    };
    EmulatorTokenProvider = class {
      constructor(accessToken) {
        this.accessToken = accessToken;
      }
      getToken(forceRefresh) {
        return Promise.resolve({
          accessToken: this.accessToken
        });
      }
      addTokenChangeListener(listener) {
        listener(this.accessToken);
      }
      removeTokenChangeListener(listener) {
      }
      notifyForInvalidToken() {
      }
    };
    EmulatorTokenProvider.OWNER = "owner";
    PacketReceiver = class {
      constructor(onMessage_) {
        this.onMessage_ = onMessage_;
        this.pendingResponses = [];
        this.currentResponseNum = 0;
        this.closeAfterResponse = -1;
        this.onClose = null;
      }
      closeAfter(responseNum, callback) {
        this.closeAfterResponse = responseNum;
        this.onClose = callback;
        if (this.closeAfterResponse < this.currentResponseNum) {
          this.onClose();
          this.onClose = null;
        }
      }
      handleResponse(requestNum, data) {
        this.pendingResponses[requestNum] = data;
        while (this.pendingResponses[this.currentResponseNum]) {
          const toProcess = this.pendingResponses[this.currentResponseNum];
          delete this.pendingResponses[this.currentResponseNum];
          for (let i = 0; i < toProcess.length; ++i) {
            if (toProcess[i]) {
              exceptionGuard(() => {
                this.onMessage_(toProcess[i]);
              });
            }
          }
          if (this.currentResponseNum === this.closeAfterResponse) {
            if (this.onClose) {
              this.onClose();
              this.onClose = null;
            }
            break;
          }
          this.currentResponseNum++;
        }
      }
    };
    FIREBASE_LONGPOLL_START_PARAM = "start";
    FIREBASE_LONGPOLL_CLOSE_COMMAND = "close";
    FIREBASE_LONGPOLL_COMMAND_CB_NAME = "pLPCommand";
    FIREBASE_LONGPOLL_DATA_CB_NAME = "pRTLPCB";
    FIREBASE_LONGPOLL_ID_PARAM = "id";
    FIREBASE_LONGPOLL_PW_PARAM = "pw";
    FIREBASE_LONGPOLL_SERIAL_PARAM = "ser";
    FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = "cb";
    FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = "seg";
    FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = "ts";
    FIREBASE_LONGPOLL_DATA_PARAM = "d";
    FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = "dframe";
    MAX_URL_DATA_SIZE = 1870;
    SEG_HEADER_SIZE = 30;
    MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;
    KEEPALIVE_REQUEST_INTERVAL = 25e3;
    LP_CONNECT_TIMEOUT = 3e4;
    BrowserPollConnection = class {
      constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.repoInfo = repoInfo;
        this.applicationId = applicationId;
        this.appCheckToken = appCheckToken;
        this.authToken = authToken;
        this.transportSessionId = transportSessionId;
        this.lastSessionId = lastSessionId;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.everConnected_ = false;
        this.log_ = logWrapper(connId);
        this.stats_ = statsManagerGetCollection(repoInfo);
        this.urlFn = (params) => {
          if (this.appCheckToken) {
            params[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;
          }
          return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);
        };
      }
      open(onMessage, onDisconnect) {
        this.curSegmentNum = 0;
        this.onDisconnect_ = onDisconnect;
        this.myPacketOrderer = new PacketReceiver(onMessage);
        this.isClosed_ = false;
        this.connectTimeoutTimer_ = setTimeout(() => {
          this.log_("Timed out trying to connect.");
          this.onClosed_();
          this.connectTimeoutTimer_ = null;
        }, Math.floor(LP_CONNECT_TIMEOUT));
        executeWhenDOMReady(() => {
          if (this.isClosed_) {
            return;
          }
          this.scriptTagHolder = new FirebaseIFrameScriptHolder((...args) => {
            const [command, arg1, arg2, arg3, arg4] = args;
            this.incrementIncomingBytes_(args);
            if (!this.scriptTagHolder) {
              return;
            }
            if (this.connectTimeoutTimer_) {
              clearTimeout(this.connectTimeoutTimer_);
              this.connectTimeoutTimer_ = null;
            }
            this.everConnected_ = true;
            if (command === FIREBASE_LONGPOLL_START_PARAM) {
              this.id = arg1;
              this.password = arg2;
            } else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {
              if (arg1) {
                this.scriptTagHolder.sendNewPolls = false;
                this.myPacketOrderer.closeAfter(arg1, () => {
                  this.onClosed_();
                });
              } else {
                this.onClosed_();
              }
            } else {
              throw new Error("Unrecognized command received: " + command);
            }
          }, (...args) => {
            const [pN, data] = args;
            this.incrementIncomingBytes_(args);
            this.myPacketOrderer.handleResponse(pN, data);
          }, () => {
            this.onClosed_();
          }, this.urlFn);
          const urlParams = {};
          urlParams[FIREBASE_LONGPOLL_START_PARAM] = "t";
          urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 1e8);
          if (this.scriptTagHolder.uniqueCallbackIdentifier) {
            urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = this.scriptTagHolder.uniqueCallbackIdentifier;
          }
          urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
          if (this.transportSessionId) {
            urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;
          }
          if (this.lastSessionId) {
            urlParams[LAST_SESSION_PARAM] = this.lastSessionId;
          }
          if (this.applicationId) {
            urlParams[APPLICATION_ID_PARAM] = this.applicationId;
          }
          if (this.appCheckToken) {
            urlParams[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;
          }
          if (typeof location !== "undefined" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {
            urlParams[REFERER_PARAM] = FORGE_REF;
          }
          const connectURL = this.urlFn(urlParams);
          this.log_("Connecting via long-poll to " + connectURL);
          this.scriptTagHolder.addTag(connectURL, () => {
          });
        });
      }
      start() {
        this.scriptTagHolder.startLongPoll(this.id, this.password);
        this.addDisconnectPingFrame(this.id, this.password);
      }
      static forceAllow() {
        BrowserPollConnection.forceAllow_ = true;
      }
      static forceDisallow() {
        BrowserPollConnection.forceDisallow_ = true;
      }
      static isAvailable() {
        if (isNodeSdk()) {
          return false;
        } else if (BrowserPollConnection.forceAllow_) {
          return true;
        } else {
          return !BrowserPollConnection.forceDisallow_ && typeof document !== "undefined" && document.createElement != null && !isChromeExtensionContentScript() && !isWindowsStoreApp();
        }
      }
      markConnectionHealthy() {
      }
      shutdown_() {
        this.isClosed_ = true;
        if (this.scriptTagHolder) {
          this.scriptTagHolder.close();
          this.scriptTagHolder = null;
        }
        if (this.myDisconnFrame) {
          document.body.removeChild(this.myDisconnFrame);
          this.myDisconnFrame = null;
        }
        if (this.connectTimeoutTimer_) {
          clearTimeout(this.connectTimeoutTimer_);
          this.connectTimeoutTimer_ = null;
        }
      }
      onClosed_() {
        if (!this.isClosed_) {
          this.log_("Longpoll is closing itself");
          this.shutdown_();
          if (this.onDisconnect_) {
            this.onDisconnect_(this.everConnected_);
            this.onDisconnect_ = null;
          }
        }
      }
      close() {
        if (!this.isClosed_) {
          this.log_("Longpoll is being closed.");
          this.shutdown_();
        }
      }
      send(data) {
        const dataStr = stringify(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter("bytes_sent", dataStr.length);
        const base64data = base64Encode(dataStr);
        const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);
        for (let i = 0; i < dataSegs.length; i++) {
          this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);
          this.curSegmentNum++;
        }
      }
      addDisconnectPingFrame(id2, pw) {
        if (isNodeSdk()) {
          return;
        }
        this.myDisconnFrame = document.createElement("iframe");
        const urlParams = {};
        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = "t";
        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id2;
        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;
        this.myDisconnFrame.src = this.urlFn(urlParams);
        this.myDisconnFrame.style.display = "none";
        document.body.appendChild(this.myDisconnFrame);
      }
      incrementIncomingBytes_(args) {
        const bytesReceived = stringify(args).length;
        this.bytesReceived += bytesReceived;
        this.stats_.incrementCounter("bytes_received", bytesReceived);
      }
    };
    FirebaseIFrameScriptHolder = class {
      constructor(commandCB, onMessageCB, onDisconnect, urlFn) {
        this.onDisconnect = onDisconnect;
        this.urlFn = urlFn;
        this.outstandingRequests = new Set();
        this.pendingSegs = [];
        this.currentSerial = Math.floor(Math.random() * 1e8);
        this.sendNewPolls = true;
        if (!isNodeSdk()) {
          this.uniqueCallbackIdentifier = LUIDGenerator();
          window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;
          window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;
          this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();
          let script = "";
          if (this.myIFrame.src && this.myIFrame.src.substr(0, "javascript:".length) === "javascript:") {
            const currentDomain = document.domain;
            script = '<script>document.domain="' + currentDomain + '";<\/script>';
          }
          const iframeContents = "<html><body>" + script + "</body></html>";
          try {
            this.myIFrame.doc.open();
            this.myIFrame.doc.write(iframeContents);
            this.myIFrame.doc.close();
          } catch (e) {
            log("frame writing exception");
            if (e.stack) {
              log(e.stack);
            }
            log(e);
          }
        } else {
          this.commandCB = commandCB;
          this.onMessageCB = onMessageCB;
        }
      }
      static createIFrame_() {
        const iframe = document.createElement("iframe");
        iframe.style.display = "none";
        if (document.body) {
          document.body.appendChild(iframe);
          try {
            const a = iframe.contentWindow.document;
            if (!a) {
              log("No IE domain setting required");
            }
          } catch (e) {
            const domain = document.domain;
            iframe.src = "javascript:void((function(){document.open();document.domain='" + domain + "';document.close();})())";
          }
        } else {
          throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
        }
        if (iframe.contentDocument) {
          iframe.doc = iframe.contentDocument;
        } else if (iframe.contentWindow) {
          iframe.doc = iframe.contentWindow.document;
        } else if (iframe.document) {
          iframe.doc = iframe.document;
        }
        return iframe;
      }
      close() {
        this.alive = false;
        if (this.myIFrame) {
          this.myIFrame.doc.body.innerHTML = "";
          setTimeout(() => {
            if (this.myIFrame !== null) {
              document.body.removeChild(this.myIFrame);
              this.myIFrame = null;
            }
          }, Math.floor(0));
        }
        const onDisconnect = this.onDisconnect;
        if (onDisconnect) {
          this.onDisconnect = null;
          onDisconnect();
        }
      }
      startLongPoll(id2, pw) {
        this.myID = id2;
        this.myPW = pw;
        this.alive = true;
        while (this.newRequest_()) {
        }
      }
      newRequest_() {
        if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {
          this.currentSerial++;
          const urlParams = {};
          urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
          urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
          urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;
          let theURL = this.urlFn(urlParams);
          let curDataString = "";
          let i = 0;
          while (this.pendingSegs.length > 0) {
            const nextSeg = this.pendingSegs[0];
            if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <= MAX_URL_DATA_SIZE) {
              const theSeg = this.pendingSegs.shift();
              curDataString = curDataString + "&" + FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM + i + "=" + theSeg.seg + "&" + FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET + i + "=" + theSeg.ts + "&" + FIREBASE_LONGPOLL_DATA_PARAM + i + "=" + theSeg.d;
              i++;
            } else {
              break;
            }
          }
          theURL = theURL + curDataString;
          this.addLongPollTag_(theURL, this.currentSerial);
          return true;
        } else {
          return false;
        }
      }
      enqueueSegment(segnum, totalsegs, data) {
        this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });
        if (this.alive) {
          this.newRequest_();
        }
      }
      addLongPollTag_(url2, serial) {
        this.outstandingRequests.add(serial);
        const doNewRequest = () => {
          this.outstandingRequests.delete(serial);
          this.newRequest_();
        };
        const keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));
        const readyStateCB = () => {
          clearTimeout(keepaliveTimeout);
          doNewRequest();
        };
        this.addTag(url2, readyStateCB);
      }
      addTag(url2, loadCB) {
        if (isNodeSdk()) {
          this.doNodeLongPoll(url2, loadCB);
        } else {
          setTimeout(() => {
            try {
              if (!this.sendNewPolls) {
                return;
              }
              const newScript = this.myIFrame.doc.createElement("script");
              newScript.type = "text/javascript";
              newScript.async = true;
              newScript.src = url2;
              newScript.onload = newScript.onreadystatechange = function() {
                const rstate = newScript.readyState;
                if (!rstate || rstate === "loaded" || rstate === "complete") {
                  newScript.onload = newScript.onreadystatechange = null;
                  if (newScript.parentNode) {
                    newScript.parentNode.removeChild(newScript);
                  }
                  loadCB();
                }
              };
              newScript.onerror = () => {
                log("Long-poll script failed to load: " + url2);
                this.sendNewPolls = false;
                this.close();
              };
              this.myIFrame.doc.body.appendChild(newScript);
            } catch (e) {
            }
          }, Math.floor(1));
        }
      }
    };
    TransportManager = class {
      constructor(repoInfo) {
        this.initTransports_(repoInfo);
      }
      static get ALL_TRANSPORTS() {
        return [BrowserPollConnection, WebSocketConnection];
      }
      initTransports_(repoInfo) {
        const isWebSocketsAvailable = WebSocketConnection && WebSocketConnection["isAvailable"]();
        let isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();
        if (repoInfo.webSocketOnly) {
          if (!isWebSocketsAvailable) {
            warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");
          }
          isSkipPollConnection = true;
        }
        if (isSkipPollConnection) {
          this.transports_ = [WebSocketConnection];
        } else {
          const transports = this.transports_ = [];
          for (const transport of TransportManager.ALL_TRANSPORTS) {
            if (transport && transport["isAvailable"]()) {
              transports.push(transport);
            }
          }
        }
      }
      initialTransport() {
        if (this.transports_.length > 0) {
          return this.transports_[0];
        } else {
          throw new Error("No transports available");
        }
      }
      upgradeTransport() {
        if (this.transports_.length > 1) {
          return this.transports_[1];
        } else {
          return null;
        }
      }
    };
    UPGRADE_TIMEOUT = 6e4;
    DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5e3;
    BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;
    BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;
    MESSAGE_TYPE = "t";
    MESSAGE_DATA = "d";
    CONTROL_SHUTDOWN = "s";
    CONTROL_RESET = "r";
    CONTROL_ERROR = "e";
    CONTROL_PONG = "o";
    SWITCH_ACK = "a";
    END_TRANSMISSION = "n";
    PING = "p";
    SERVER_HELLO = "h";
    Connection = class {
      constructor(id2, repoInfo_, applicationId_, appCheckToken_, authToken_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {
        this.id = id2;
        this.repoInfo_ = repoInfo_;
        this.applicationId_ = applicationId_;
        this.appCheckToken_ = appCheckToken_;
        this.authToken_ = authToken_;
        this.onMessage_ = onMessage_;
        this.onReady_ = onReady_;
        this.onDisconnect_ = onDisconnect_;
        this.onKill_ = onKill_;
        this.lastSessionId = lastSessionId;
        this.connectionCount = 0;
        this.pendingDataMessages = [];
        this.state_ = 0;
        this.log_ = logWrapper("c:" + this.id + ":");
        this.transportManager_ = new TransportManager(repoInfo_);
        this.log_("Connection created");
        this.start_();
      }
      start_() {
        const conn = this.transportManager_.initialTransport();
        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId);
        this.primaryResponsesRequired_ = conn["responsesRequiredToBeHealthy"] || 0;
        const onMessageReceived = this.connReceiver_(this.conn_);
        const onConnectionLost = this.disconnReceiver_(this.conn_);
        this.tx_ = this.conn_;
        this.rx_ = this.conn_;
        this.secondaryConn_ = null;
        this.isHealthy_ = false;
        setTimeout(() => {
          this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);
        }, Math.floor(0));
        const healthyTimeoutMS = conn["healthyTimeout"] || 0;
        if (healthyTimeoutMS > 0) {
          this.healthyTimeout_ = setTimeoutNonBlocking(() => {
            this.healthyTimeout_ = null;
            if (!this.isHealthy_) {
              if (this.conn_ && this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {
                this.log_("Connection exceeded healthy timeout but has received " + this.conn_.bytesReceived + " bytes.  Marking connection healthy.");
                this.isHealthy_ = true;
                this.conn_.markConnectionHealthy();
              } else if (this.conn_ && this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {
                this.log_("Connection exceeded healthy timeout but has sent " + this.conn_.bytesSent + " bytes.  Leaving connection alive.");
              } else {
                this.log_("Closing unhealthy connection after timeout.");
                this.close();
              }
            }
          }, Math.floor(healthyTimeoutMS));
        }
      }
      nextTransportId_() {
        return "c:" + this.id + ":" + this.connectionCount++;
      }
      disconnReceiver_(conn) {
        return (everConnected) => {
          if (conn === this.conn_) {
            this.onConnectionLost_(everConnected);
          } else if (conn === this.secondaryConn_) {
            this.log_("Secondary connection lost.");
            this.onSecondaryConnectionLost_();
          } else {
            this.log_("closing an old connection");
          }
        };
      }
      connReceiver_(conn) {
        return (message2) => {
          if (this.state_ !== 2) {
            if (conn === this.rx_) {
              this.onPrimaryMessageReceived_(message2);
            } else if (conn === this.secondaryConn_) {
              this.onSecondaryMessageReceived_(message2);
            } else {
              this.log_("message on old connection");
            }
          }
        };
      }
      sendRequest(dataMsg) {
        const msg = { t: "d", d: dataMsg };
        this.sendData_(msg);
      }
      tryCleanupConnection() {
        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {
          this.log_("cleaning up and promoting a connection: " + this.secondaryConn_.connId);
          this.conn_ = this.secondaryConn_;
          this.secondaryConn_ = null;
        }
      }
      onSecondaryControl_(controlData) {
        if (MESSAGE_TYPE in controlData) {
          const cmd = controlData[MESSAGE_TYPE];
          if (cmd === SWITCH_ACK) {
            this.upgradeIfSecondaryHealthy_();
          } else if (cmd === CONTROL_RESET) {
            this.log_("Got a reset on secondary, closing it");
            this.secondaryConn_.close();
            if (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) {
              this.close();
            }
          } else if (cmd === CONTROL_PONG) {
            this.log_("got pong on secondary.");
            this.secondaryResponsesRequired_--;
            this.upgradeIfSecondaryHealthy_();
          }
        }
      }
      onSecondaryMessageReceived_(parsedData) {
        const layer = requireKey("t", parsedData);
        const data = requireKey("d", parsedData);
        if (layer === "c") {
          this.onSecondaryControl_(data);
        } else if (layer === "d") {
          this.pendingDataMessages.push(data);
        } else {
          throw new Error("Unknown protocol layer: " + layer);
        }
      }
      upgradeIfSecondaryHealthy_() {
        if (this.secondaryResponsesRequired_ <= 0) {
          this.log_("Secondary connection is healthy.");
          this.isHealthy_ = true;
          this.secondaryConn_.markConnectionHealthy();
          this.proceedWithUpgrade_();
        } else {
          this.log_("sending ping on secondary.");
          this.secondaryConn_.send({ t: "c", d: { t: PING, d: {} } });
        }
      }
      proceedWithUpgrade_() {
        this.secondaryConn_.start();
        this.log_("sending client ack on secondary");
        this.secondaryConn_.send({ t: "c", d: { t: SWITCH_ACK, d: {} } });
        this.log_("Ending transmission on primary");
        this.conn_.send({ t: "c", d: { t: END_TRANSMISSION, d: {} } });
        this.tx_ = this.secondaryConn_;
        this.tryCleanupConnection();
      }
      onPrimaryMessageReceived_(parsedData) {
        const layer = requireKey("t", parsedData);
        const data = requireKey("d", parsedData);
        if (layer === "c") {
          this.onControl_(data);
        } else if (layer === "d") {
          this.onDataMessage_(data);
        }
      }
      onDataMessage_(message2) {
        this.onPrimaryResponse_();
        this.onMessage_(message2);
      }
      onPrimaryResponse_() {
        if (!this.isHealthy_) {
          this.primaryResponsesRequired_--;
          if (this.primaryResponsesRequired_ <= 0) {
            this.log_("Primary connection is healthy.");
            this.isHealthy_ = true;
            this.conn_.markConnectionHealthy();
          }
        }
      }
      onControl_(controlData) {
        const cmd = requireKey(MESSAGE_TYPE, controlData);
        if (MESSAGE_DATA in controlData) {
          const payload = controlData[MESSAGE_DATA];
          if (cmd === SERVER_HELLO) {
            this.onHandshake_(payload);
          } else if (cmd === END_TRANSMISSION) {
            this.log_("recvd end transmission on primary");
            this.rx_ = this.secondaryConn_;
            for (let i = 0; i < this.pendingDataMessages.length; ++i) {
              this.onDataMessage_(this.pendingDataMessages[i]);
            }
            this.pendingDataMessages = [];
            this.tryCleanupConnection();
          } else if (cmd === CONTROL_SHUTDOWN) {
            this.onConnectionShutdown_(payload);
          } else if (cmd === CONTROL_RESET) {
            this.onReset_(payload);
          } else if (cmd === CONTROL_ERROR) {
            error("Server Error: " + payload);
          } else if (cmd === CONTROL_PONG) {
            this.log_("got pong on primary.");
            this.onPrimaryResponse_();
            this.sendPingOnPrimaryIfNecessary_();
          } else {
            error("Unknown control packet command: " + cmd);
          }
        }
      }
      onHandshake_(handshake) {
        const timestamp = handshake.ts;
        const version22 = handshake.v;
        const host = handshake.h;
        this.sessionId = handshake.s;
        this.repoInfo_.host = host;
        if (this.state_ === 0) {
          this.conn_.start();
          this.onConnectionEstablished_(this.conn_, timestamp);
          if (PROTOCOL_VERSION !== version22) {
            warn("Protocol version mismatch detected");
          }
          this.tryStartUpgrade_();
        }
      }
      tryStartUpgrade_() {
        const conn = this.transportManager_.upgradeTransport();
        if (conn) {
          this.startUpgrade_(conn);
        }
      }
      startUpgrade_(conn) {
        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId);
        this.secondaryResponsesRequired_ = conn["responsesRequiredToBeHealthy"] || 0;
        const onMessage = this.connReceiver_(this.secondaryConn_);
        const onDisconnect = this.disconnReceiver_(this.secondaryConn_);
        this.secondaryConn_.open(onMessage, onDisconnect);
        setTimeoutNonBlocking(() => {
          if (this.secondaryConn_) {
            this.log_("Timed out trying to upgrade.");
            this.secondaryConn_.close();
          }
        }, Math.floor(UPGRADE_TIMEOUT));
      }
      onReset_(host) {
        this.log_("Reset packet received.  New host: " + host);
        this.repoInfo_.host = host;
        if (this.state_ === 1) {
          this.close();
        } else {
          this.closeConnections_();
          this.start_();
        }
      }
      onConnectionEstablished_(conn, timestamp) {
        this.log_("Realtime connection established.");
        this.conn_ = conn;
        this.state_ = 1;
        if (this.onReady_) {
          this.onReady_(timestamp, this.sessionId);
          this.onReady_ = null;
        }
        if (this.primaryResponsesRequired_ === 0) {
          this.log_("Primary connection is healthy.");
          this.isHealthy_ = true;
        } else {
          setTimeoutNonBlocking(() => {
            this.sendPingOnPrimaryIfNecessary_();
          }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));
        }
      }
      sendPingOnPrimaryIfNecessary_() {
        if (!this.isHealthy_ && this.state_ === 1) {
          this.log_("sending ping on primary.");
          this.sendData_({ t: "c", d: { t: PING, d: {} } });
        }
      }
      onSecondaryConnectionLost_() {
        const conn = this.secondaryConn_;
        this.secondaryConn_ = null;
        if (this.tx_ === conn || this.rx_ === conn) {
          this.close();
        }
      }
      onConnectionLost_(everConnected) {
        this.conn_ = null;
        if (!everConnected && this.state_ === 0) {
          this.log_("Realtime connection failed.");
          if (this.repoInfo_.isCacheableHost()) {
            PersistentStorage.remove("host:" + this.repoInfo_.host);
            this.repoInfo_.internalHost = this.repoInfo_.host;
          }
        } else if (this.state_ === 1) {
          this.log_("Realtime connection lost.");
        }
        this.close();
      }
      onConnectionShutdown_(reason) {
        this.log_("Connection shutdown command received. Shutting down...");
        if (this.onKill_) {
          this.onKill_(reason);
          this.onKill_ = null;
        }
        this.onDisconnect_ = null;
        this.close();
      }
      sendData_(data) {
        if (this.state_ !== 1) {
          throw "Connection is not connected";
        } else {
          this.tx_.send(data);
        }
      }
      close() {
        if (this.state_ !== 2) {
          this.log_("Closing realtime connection.");
          this.state_ = 2;
          this.closeConnections_();
          if (this.onDisconnect_) {
            this.onDisconnect_();
            this.onDisconnect_ = null;
          }
        }
      }
      closeConnections_() {
        this.log_("Shutting down all connections");
        if (this.conn_) {
          this.conn_.close();
          this.conn_ = null;
        }
        if (this.secondaryConn_) {
          this.secondaryConn_.close();
          this.secondaryConn_ = null;
        }
        if (this.healthyTimeout_) {
          clearTimeout(this.healthyTimeout_);
          this.healthyTimeout_ = null;
        }
      }
    };
    ServerActions = class {
      put(pathString, data, onComplete, hash2) {
      }
      merge(pathString, data, onComplete, hash2) {
      }
      refreshAuthToken(token) {
      }
      refreshAppCheckToken(token) {
      }
      onDisconnectPut(pathString, data, onComplete) {
      }
      onDisconnectMerge(pathString, data, onComplete) {
      }
      onDisconnectCancel(pathString, onComplete) {
      }
      reportStats(stats) {
      }
    };
    EventEmitter = class {
      constructor(allowedEvents_) {
        this.allowedEvents_ = allowedEvents_;
        this.listeners_ = {};
        assert(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, "Requires a non-empty array");
      }
      trigger(eventType, ...varArgs) {
        if (Array.isArray(this.listeners_[eventType])) {
          const listeners2 = [...this.listeners_[eventType]];
          for (let i = 0; i < listeners2.length; i++) {
            listeners2[i].callback.apply(listeners2[i].context, varArgs);
          }
        }
      }
      on(eventType, callback, context) {
        this.validateEventType_(eventType);
        this.listeners_[eventType] = this.listeners_[eventType] || [];
        this.listeners_[eventType].push({ callback, context });
        const eventData = this.getInitialEvent(eventType);
        if (eventData) {
          callback.apply(context, eventData);
        }
      }
      off(eventType, callback, context) {
        this.validateEventType_(eventType);
        const listeners2 = this.listeners_[eventType] || [];
        for (let i = 0; i < listeners2.length; i++) {
          if (listeners2[i].callback === callback && (!context || context === listeners2[i].context)) {
            listeners2.splice(i, 1);
            return;
          }
        }
      }
      validateEventType_(eventType) {
        assert(this.allowedEvents_.find((et2) => {
          return et2 === eventType;
        }), "Unknown event: " + eventType);
      }
    };
    OnlineMonitor = class extends EventEmitter {
      constructor() {
        super(["online"]);
        this.online_ = true;
        if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined" && !isMobileCordova()) {
          window.addEventListener("online", () => {
            if (!this.online_) {
              this.online_ = true;
              this.trigger("online", true);
            }
          }, false);
          window.addEventListener("offline", () => {
            if (this.online_) {
              this.online_ = false;
              this.trigger("online", false);
            }
          }, false);
        }
      }
      static getInstance() {
        return new OnlineMonitor();
      }
      getInitialEvent(eventType) {
        assert(eventType === "online", "Unknown event type: " + eventType);
        return [this.online_];
      }
      currentlyOnline() {
        return this.online_;
      }
    };
    MAX_PATH_DEPTH = 32;
    MAX_PATH_LENGTH_BYTES = 768;
    Path = class {
      constructor(pathOrString, pieceNum) {
        if (pieceNum === void 0) {
          this.pieces_ = pathOrString.split("/");
          let copyTo = 0;
          for (let i = 0; i < this.pieces_.length; i++) {
            if (this.pieces_[i].length > 0) {
              this.pieces_[copyTo] = this.pieces_[i];
              copyTo++;
            }
          }
          this.pieces_.length = copyTo;
          this.pieceNum_ = 0;
        } else {
          this.pieces_ = pathOrString;
          this.pieceNum_ = pieceNum;
        }
      }
      toString() {
        let pathString = "";
        for (let i = this.pieceNum_; i < this.pieces_.length; i++) {
          if (this.pieces_[i] !== "") {
            pathString += "/" + this.pieces_[i];
          }
        }
        return pathString || "/";
      }
    };
    ValidationPath = class {
      constructor(path, errorPrefix_) {
        this.errorPrefix_ = errorPrefix_;
        this.parts_ = pathSlice(path, 0);
        this.byteLength_ = Math.max(1, this.parts_.length);
        for (let i = 0; i < this.parts_.length; i++) {
          this.byteLength_ += stringLength(this.parts_[i]);
        }
        validationPathCheckValid(this);
      }
    };
    VisibilityMonitor = class extends EventEmitter {
      constructor() {
        super(["visible"]);
        let hidden;
        let visibilityChange;
        if (typeof document !== "undefined" && typeof document.addEventListener !== "undefined") {
          if (typeof document["hidden"] !== "undefined") {
            visibilityChange = "visibilitychange";
            hidden = "hidden";
          } else if (typeof document["mozHidden"] !== "undefined") {
            visibilityChange = "mozvisibilitychange";
            hidden = "mozHidden";
          } else if (typeof document["msHidden"] !== "undefined") {
            visibilityChange = "msvisibilitychange";
            hidden = "msHidden";
          } else if (typeof document["webkitHidden"] !== "undefined") {
            visibilityChange = "webkitvisibilitychange";
            hidden = "webkitHidden";
          }
        }
        this.visible_ = true;
        if (visibilityChange) {
          document.addEventListener(visibilityChange, () => {
            const visible = !document[hidden];
            if (visible !== this.visible_) {
              this.visible_ = visible;
              this.trigger("visible", visible);
            }
          }, false);
        }
      }
      static getInstance() {
        return new VisibilityMonitor();
      }
      getInitialEvent(eventType) {
        assert(eventType === "visible", "Unknown event type: " + eventType);
        return [this.visible_];
      }
    };
    RECONNECT_MIN_DELAY = 1e3;
    RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1e3;
    GET_CONNECT_TIMEOUT = 3 * 1e3;
    RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1e3;
    RECONNECT_DELAY_MULTIPLIER = 1.3;
    RECONNECT_DELAY_RESET_TIMEOUT = 3e4;
    SERVER_KILL_INTERRUPT_REASON = "server_kill";
    INVALID_TOKEN_THRESHOLD = 3;
    PersistentConnection = class extends ServerActions {
      constructor(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, appCheckTokenProvider_, authOverride_) {
        super();
        this.repoInfo_ = repoInfo_;
        this.applicationId_ = applicationId_;
        this.onDataUpdate_ = onDataUpdate_;
        this.onConnectStatus_ = onConnectStatus_;
        this.onServerInfoUpdate_ = onServerInfoUpdate_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckTokenProvider_ = appCheckTokenProvider_;
        this.authOverride_ = authOverride_;
        this.id = PersistentConnection.nextPersistentConnectionId_++;
        this.log_ = logWrapper("p:" + this.id + ":");
        this.interruptReasons_ = {};
        this.listens = new Map();
        this.outstandingPuts_ = [];
        this.outstandingGets_ = [];
        this.outstandingPutCount_ = 0;
        this.outstandingGetCount_ = 0;
        this.onDisconnectRequestQueue_ = [];
        this.connected_ = false;
        this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;
        this.securityDebugCallback_ = null;
        this.lastSessionId = null;
        this.establishConnectionTimer_ = null;
        this.visible_ = false;
        this.requestCBHash_ = {};
        this.requestNumber_ = 0;
        this.realtime_ = null;
        this.authToken_ = null;
        this.appCheckToken_ = null;
        this.forceTokenRefresh_ = false;
        this.invalidAuthTokenCount_ = 0;
        this.invalidAppCheckTokenCount_ = 0;
        this.firstConnection_ = true;
        this.lastConnectionAttemptTime_ = null;
        this.lastConnectionEstablishedTime_ = null;
        if (authOverride_ && !isNodeSdk()) {
          throw new Error("Auth override specified in options, but not supported on non Node.js platforms");
        }
        VisibilityMonitor.getInstance().on("visible", this.onVisible_, this);
        if (repoInfo_.host.indexOf("fblocal") === -1) {
          OnlineMonitor.getInstance().on("online", this.onOnline_, this);
        }
      }
      sendRequest(action, body, onResponse) {
        const curReqNum = ++this.requestNumber_;
        const msg = { r: curReqNum, a: action, b: body };
        this.log_(stringify(msg));
        assert(this.connected_, "sendRequest call when we're not connected not allowed.");
        this.realtime_.sendRequest(msg);
        if (onResponse) {
          this.requestCBHash_[curReqNum] = onResponse;
        }
      }
      get(query) {
        this.initConnection_();
        const deferred = new Deferred();
        const request = {
          p: query._path.toString(),
          q: query._queryObject
        };
        const outstandingGet = {
          action: "g",
          request,
          onComplete: (message2) => {
            const payload = message2["d"];
            if (message2["s"] === "ok") {
              this.onDataUpdate_(request["p"], payload, false, null);
              deferred.resolve(payload);
            } else {
              deferred.reject(payload);
            }
          }
        };
        this.outstandingGets_.push(outstandingGet);
        this.outstandingGetCount_++;
        const index = this.outstandingGets_.length - 1;
        if (!this.connected_) {
          setTimeout(() => {
            const get3 = this.outstandingGets_[index];
            if (get3 === void 0 || outstandingGet !== get3) {
              return;
            }
            delete this.outstandingGets_[index];
            this.outstandingGetCount_--;
            if (this.outstandingGetCount_ === 0) {
              this.outstandingGets_ = [];
            }
            this.log_("get " + index + " timed out on connection");
            deferred.reject(new Error("Client is offline."));
          }, GET_CONNECT_TIMEOUT);
        }
        if (this.connected_) {
          this.sendGet_(index);
        }
        return deferred.promise;
      }
      listen(query, currentHashFn, tag, onComplete) {
        this.initConnection_();
        const queryId = query._queryIdentifier;
        const pathString = query._path.toString();
        this.log_("Listen called for " + pathString + " " + queryId);
        if (!this.listens.has(pathString)) {
          this.listens.set(pathString, new Map());
        }
        assert(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), "listen() called for non-default but complete query");
        assert(!this.listens.get(pathString).has(queryId), "listen() called twice for same path/queryId.");
        const listenSpec = {
          onComplete,
          hashFn: currentHashFn,
          query,
          tag
        };
        this.listens.get(pathString).set(queryId, listenSpec);
        if (this.connected_) {
          this.sendListen_(listenSpec);
        }
      }
      sendGet_(index) {
        const get3 = this.outstandingGets_[index];
        this.sendRequest("g", get3.request, (message2) => {
          delete this.outstandingGets_[index];
          this.outstandingGetCount_--;
          if (this.outstandingGetCount_ === 0) {
            this.outstandingGets_ = [];
          }
          if (get3.onComplete) {
            get3.onComplete(message2);
          }
        });
      }
      sendListen_(listenSpec) {
        const query = listenSpec.query;
        const pathString = query._path.toString();
        const queryId = query._queryIdentifier;
        this.log_("Listen on " + pathString + " for " + queryId);
        const req = { p: pathString };
        const action = "q";
        if (listenSpec.tag) {
          req["q"] = query._queryObject;
          req["t"] = listenSpec.tag;
        }
        req["h"] = listenSpec.hashFn();
        this.sendRequest(action, req, (message2) => {
          const payload = message2["d"];
          const status = message2["s"];
          PersistentConnection.warnOnListenWarnings_(payload, query);
          const currentListenSpec = this.listens.get(pathString) && this.listens.get(pathString).get(queryId);
          if (currentListenSpec === listenSpec) {
            this.log_("listen response", message2);
            if (status !== "ok") {
              this.removeListen_(pathString, queryId);
            }
            if (listenSpec.onComplete) {
              listenSpec.onComplete(status, payload);
            }
          }
        });
      }
      static warnOnListenWarnings_(payload, query) {
        if (payload && typeof payload === "object" && contains(payload, "w")) {
          const warnings = safeGet(payload, "w");
          if (Array.isArray(warnings) && ~warnings.indexOf("no_index")) {
            const indexSpec = '".indexOn": "' + query._queryParams.getIndex().toString() + '"';
            const indexPath = query._path.toString();
            warn(`Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding ${indexSpec} at ${indexPath} to your security rules for better performance.`);
          }
        }
      }
      refreshAuthToken(token) {
        this.authToken_ = token;
        this.log_("Auth token refreshed");
        if (this.authToken_) {
          this.tryAuth();
        } else {
          if (this.connected_) {
            this.sendRequest("unauth", {}, () => {
            });
          }
        }
        this.reduceReconnectDelayIfAdminCredential_(token);
      }
      reduceReconnectDelayIfAdminCredential_(credential) {
        const isFirebaseSecret = credential && credential.length === 40;
        if (isFirebaseSecret || isAdmin(credential)) {
          this.log_("Admin auth credential detected.  Reducing max reconnect time.");
          this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
        }
      }
      refreshAppCheckToken(token) {
        this.appCheckToken_ = token;
        this.log_("App check token refreshed");
        if (this.appCheckToken_) {
          this.tryAppCheck();
        } else {
          if (this.connected_) {
            this.sendRequest("unappeck", {}, () => {
            });
          }
        }
      }
      tryAuth() {
        if (this.connected_ && this.authToken_) {
          const token = this.authToken_;
          const authMethod = isValidFormat(token) ? "auth" : "gauth";
          const requestData = { cred: token };
          if (this.authOverride_ === null) {
            requestData["noauth"] = true;
          } else if (typeof this.authOverride_ === "object") {
            requestData["authvar"] = this.authOverride_;
          }
          this.sendRequest(authMethod, requestData, (res) => {
            const status = res["s"];
            const data = res["d"] || "error";
            if (this.authToken_ === token) {
              if (status === "ok") {
                this.invalidAuthTokenCount_ = 0;
              } else {
                this.onAuthRevoked_(status, data);
              }
            }
          });
        }
      }
      tryAppCheck() {
        if (this.connected_ && this.appCheckToken_) {
          this.sendRequest("appcheck", { "token": this.appCheckToken_ }, (res) => {
            const status = res["s"];
            const data = res["d"] || "error";
            if (status === "ok") {
              this.invalidAppCheckTokenCount_ = 0;
            } else {
              this.onAppCheckRevoked_(status, data);
            }
          });
        }
      }
      unlisten(query, tag) {
        const pathString = query._path.toString();
        const queryId = query._queryIdentifier;
        this.log_("Unlisten called for " + pathString + " " + queryId);
        assert(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), "unlisten() called for non-default but complete query");
        const listen2 = this.removeListen_(pathString, queryId);
        if (listen2 && this.connected_) {
          this.sendUnlisten_(pathString, queryId, query._queryObject, tag);
        }
      }
      sendUnlisten_(pathString, queryId, queryObj, tag) {
        this.log_("Unlisten on " + pathString + " for " + queryId);
        const req = { p: pathString };
        const action = "n";
        if (tag) {
          req["q"] = queryObj;
          req["t"] = tag;
        }
        this.sendRequest(action, req);
      }
      onDisconnectPut(pathString, data, onComplete) {
        this.initConnection_();
        if (this.connected_) {
          this.sendOnDisconnect_("o", pathString, data, onComplete);
        } else {
          this.onDisconnectRequestQueue_.push({
            pathString,
            action: "o",
            data,
            onComplete
          });
        }
      }
      onDisconnectMerge(pathString, data, onComplete) {
        this.initConnection_();
        if (this.connected_) {
          this.sendOnDisconnect_("om", pathString, data, onComplete);
        } else {
          this.onDisconnectRequestQueue_.push({
            pathString,
            action: "om",
            data,
            onComplete
          });
        }
      }
      onDisconnectCancel(pathString, onComplete) {
        this.initConnection_();
        if (this.connected_) {
          this.sendOnDisconnect_("oc", pathString, null, onComplete);
        } else {
          this.onDisconnectRequestQueue_.push({
            pathString,
            action: "oc",
            data: null,
            onComplete
          });
        }
      }
      sendOnDisconnect_(action, pathString, data, onComplete) {
        const request = { p: pathString, d: data };
        this.log_("onDisconnect " + action, request);
        this.sendRequest(action, request, (response) => {
          if (onComplete) {
            setTimeout(() => {
              onComplete(response["s"], response["d"]);
            }, Math.floor(0));
          }
        });
      }
      put(pathString, data, onComplete, hash2) {
        this.putInternal("p", pathString, data, onComplete, hash2);
      }
      merge(pathString, data, onComplete, hash2) {
        this.putInternal("m", pathString, data, onComplete, hash2);
      }
      putInternal(action, pathString, data, onComplete, hash2) {
        this.initConnection_();
        const request = {
          p: pathString,
          d: data
        };
        if (hash2 !== void 0) {
          request["h"] = hash2;
        }
        this.outstandingPuts_.push({
          action,
          request,
          onComplete
        });
        this.outstandingPutCount_++;
        const index = this.outstandingPuts_.length - 1;
        if (this.connected_) {
          this.sendPut_(index);
        } else {
          this.log_("Buffering put: " + pathString);
        }
      }
      sendPut_(index) {
        const action = this.outstandingPuts_[index].action;
        const request = this.outstandingPuts_[index].request;
        const onComplete = this.outstandingPuts_[index].onComplete;
        this.outstandingPuts_[index].queued = this.connected_;
        this.sendRequest(action, request, (message2) => {
          this.log_(action + " response", message2);
          delete this.outstandingPuts_[index];
          this.outstandingPutCount_--;
          if (this.outstandingPutCount_ === 0) {
            this.outstandingPuts_ = [];
          }
          if (onComplete) {
            onComplete(message2["s"], message2["d"]);
          }
        });
      }
      reportStats(stats) {
        if (this.connected_) {
          const request = { c: stats };
          this.log_("reportStats", request);
          this.sendRequest("s", request, (result) => {
            const status = result["s"];
            if (status !== "ok") {
              const errorReason = result["d"];
              this.log_("reportStats", "Error sending stats: " + errorReason);
            }
          });
        }
      }
      onDataMessage_(message2) {
        if ("r" in message2) {
          this.log_("from server: " + stringify(message2));
          const reqNum = message2["r"];
          const onResponse = this.requestCBHash_[reqNum];
          if (onResponse) {
            delete this.requestCBHash_[reqNum];
            onResponse(message2["b"]);
          }
        } else if ("error" in message2) {
          throw "A server-side error has occurred: " + message2["error"];
        } else if ("a" in message2) {
          this.onDataPush_(message2["a"], message2["b"]);
        }
      }
      onDataPush_(action, body) {
        this.log_("handleServerMessage", action, body);
        if (action === "d") {
          this.onDataUpdate_(body["p"], body["d"], false, body["t"]);
        } else if (action === "m") {
          this.onDataUpdate_(body["p"], body["d"], true, body["t"]);
        } else if (action === "c") {
          this.onListenRevoked_(body["p"], body["q"]);
        } else if (action === "ac") {
          this.onAuthRevoked_(body["s"], body["d"]);
        } else if (action === "apc") {
          this.onAppCheckRevoked_(body["s"], body["d"]);
        } else if (action === "sd") {
          this.onSecurityDebugPacket_(body);
        } else {
          error("Unrecognized action received from server: " + stringify(action) + "\nAre you using the latest client?");
        }
      }
      onReady_(timestamp, sessionId) {
        this.log_("connection ready");
        this.connected_ = true;
        this.lastConnectionEstablishedTime_ = new Date().getTime();
        this.handleTimestamp_(timestamp);
        this.lastSessionId = sessionId;
        if (this.firstConnection_) {
          this.sendConnectStats_();
        }
        this.restoreState_();
        this.firstConnection_ = false;
        this.onConnectStatus_(true);
      }
      scheduleConnect_(timeout) {
        assert(!this.realtime_, "Scheduling a connect when we're already connected/ing?");
        if (this.establishConnectionTimer_) {
          clearTimeout(this.establishConnectionTimer_);
        }
        this.establishConnectionTimer_ = setTimeout(() => {
          this.establishConnectionTimer_ = null;
          this.establishConnection_();
        }, Math.floor(timeout));
      }
      initConnection_() {
        if (!this.realtime_ && this.firstConnection_) {
          this.scheduleConnect_(0);
        }
      }
      onVisible_(visible) {
        if (visible && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_) {
          this.log_("Window became visible.  Reducing delay.");
          this.reconnectDelay_ = RECONNECT_MIN_DELAY;
          if (!this.realtime_) {
            this.scheduleConnect_(0);
          }
        }
        this.visible_ = visible;
      }
      onOnline_(online) {
        if (online) {
          this.log_("Browser went online.");
          this.reconnectDelay_ = RECONNECT_MIN_DELAY;
          if (!this.realtime_) {
            this.scheduleConnect_(0);
          }
        } else {
          this.log_("Browser went offline.  Killing connection.");
          if (this.realtime_) {
            this.realtime_.close();
          }
        }
      }
      onRealtimeDisconnect_() {
        this.log_("data client disconnected");
        this.connected_ = false;
        this.realtime_ = null;
        this.cancelSentTransactions_();
        this.requestCBHash_ = {};
        if (this.shouldReconnect_()) {
          if (!this.visible_) {
            this.log_("Window isn't visible.  Delaying reconnect.");
            this.reconnectDelay_ = this.maxReconnectDelay_;
            this.lastConnectionAttemptTime_ = new Date().getTime();
          } else if (this.lastConnectionEstablishedTime_) {
            const timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;
            if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) {
              this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            }
            this.lastConnectionEstablishedTime_ = null;
          }
          const timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;
          let reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);
          reconnectDelay = Math.random() * reconnectDelay;
          this.log_("Trying to reconnect in " + reconnectDelay + "ms");
          this.scheduleConnect_(reconnectDelay);
          this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);
        }
        this.onConnectStatus_(false);
      }
      async establishConnection_() {
        if (this.shouldReconnect_()) {
          this.log_("Making a connection attempt");
          this.lastConnectionAttemptTime_ = new Date().getTime();
          this.lastConnectionEstablishedTime_ = null;
          const onDataMessage = this.onDataMessage_.bind(this);
          const onReady = this.onReady_.bind(this);
          const onDisconnect = this.onRealtimeDisconnect_.bind(this);
          const connId = this.id + ":" + PersistentConnection.nextConnectionId_++;
          const lastSessionId = this.lastSessionId;
          let canceled2 = false;
          let connection = null;
          const closeFn = function() {
            if (connection) {
              connection.close();
            } else {
              canceled2 = true;
              onDisconnect();
            }
          };
          const sendRequestFn = function(msg) {
            assert(connection, "sendRequest call when we're not connected not allowed.");
            connection.sendRequest(msg);
          };
          this.realtime_ = {
            close: closeFn,
            sendRequest: sendRequestFn
          };
          const forceRefresh = this.forceTokenRefresh_;
          this.forceTokenRefresh_ = false;
          try {
            const [authToken, appCheckToken] = await Promise.all([
              this.authTokenProvider_.getToken(forceRefresh),
              this.appCheckTokenProvider_.getToken(forceRefresh)
            ]);
            if (!canceled2) {
              log("getToken() completed. Creating connection.");
              this.authToken_ = authToken && authToken.accessToken;
              this.appCheckToken_ = appCheckToken && appCheckToken.token;
              connection = new Connection(connId, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, onDataMessage, onReady, onDisconnect, (reason) => {
                warn(reason + " (" + this.repoInfo_.toString() + ")");
                this.interrupt(SERVER_KILL_INTERRUPT_REASON);
              }, lastSessionId);
            } else {
              log("getToken() completed but was canceled");
            }
          } catch (error22) {
            this.log_("Failed to get token: " + error22);
            if (!canceled2) {
              if (this.repoInfo_.nodeAdmin) {
                warn(error22);
              }
              closeFn();
            }
          }
        }
      }
      interrupt(reason) {
        log("Interrupting connection for reason: " + reason);
        this.interruptReasons_[reason] = true;
        if (this.realtime_) {
          this.realtime_.close();
        } else {
          if (this.establishConnectionTimer_) {
            clearTimeout(this.establishConnectionTimer_);
            this.establishConnectionTimer_ = null;
          }
          if (this.connected_) {
            this.onRealtimeDisconnect_();
          }
        }
      }
      resume(reason) {
        log("Resuming connection for reason: " + reason);
        delete this.interruptReasons_[reason];
        if (isEmpty(this.interruptReasons_)) {
          this.reconnectDelay_ = RECONNECT_MIN_DELAY;
          if (!this.realtime_) {
            this.scheduleConnect_(0);
          }
        }
      }
      handleTimestamp_(timestamp) {
        const delta = timestamp - new Date().getTime();
        this.onServerInfoUpdate_({ serverTimeOffset: delta });
      }
      cancelSentTransactions_() {
        for (let i = 0; i < this.outstandingPuts_.length; i++) {
          const put = this.outstandingPuts_[i];
          if (put && "h" in put.request && put.queued) {
            if (put.onComplete) {
              put.onComplete("disconnect");
            }
            delete this.outstandingPuts_[i];
            this.outstandingPutCount_--;
          }
        }
        if (this.outstandingPutCount_ === 0) {
          this.outstandingPuts_ = [];
        }
      }
      onListenRevoked_(pathString, query) {
        let queryId;
        if (!query) {
          queryId = "default";
        } else {
          queryId = query.map((q2) => ObjectToUniqueKey(q2)).join("$");
        }
        const listen2 = this.removeListen_(pathString, queryId);
        if (listen2 && listen2.onComplete) {
          listen2.onComplete("permission_denied");
        }
      }
      removeListen_(pathString, queryId) {
        const normalizedPathString = new Path(pathString).toString();
        let listen2;
        if (this.listens.has(normalizedPathString)) {
          const map2 = this.listens.get(normalizedPathString);
          listen2 = map2.get(queryId);
          map2.delete(queryId);
          if (map2.size === 0) {
            this.listens.delete(normalizedPathString);
          }
        } else {
          listen2 = void 0;
        }
        return listen2;
      }
      onAuthRevoked_(statusCode, explanation) {
        log("Auth token revoked: " + statusCode + "/" + explanation);
        this.authToken_ = null;
        this.forceTokenRefresh_ = true;
        this.realtime_.close();
        if (statusCode === "invalid_token" || statusCode === "permission_denied") {
          this.invalidAuthTokenCount_++;
          if (this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
            this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
            this.authTokenProvider_.notifyForInvalidToken();
          }
        }
      }
      onAppCheckRevoked_(statusCode, explanation) {
        log("App check token revoked: " + statusCode + "/" + explanation);
        this.appCheckToken_ = null;
        this.forceTokenRefresh_ = true;
        if (statusCode === "invalid_token" || statusCode === "permission_denied") {
          this.invalidAppCheckTokenCount_++;
          if (this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
            this.appCheckTokenProvider_.notifyForInvalidToken();
          }
        }
      }
      onSecurityDebugPacket_(body) {
        if (this.securityDebugCallback_) {
          this.securityDebugCallback_(body);
        } else {
          if ("msg" in body) {
            console.log("FIREBASE: " + body["msg"].replace("\n", "\nFIREBASE: "));
          }
        }
      }
      restoreState_() {
        this.tryAuth();
        this.tryAppCheck();
        for (const queries of this.listens.values()) {
          for (const listenSpec of queries.values()) {
            this.sendListen_(listenSpec);
          }
        }
        for (let i = 0; i < this.outstandingPuts_.length; i++) {
          if (this.outstandingPuts_[i]) {
            this.sendPut_(i);
          }
        }
        while (this.onDisconnectRequestQueue_.length) {
          const request = this.onDisconnectRequestQueue_.shift();
          this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);
        }
        for (let i = 0; i < this.outstandingGets_.length; i++) {
          if (this.outstandingGets_[i]) {
            this.sendGet_(i);
          }
        }
      }
      sendConnectStats_() {
        const stats = {};
        let clientName = "js";
        if (isNodeSdk()) {
          if (this.repoInfo_.nodeAdmin) {
            clientName = "admin_node";
          } else {
            clientName = "node";
          }
        }
        stats["sdk." + clientName + "." + SDK_VERSION2.replace(/\./g, "-")] = 1;
        if (isMobileCordova()) {
          stats["framework.cordova"] = 1;
        } else if (isReactNative()) {
          stats["framework.reactnative"] = 1;
        }
        this.reportStats(stats);
      }
      shouldReconnect_() {
        const online = OnlineMonitor.getInstance().currentlyOnline();
        return isEmpty(this.interruptReasons_) && online;
      }
    };
    PersistentConnection.nextPersistentConnectionId_ = 0;
    PersistentConnection.nextConnectionId_ = 0;
    NamedNode = class {
      constructor(name22, node) {
        this.name = name22;
        this.node = node;
      }
      static Wrap(name22, node) {
        return new NamedNode(name22, node);
      }
    };
    Index = class {
      getCompare() {
        return this.compare.bind(this);
      }
      indexedValueChanged(oldNode, newNode) {
        const oldWrapped = new NamedNode(MIN_NAME, oldNode);
        const newWrapped = new NamedNode(MIN_NAME, newNode);
        return this.compare(oldWrapped, newWrapped) !== 0;
      }
      minPost() {
        return NamedNode.MIN;
      }
    };
    KeyIndex = class extends Index {
      static get __EMPTY_NODE() {
        return __EMPTY_NODE;
      }
      static set __EMPTY_NODE(val) {
        __EMPTY_NODE = val;
      }
      compare(a, b) {
        return nameCompare(a.name, b.name);
      }
      isDefinedOn(node) {
        throw assertionError("KeyIndex.isDefinedOn not expected to be called.");
      }
      indexedValueChanged(oldNode, newNode) {
        return false;
      }
      minPost() {
        return NamedNode.MIN;
      }
      maxPost() {
        return new NamedNode(MAX_NAME, __EMPTY_NODE);
      }
      makePost(indexValue, name22) {
        assert(typeof indexValue === "string", "KeyIndex indexValue must always be a string.");
        return new NamedNode(indexValue, __EMPTY_NODE);
      }
      toString() {
        return ".key";
      }
    };
    KEY_INDEX = new KeyIndex();
    SortedMapIterator = class {
      constructor(node, startKey, comparator, isReverse_, resultGenerator_ = null) {
        this.isReverse_ = isReverse_;
        this.resultGenerator_ = resultGenerator_;
        this.nodeStack_ = [];
        let cmp = 1;
        while (!node.isEmpty()) {
          node = node;
          cmp = startKey ? comparator(node.key, startKey) : 1;
          if (isReverse_) {
            cmp *= -1;
          }
          if (cmp < 0) {
            if (this.isReverse_) {
              node = node.left;
            } else {
              node = node.right;
            }
          } else if (cmp === 0) {
            this.nodeStack_.push(node);
            break;
          } else {
            this.nodeStack_.push(node);
            if (this.isReverse_) {
              node = node.right;
            } else {
              node = node.left;
            }
          }
        }
      }
      getNext() {
        if (this.nodeStack_.length === 0) {
          return null;
        }
        let node = this.nodeStack_.pop();
        let result;
        if (this.resultGenerator_) {
          result = this.resultGenerator_(node.key, node.value);
        } else {
          result = { key: node.key, value: node.value };
        }
        if (this.isReverse_) {
          node = node.left;
          while (!node.isEmpty()) {
            this.nodeStack_.push(node);
            node = node.right;
          }
        } else {
          node = node.right;
          while (!node.isEmpty()) {
            this.nodeStack_.push(node);
            node = node.left;
          }
        }
        return result;
      }
      hasNext() {
        return this.nodeStack_.length > 0;
      }
      peek() {
        if (this.nodeStack_.length === 0) {
          return null;
        }
        const node = this.nodeStack_[this.nodeStack_.length - 1];
        if (this.resultGenerator_) {
          return this.resultGenerator_(node.key, node.value);
        } else {
          return { key: node.key, value: node.value };
        }
      }
    };
    LLRBNode = class {
      constructor(key, value, color, left, right) {
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode.RED;
        this.left = left != null ? left : SortedMap.EMPTY_NODE;
        this.right = right != null ? right : SortedMap.EMPTY_NODE;
      }
      copy(key, value, color, left, right) {
        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
      }
      count() {
        return this.left.count() + 1 + this.right.count();
      }
      isEmpty() {
        return false;
      }
      inorderTraversal(action) {
        return this.left.inorderTraversal(action) || !!action(this.key, this.value) || this.right.inorderTraversal(action);
      }
      reverseTraversal(action) {
        return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
      }
      min_() {
        if (this.left.isEmpty()) {
          return this;
        } else {
          return this.left.min_();
        }
      }
      minKey() {
        return this.min_().key;
      }
      maxKey() {
        if (this.right.isEmpty()) {
          return this.key;
        } else {
          return this.right.maxKey();
        }
      }
      insert(key, value, comparator) {
        let n = this;
        const cmp = comparator(key, n.key);
        if (cmp < 0) {
          n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
        } else if (cmp === 0) {
          n = n.copy(null, value, null, null, null);
        } else {
          n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
        }
        return n.fixUp_();
      }
      removeMin_() {
        if (this.left.isEmpty()) {
          return SortedMap.EMPTY_NODE;
        }
        let n = this;
        if (!n.left.isRed_() && !n.left.left.isRed_()) {
          n = n.moveRedLeft_();
        }
        n = n.copy(null, null, null, n.left.removeMin_(), null);
        return n.fixUp_();
      }
      remove(key, comparator) {
        let n, smallest;
        n = this;
        if (comparator(key, n.key) < 0) {
          if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {
            n = n.moveRedLeft_();
          }
          n = n.copy(null, null, null, n.left.remove(key, comparator), null);
        } else {
          if (n.left.isRed_()) {
            n = n.rotateRight_();
          }
          if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {
            n = n.moveRedRight_();
          }
          if (comparator(key, n.key) === 0) {
            if (n.right.isEmpty()) {
              return SortedMap.EMPTY_NODE;
            } else {
              smallest = n.right.min_();
              n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());
            }
          }
          n = n.copy(null, null, null, null, n.right.remove(key, comparator));
        }
        return n.fixUp_();
      }
      isRed_() {
        return this.color;
      }
      fixUp_() {
        let n = this;
        if (n.right.isRed_() && !n.left.isRed_()) {
          n = n.rotateLeft_();
        }
        if (n.left.isRed_() && n.left.left.isRed_()) {
          n = n.rotateRight_();
        }
        if (n.left.isRed_() && n.right.isRed_()) {
          n = n.colorFlip_();
        }
        return n;
      }
      moveRedLeft_() {
        let n = this.colorFlip_();
        if (n.right.left.isRed_()) {
          n = n.copy(null, null, null, null, n.right.rotateRight_());
          n = n.rotateLeft_();
          n = n.colorFlip_();
        }
        return n;
      }
      moveRedRight_() {
        let n = this.colorFlip_();
        if (n.left.left.isRed_()) {
          n = n.rotateRight_();
          n = n.colorFlip_();
        }
        return n;
      }
      rotateLeft_() {
        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
      }
      rotateRight_() {
        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
      }
      colorFlip_() {
        const left = this.left.copy(null, null, !this.left.color, null, null);
        const right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
      }
      checkMaxDepth_() {
        const blackDepth = this.check_();
        return Math.pow(2, blackDepth) <= this.count() + 1;
      }
      check_() {
        if (this.isRed_() && this.left.isRed_()) {
          throw new Error("Red node has red child(" + this.key + "," + this.value + ")");
        }
        if (this.right.isRed_()) {
          throw new Error("Right child of (" + this.key + "," + this.value + ") is red");
        }
        const blackDepth = this.left.check_();
        if (blackDepth !== this.right.check_()) {
          throw new Error("Black depths differ");
        } else {
          return blackDepth + (this.isRed_() ? 0 : 1);
        }
      }
    };
    LLRBNode.RED = true;
    LLRBNode.BLACK = false;
    LLRBEmptyNode = class {
      copy(key, value, color, left, right) {
        return this;
      }
      insert(key, value, comparator) {
        return new LLRBNode(key, value, null);
      }
      remove(key, comparator) {
        return this;
      }
      count() {
        return 0;
      }
      isEmpty() {
        return true;
      }
      inorderTraversal(action) {
        return false;
      }
      reverseTraversal(action) {
        return false;
      }
      minKey() {
        return null;
      }
      maxKey() {
        return null;
      }
      check_() {
        return 0;
      }
      isRed_() {
        return false;
      }
    };
    SortedMap = class {
      constructor(comparator_, root_ = SortedMap.EMPTY_NODE) {
        this.comparator_ = comparator_;
        this.root_ = root_;
      }
      insert(key, value) {
        return new SortedMap(this.comparator_, this.root_.insert(key, value, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));
      }
      remove(key) {
        return new SortedMap(this.comparator_, this.root_.remove(key, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));
      }
      get(key) {
        let cmp;
        let node = this.root_;
        while (!node.isEmpty()) {
          cmp = this.comparator_(key, node.key);
          if (cmp === 0) {
            return node.value;
          } else if (cmp < 0) {
            node = node.left;
          } else if (cmp > 0) {
            node = node.right;
          }
        }
        return null;
      }
      getPredecessorKey(key) {
        let cmp, node = this.root_, rightParent = null;
        while (!node.isEmpty()) {
          cmp = this.comparator_(key, node.key);
          if (cmp === 0) {
            if (!node.left.isEmpty()) {
              node = node.left;
              while (!node.right.isEmpty()) {
                node = node.right;
              }
              return node.key;
            } else if (rightParent) {
              return rightParent.key;
            } else {
              return null;
            }
          } else if (cmp < 0) {
            node = node.left;
          } else if (cmp > 0) {
            rightParent = node;
            node = node.right;
          }
        }
        throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?");
      }
      isEmpty() {
        return this.root_.isEmpty();
      }
      count() {
        return this.root_.count();
      }
      minKey() {
        return this.root_.minKey();
      }
      maxKey() {
        return this.root_.maxKey();
      }
      inorderTraversal(action) {
        return this.root_.inorderTraversal(action);
      }
      reverseTraversal(action) {
        return this.root_.reverseTraversal(action);
      }
      getIterator(resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
      }
      getIteratorFrom(key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);
      }
      getReverseIteratorFrom(key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);
      }
      getReverseIterator(resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
      }
    };
    SortedMap.EMPTY_NODE = new LLRBEmptyNode();
    priorityHashText = function(priority) {
      if (typeof priority === "number") {
        return "number:" + doubleToIEEE754String(priority);
      } else {
        return "string:" + priority;
      }
    };
    validatePriorityNode = function(priorityNode) {
      if (priorityNode.isLeafNode()) {
        const val = priorityNode.val();
        assert(typeof val === "string" || typeof val === "number" || typeof val === "object" && contains(val, ".sv"), "Priority must be a string or number.");
      } else {
        assert(priorityNode === MAX_NODE$2 || priorityNode.isEmpty(), "priority of unexpected type.");
      }
      assert(priorityNode === MAX_NODE$2 || priorityNode.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
    };
    LeafNode = class {
      constructor(value_, priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
        this.value_ = value_;
        this.priorityNode_ = priorityNode_;
        this.lazyHash_ = null;
        assert(this.value_ !== void 0 && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value.");
        validatePriorityNode(this.priorityNode_);
      }
      static set __childrenNodeConstructor(val) {
        __childrenNodeConstructor = val;
      }
      static get __childrenNodeConstructor() {
        return __childrenNodeConstructor;
      }
      isLeafNode() {
        return true;
      }
      getPriority() {
        return this.priorityNode_;
      }
      updatePriority(newPriorityNode) {
        return new LeafNode(this.value_, newPriorityNode);
      }
      getImmediateChild(childName) {
        if (childName === ".priority") {
          return this.priorityNode_;
        } else {
          return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
      }
      getChild(path) {
        if (pathIsEmpty(path)) {
          return this;
        } else if (pathGetFront(path) === ".priority") {
          return this.priorityNode_;
        } else {
          return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
      }
      hasChild() {
        return false;
      }
      getPredecessorChildName(childName, childNode) {
        return null;
      }
      updateImmediateChild(childName, newChildNode) {
        if (childName === ".priority") {
          return this.updatePriority(newChildNode);
        } else if (newChildNode.isEmpty() && childName !== ".priority") {
          return this;
        } else {
          return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);
        }
      }
      updateChild(path, newChildNode) {
        const front = pathGetFront(path);
        if (front === null) {
          return newChildNode;
        } else if (newChildNode.isEmpty() && front !== ".priority") {
          return this;
        } else {
          assert(front !== ".priority" || pathGetLength(path) === 1, ".priority must be the last token in a path");
          return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path), newChildNode));
        }
      }
      isEmpty() {
        return false;
      }
      numChildren() {
        return 0;
      }
      forEachChild(index, action) {
        return false;
      }
      val(exportFormat) {
        if (exportFormat && !this.getPriority().isEmpty()) {
          return {
            ".value": this.getValue(),
            ".priority": this.getPriority().val()
          };
        } else {
          return this.getValue();
        }
      }
      hash() {
        if (this.lazyHash_ === null) {
          let toHash = "";
          if (!this.priorityNode_.isEmpty()) {
            toHash += "priority:" + priorityHashText(this.priorityNode_.val()) + ":";
          }
          const type = typeof this.value_;
          toHash += type + ":";
          if (type === "number") {
            toHash += doubleToIEEE754String(this.value_);
          } else {
            toHash += this.value_;
          }
          this.lazyHash_ = sha1(toHash);
        }
        return this.lazyHash_;
      }
      getValue() {
        return this.value_;
      }
      compareTo(other) {
        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
          return 1;
        } else if (other instanceof LeafNode.__childrenNodeConstructor) {
          return -1;
        } else {
          assert(other.isLeafNode(), "Unknown node type");
          return this.compareToLeafNode_(other);
        }
      }
      compareToLeafNode_(otherLeaf) {
        const otherLeafType = typeof otherLeaf.value_;
        const thisLeafType = typeof this.value_;
        const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);
        const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);
        assert(otherIndex >= 0, "Unknown leaf type: " + otherLeafType);
        assert(thisIndex >= 0, "Unknown leaf type: " + thisLeafType);
        if (otherIndex === thisIndex) {
          if (thisLeafType === "object") {
            return 0;
          } else {
            if (this.value_ < otherLeaf.value_) {
              return -1;
            } else if (this.value_ === otherLeaf.value_) {
              return 0;
            } else {
              return 1;
            }
          }
        } else {
          return thisIndex - otherIndex;
        }
      }
      withIndex() {
        return this;
      }
      isIndexed() {
        return true;
      }
      equals(other) {
        if (other === this) {
          return true;
        } else if (other.isLeafNode()) {
          const otherLeaf = other;
          return this.value_ === otherLeaf.value_ && this.priorityNode_.equals(otherLeaf.priorityNode_);
        } else {
          return false;
        }
      }
    };
    LeafNode.VALUE_TYPE_ORDER = ["object", "boolean", "number", "string"];
    PriorityIndex = class extends Index {
      compare(a, b) {
        const aPriority = a.node.getPriority();
        const bPriority = b.node.getPriority();
        const indexCmp = aPriority.compareTo(bPriority);
        if (indexCmp === 0) {
          return nameCompare(a.name, b.name);
        } else {
          return indexCmp;
        }
      }
      isDefinedOn(node) {
        return !node.getPriority().isEmpty();
      }
      indexedValueChanged(oldNode, newNode) {
        return !oldNode.getPriority().equals(newNode.getPriority());
      }
      minPost() {
        return NamedNode.MIN;
      }
      maxPost() {
        return new NamedNode(MAX_NAME, new LeafNode("[PRIORITY-POST]", MAX_NODE$1));
      }
      makePost(indexValue, name22) {
        const priorityNode = nodeFromJSON$1(indexValue);
        return new NamedNode(name22, new LeafNode("[PRIORITY-POST]", priorityNode));
      }
      toString() {
        return ".priority";
      }
    };
    PRIORITY_INDEX = new PriorityIndex();
    LOG_2 = Math.log(2);
    Base12Num = class {
      constructor(length) {
        const logBase2 = (num) => parseInt(Math.log(num) / LOG_2, 10);
        const bitMask = (bits) => parseInt(Array(bits + 1).join("1"), 2);
        this.count = logBase2(length + 1);
        this.current_ = this.count - 1;
        const mask = bitMask(this.count);
        this.bits_ = length + 1 & mask;
      }
      nextBitIsOne() {
        const result = !(this.bits_ & 1 << this.current_);
        this.current_--;
        return result;
      }
    };
    buildChildSet = function(childList, cmp, keyFn, mapSortFn) {
      childList.sort(cmp);
      const buildBalancedTree = function(low, high) {
        const length = high - low;
        let namedNode;
        let key;
        if (length === 0) {
          return null;
        } else if (length === 1) {
          namedNode = childList[low];
          key = keyFn ? keyFn(namedNode) : namedNode;
          return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);
        } else {
          const middle = parseInt(length / 2, 10) + low;
          const left = buildBalancedTree(low, middle);
          const right = buildBalancedTree(middle + 1, high);
          namedNode = childList[middle];
          key = keyFn ? keyFn(namedNode) : namedNode;
          return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);
        }
      };
      const buildFrom12Array = function(base122) {
        let node = null;
        let root2 = null;
        let index = childList.length;
        const buildPennant = function(chunkSize, color) {
          const low = index - chunkSize;
          const high = index;
          index -= chunkSize;
          const childTree = buildBalancedTree(low + 1, high);
          const namedNode = childList[low];
          const key = keyFn ? keyFn(namedNode) : namedNode;
          attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));
        };
        const attachPennant = function(pennant) {
          if (node) {
            node.left = pennant;
            node = pennant;
          } else {
            root2 = pennant;
            node = pennant;
          }
        };
        for (let i = 0; i < base122.count; ++i) {
          const isOne = base122.nextBitIsOne();
          const chunkSize = Math.pow(2, base122.count - (i + 1));
          if (isOne) {
            buildPennant(chunkSize, LLRBNode.BLACK);
          } else {
            buildPennant(chunkSize, LLRBNode.BLACK);
            buildPennant(chunkSize, LLRBNode.RED);
          }
        }
        return root2;
      };
      const base12 = new Base12Num(childList.length);
      const root = buildFrom12Array(base12);
      return new SortedMap(mapSortFn || cmp, root);
    };
    fallbackObject = {};
    IndexMap = class {
      constructor(indexes_, indexSet_) {
        this.indexes_ = indexes_;
        this.indexSet_ = indexSet_;
      }
      static get Default() {
        assert(fallbackObject && PRIORITY_INDEX, "ChildrenNode.ts has not been loaded");
        _defaultIndexMap = _defaultIndexMap || new IndexMap({ ".priority": fallbackObject }, { ".priority": PRIORITY_INDEX });
        return _defaultIndexMap;
      }
      get(indexKey) {
        const sortedMap = safeGet(this.indexes_, indexKey);
        if (!sortedMap) {
          throw new Error("No index defined for " + indexKey);
        }
        if (sortedMap instanceof SortedMap) {
          return sortedMap;
        } else {
          return null;
        }
      }
      hasIndex(indexDefinition) {
        return contains(this.indexSet_, indexDefinition.toString());
      }
      addIndex(indexDefinition, existingChildren) {
        assert(indexDefinition !== KEY_INDEX, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
        const childList = [];
        let sawIndexedValue = false;
        const iter = existingChildren.getIterator(NamedNode.Wrap);
        let next = iter.getNext();
        while (next) {
          sawIndexedValue = sawIndexedValue || indexDefinition.isDefinedOn(next.node);
          childList.push(next);
          next = iter.getNext();
        }
        let newIndex;
        if (sawIndexedValue) {
          newIndex = buildChildSet(childList, indexDefinition.getCompare());
        } else {
          newIndex = fallbackObject;
        }
        const indexName = indexDefinition.toString();
        const newIndexSet = Object.assign({}, this.indexSet_);
        newIndexSet[indexName] = indexDefinition;
        const newIndexes = Object.assign({}, this.indexes_);
        newIndexes[indexName] = newIndex;
        return new IndexMap(newIndexes, newIndexSet);
      }
      addToIndexes(namedNode, existingChildren) {
        const newIndexes = map(this.indexes_, (indexedChildren, indexName) => {
          const index = safeGet(this.indexSet_, indexName);
          assert(index, "Missing index implementation for " + indexName);
          if (indexedChildren === fallbackObject) {
            if (index.isDefinedOn(namedNode.node)) {
              const childList = [];
              const iter = existingChildren.getIterator(NamedNode.Wrap);
              let next = iter.getNext();
              while (next) {
                if (next.name !== namedNode.name) {
                  childList.push(next);
                }
                next = iter.getNext();
              }
              childList.push(namedNode);
              return buildChildSet(childList, index.getCompare());
            } else {
              return fallbackObject;
            }
          } else {
            const existingSnap = existingChildren.get(namedNode.name);
            let newChildren = indexedChildren;
            if (existingSnap) {
              newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));
            }
            return newChildren.insert(namedNode, namedNode.node);
          }
        });
        return new IndexMap(newIndexes, this.indexSet_);
      }
      removeFromIndexes(namedNode, existingChildren) {
        const newIndexes = map(this.indexes_, (indexedChildren) => {
          if (indexedChildren === fallbackObject) {
            return indexedChildren;
          } else {
            const existingSnap = existingChildren.get(namedNode.name);
            if (existingSnap) {
              return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));
            } else {
              return indexedChildren;
            }
          }
        });
        return new IndexMap(newIndexes, this.indexSet_);
      }
    };
    ChildrenNode = class {
      constructor(children_, priorityNode_, indexMap_) {
        this.children_ = children_;
        this.priorityNode_ = priorityNode_;
        this.indexMap_ = indexMap_;
        this.lazyHash_ = null;
        if (this.priorityNode_) {
          validatePriorityNode(this.priorityNode_);
        }
        if (this.children_.isEmpty()) {
          assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), "An empty node cannot have a priority");
        }
      }
      static get EMPTY_NODE() {
        return EMPTY_NODE || (EMPTY_NODE = new ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default));
      }
      isLeafNode() {
        return false;
      }
      getPriority() {
        return this.priorityNode_ || EMPTY_NODE;
      }
      updatePriority(newPriorityNode) {
        if (this.children_.isEmpty()) {
          return this;
        } else {
          return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);
        }
      }
      getImmediateChild(childName) {
        if (childName === ".priority") {
          return this.getPriority();
        } else {
          const child = this.children_.get(childName);
          return child === null ? EMPTY_NODE : child;
        }
      }
      getChild(path) {
        const front = pathGetFront(path);
        if (front === null) {
          return this;
        }
        return this.getImmediateChild(front).getChild(pathPopFront(path));
      }
      hasChild(childName) {
        return this.children_.get(childName) !== null;
      }
      updateImmediateChild(childName, newChildNode) {
        assert(newChildNode, "We should always be passing snapshot nodes");
        if (childName === ".priority") {
          return this.updatePriority(newChildNode);
        } else {
          const namedNode = new NamedNode(childName, newChildNode);
          let newChildren, newIndexMap;
          if (newChildNode.isEmpty()) {
            newChildren = this.children_.remove(childName);
            newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
          } else {
            newChildren = this.children_.insert(childName, newChildNode);
            newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
          }
          const newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;
          return new ChildrenNode(newChildren, newPriority, newIndexMap);
        }
      }
      updateChild(path, newChildNode) {
        const front = pathGetFront(path);
        if (front === null) {
          return newChildNode;
        } else {
          assert(pathGetFront(path) !== ".priority" || pathGetLength(path) === 1, ".priority must be the last token in a path");
          const newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path), newChildNode);
          return this.updateImmediateChild(front, newImmediateChild);
        }
      }
      isEmpty() {
        return this.children_.isEmpty();
      }
      numChildren() {
        return this.children_.count();
      }
      val(exportFormat) {
        if (this.isEmpty()) {
          return null;
        }
        const obj = {};
        let numKeys = 0, maxKey = 0, allIntegerKeys = true;
        this.forEachChild(PRIORITY_INDEX, (key, childNode) => {
          obj[key] = childNode.val(exportFormat);
          numKeys++;
          if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {
            maxKey = Math.max(maxKey, Number(key));
          } else {
            allIntegerKeys = false;
          }
        });
        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {
          const array = [];
          for (const key in obj) {
            array[key] = obj[key];
          }
          return array;
        } else {
          if (exportFormat && !this.getPriority().isEmpty()) {
            obj[".priority"] = this.getPriority().val();
          }
          return obj;
        }
      }
      hash() {
        if (this.lazyHash_ === null) {
          let toHash = "";
          if (!this.getPriority().isEmpty()) {
            toHash += "priority:" + priorityHashText(this.getPriority().val()) + ":";
          }
          this.forEachChild(PRIORITY_INDEX, (key, childNode) => {
            const childHash = childNode.hash();
            if (childHash !== "") {
              toHash += ":" + key + ":" + childHash;
            }
          });
          this.lazyHash_ = toHash === "" ? "" : sha1(toHash);
        }
        return this.lazyHash_;
      }
      getPredecessorChildName(childName, childNode, index) {
        const idx = this.resolveIndex_(index);
        if (idx) {
          const predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));
          return predecessor ? predecessor.name : null;
        } else {
          return this.children_.getPredecessorKey(childName);
        }
      }
      getFirstChildName(indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
          const minKey = idx.minKey();
          return minKey && minKey.name;
        } else {
          return this.children_.minKey();
        }
      }
      getFirstChild(indexDefinition) {
        const minKey = this.getFirstChildName(indexDefinition);
        if (minKey) {
          return new NamedNode(minKey, this.children_.get(minKey));
        } else {
          return null;
        }
      }
      getLastChildName(indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
          const maxKey = idx.maxKey();
          return maxKey && maxKey.name;
        } else {
          return this.children_.maxKey();
        }
      }
      getLastChild(indexDefinition) {
        const maxKey = this.getLastChildName(indexDefinition);
        if (maxKey) {
          return new NamedNode(maxKey, this.children_.get(maxKey));
        } else {
          return null;
        }
      }
      forEachChild(index, action) {
        const idx = this.resolveIndex_(index);
        if (idx) {
          return idx.inorderTraversal((wrappedNode) => {
            return action(wrappedNode.name, wrappedNode.node);
          });
        } else {
          return this.children_.inorderTraversal(action);
        }
      }
      getIterator(indexDefinition) {
        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
      }
      getIteratorFrom(startPost, indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
          return idx.getIteratorFrom(startPost, (key) => key);
        } else {
          const iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);
          let next = iterator.peek();
          while (next != null && indexDefinition.compare(next, startPost) < 0) {
            iterator.getNext();
            next = iterator.peek();
          }
          return iterator;
        }
      }
      getReverseIterator(indexDefinition) {
        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
      }
      getReverseIteratorFrom(endPost, indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
          return idx.getReverseIteratorFrom(endPost, (key) => {
            return key;
          });
        } else {
          const iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);
          let next = iterator.peek();
          while (next != null && indexDefinition.compare(next, endPost) > 0) {
            iterator.getNext();
            next = iterator.peek();
          }
          return iterator;
        }
      }
      compareTo(other) {
        if (this.isEmpty()) {
          if (other.isEmpty()) {
            return 0;
          } else {
            return -1;
          }
        } else if (other.isLeafNode() || other.isEmpty()) {
          return 1;
        } else if (other === MAX_NODE) {
          return -1;
        } else {
          return 0;
        }
      }
      withIndex(indexDefinition) {
        if (indexDefinition === KEY_INDEX || this.indexMap_.hasIndex(indexDefinition)) {
          return this;
        } else {
          const newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
          return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);
        }
      }
      isIndexed(index) {
        return index === KEY_INDEX || this.indexMap_.hasIndex(index);
      }
      equals(other) {
        if (other === this) {
          return true;
        } else if (other.isLeafNode()) {
          return false;
        } else {
          const otherChildrenNode = other;
          if (!this.getPriority().equals(otherChildrenNode.getPriority())) {
            return false;
          } else if (this.children_.count() === otherChildrenNode.children_.count()) {
            const thisIter = this.getIterator(PRIORITY_INDEX);
            const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);
            let thisCurrent = thisIter.getNext();
            let otherCurrent = otherIter.getNext();
            while (thisCurrent && otherCurrent) {
              if (thisCurrent.name !== otherCurrent.name || !thisCurrent.node.equals(otherCurrent.node)) {
                return false;
              }
              thisCurrent = thisIter.getNext();
              otherCurrent = otherIter.getNext();
            }
            return thisCurrent === null && otherCurrent === null;
          } else {
            return false;
          }
        }
      }
      resolveIndex_(indexDefinition) {
        if (indexDefinition === KEY_INDEX) {
          return null;
        } else {
          return this.indexMap_.get(indexDefinition.toString());
        }
      }
    };
    ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
    MaxNode = class extends ChildrenNode {
      constructor() {
        super(new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default);
      }
      compareTo(other) {
        if (other === this) {
          return 0;
        } else {
          return 1;
        }
      }
      equals(other) {
        return other === this;
      }
      getPriority() {
        return this;
      }
      getImmediateChild(childName) {
        return ChildrenNode.EMPTY_NODE;
      }
      isEmpty() {
        return false;
      }
    };
    MAX_NODE = new MaxNode();
    Object.defineProperties(NamedNode, {
      MIN: {
        value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)
      },
      MAX: {
        value: new NamedNode(MAX_NAME, MAX_NODE)
      }
    });
    KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
    LeafNode.__childrenNodeConstructor = ChildrenNode;
    setMaxNode$1(MAX_NODE);
    setMaxNode(MAX_NODE);
    USE_HINZE = true;
    setNodeFromJSON(nodeFromJSON);
    PathIndex = class extends Index {
      constructor(indexPath_) {
        super();
        this.indexPath_ = indexPath_;
        assert(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== ".priority", "Can't create PathIndex with empty path or .priority key");
      }
      extractChild(snap) {
        return snap.getChild(this.indexPath_);
      }
      isDefinedOn(node) {
        return !node.getChild(this.indexPath_).isEmpty();
      }
      compare(a, b) {
        const aChild = this.extractChild(a.node);
        const bChild = this.extractChild(b.node);
        const indexCmp = aChild.compareTo(bChild);
        if (indexCmp === 0) {
          return nameCompare(a.name, b.name);
        } else {
          return indexCmp;
        }
      }
      makePost(indexValue, name22) {
        const valueNode = nodeFromJSON(indexValue);
        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);
        return new NamedNode(name22, node);
      }
      maxPost() {
        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);
        return new NamedNode(MAX_NAME, node);
      }
      toString() {
        return pathSlice(this.indexPath_, 0).join("/");
      }
    };
    ValueIndex = class extends Index {
      compare(a, b) {
        const indexCmp = a.node.compareTo(b.node);
        if (indexCmp === 0) {
          return nameCompare(a.name, b.name);
        } else {
          return indexCmp;
        }
      }
      isDefinedOn(node) {
        return true;
      }
      indexedValueChanged(oldNode, newNode) {
        return !oldNode.equals(newNode);
      }
      minPost() {
        return NamedNode.MIN;
      }
      maxPost() {
        return NamedNode.MAX;
      }
      makePost(indexValue, name22) {
        const valueNode = nodeFromJSON(indexValue);
        return new NamedNode(name22, valueNode);
      }
      toString() {
        return ".value";
      }
    };
    VALUE_INDEX = new ValueIndex();
    QueryParams = class {
      constructor() {
        this.limitSet_ = false;
        this.startSet_ = false;
        this.startNameSet_ = false;
        this.startAfterSet_ = false;
        this.endSet_ = false;
        this.endNameSet_ = false;
        this.endBeforeSet_ = false;
        this.limit_ = 0;
        this.viewFrom_ = "";
        this.indexStartValue_ = null;
        this.indexStartName_ = "";
        this.indexEndValue_ = null;
        this.indexEndName_ = "";
        this.index_ = PRIORITY_INDEX;
      }
      hasStart() {
        return this.startSet_;
      }
      hasStartAfter() {
        return this.startAfterSet_;
      }
      hasEndBefore() {
        return this.endBeforeSet_;
      }
      isViewFromLeft() {
        if (this.viewFrom_ === "") {
          return this.startSet_;
        } else {
          return this.viewFrom_ === "l";
        }
      }
      getIndexStartValue() {
        assert(this.startSet_, "Only valid if start has been set");
        return this.indexStartValue_;
      }
      getIndexStartName() {
        assert(this.startSet_, "Only valid if start has been set");
        if (this.startNameSet_) {
          return this.indexStartName_;
        } else {
          return MIN_NAME;
        }
      }
      hasEnd() {
        return this.endSet_;
      }
      getIndexEndValue() {
        assert(this.endSet_, "Only valid if end has been set");
        return this.indexEndValue_;
      }
      getIndexEndName() {
        assert(this.endSet_, "Only valid if end has been set");
        if (this.endNameSet_) {
          return this.indexEndName_;
        } else {
          return MAX_NAME;
        }
      }
      hasLimit() {
        return this.limitSet_;
      }
      hasAnchoredLimit() {
        return this.limitSet_ && this.viewFrom_ !== "";
      }
      getLimit() {
        assert(this.limitSet_, "Only valid if limit has been set");
        return this.limit_;
      }
      getIndex() {
        return this.index_;
      }
      loadsAllData() {
        return !(this.startSet_ || this.endSet_ || this.limitSet_);
      }
      isDefault() {
        return this.loadsAllData() && this.index_ === PRIORITY_INDEX;
      }
      copy() {
        const copy = new QueryParams();
        copy.limitSet_ = this.limitSet_;
        copy.limit_ = this.limit_;
        copy.startSet_ = this.startSet_;
        copy.indexStartValue_ = this.indexStartValue_;
        copy.startNameSet_ = this.startNameSet_;
        copy.indexStartName_ = this.indexStartName_;
        copy.endSet_ = this.endSet_;
        copy.indexEndValue_ = this.indexEndValue_;
        copy.endNameSet_ = this.endNameSet_;
        copy.indexEndName_ = this.indexEndName_;
        copy.index_ = this.index_;
        copy.viewFrom_ = this.viewFrom_;
        return copy;
      }
    };
    ReadonlyRestClient = class extends ServerActions {
      constructor(repoInfo_, onDataUpdate_, authTokenProvider_, appCheckTokenProvider_) {
        super();
        this.repoInfo_ = repoInfo_;
        this.onDataUpdate_ = onDataUpdate_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckTokenProvider_ = appCheckTokenProvider_;
        this.log_ = logWrapper("p:rest:");
        this.listens_ = {};
      }
      reportStats(stats) {
        throw new Error("Method not implemented.");
      }
      static getListenId_(query, tag) {
        if (tag !== void 0) {
          return "tag$" + tag;
        } else {
          assert(query._queryParams.isDefault(), "should have a tag if it's not a default query.");
          return query._path.toString();
        }
      }
      listen(query, currentHashFn, tag, onComplete) {
        const pathString = query._path.toString();
        this.log_("Listen called for " + pathString + " " + query._queryIdentifier);
        const listenId = ReadonlyRestClient.getListenId_(query, tag);
        const thisListen = {};
        this.listens_[listenId] = thisListen;
        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);
        this.restRequest_(pathString + ".json", queryStringParameters, (error22, result) => {
          let data = result;
          if (error22 === 404) {
            data = null;
            error22 = null;
          }
          if (error22 === null) {
            this.onDataUpdate_(pathString, data, false, tag);
          }
          if (safeGet(this.listens_, listenId) === thisListen) {
            let status;
            if (!error22) {
              status = "ok";
            } else if (error22 === 401) {
              status = "permission_denied";
            } else {
              status = "rest_error:" + error22;
            }
            onComplete(status, null);
          }
        });
      }
      unlisten(query, tag) {
        const listenId = ReadonlyRestClient.getListenId_(query, tag);
        delete this.listens_[listenId];
      }
      get(query) {
        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);
        const pathString = query._path.toString();
        const deferred = new Deferred();
        this.restRequest_(pathString + ".json", queryStringParameters, (error22, result) => {
          let data = result;
          if (error22 === 404) {
            data = null;
            error22 = null;
          }
          if (error22 === null) {
            this.onDataUpdate_(pathString, data, false, null);
            deferred.resolve(data);
          } else {
            deferred.reject(new Error(data));
          }
        });
        return deferred.promise;
      }
      refreshAuthToken(token) {
      }
      restRequest_(pathString, queryStringParameters = {}, callback) {
        queryStringParameters["format"] = "export";
        return Promise.all([
          this.authTokenProvider_.getToken(false),
          this.appCheckTokenProvider_.getToken(false)
        ]).then(([authToken, appCheckToken]) => {
          if (authToken && authToken.accessToken) {
            queryStringParameters["auth"] = authToken.accessToken;
          }
          if (appCheckToken && appCheckToken.token) {
            queryStringParameters["ac"] = appCheckToken.token;
          }
          const url2 = (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host + pathString + "?ns=" + this.repoInfo_.namespace + querystring(queryStringParameters);
          this.log_("Sending REST request for " + url2);
          const xhr = new XMLHttpRequest();
          xhr.onreadystatechange = () => {
            if (callback && xhr.readyState === 4) {
              this.log_("REST Response for " + url2 + " received. status:", xhr.status, "response:", xhr.responseText);
              let res = null;
              if (xhr.status >= 200 && xhr.status < 300) {
                try {
                  res = jsonEval(xhr.responseText);
                } catch (e) {
                  warn("Failed to parse JSON response for " + url2 + ": " + xhr.responseText);
                }
                callback(null, res);
              } else {
                if (xhr.status !== 401 && xhr.status !== 404) {
                  warn("Got unsuccessful REST response for " + url2 + " Status: " + xhr.status);
                }
                callback(xhr.status);
              }
              callback = null;
            }
          };
          xhr.open("GET", url2, true);
          xhr.send();
        });
      }
    };
    SnapshotHolder = class {
      constructor() {
        this.rootNode_ = ChildrenNode.EMPTY_NODE;
      }
      getNode(path) {
        return this.rootNode_.getChild(path);
      }
      updateSnapshot(path, newSnapshotNode) {
        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);
      }
    };
    StatsListener = class {
      constructor(collection_) {
        this.collection_ = collection_;
        this.last_ = null;
      }
      get() {
        const newStats = this.collection_.get();
        const delta = Object.assign({}, newStats);
        if (this.last_) {
          each2(this.last_, (stat, value) => {
            delta[stat] = delta[stat] - value;
          });
        }
        this.last_ = newStats;
        return delta;
      }
    };
    FIRST_STATS_MIN_TIME = 10 * 1e3;
    FIRST_STATS_MAX_TIME = 30 * 1e3;
    REPORT_STATS_INTERVAL = 5 * 60 * 1e3;
    StatsReporter = class {
      constructor(collection, server_) {
        this.server_ = server_;
        this.statsToReport_ = {};
        this.statsListener_ = new StatsListener(collection);
        const timeout = FIRST_STATS_MIN_TIME + (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));
      }
      reportStats_() {
        const stats = this.statsListener_.get();
        const reportedStats = {};
        let haveStatsToReport = false;
        each2(stats, (stat, value) => {
          if (value > 0 && contains(this.statsToReport_, stat)) {
            reportedStats[stat] = value;
            haveStatsToReport = true;
          }
        });
        if (haveStatsToReport) {
          this.server_.reportStats(reportedStats);
        }
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));
      }
    };
    (function(OperationType2) {
      OperationType2[OperationType2["OVERWRITE"] = 0] = "OVERWRITE";
      OperationType2[OperationType2["MERGE"] = 1] = "MERGE";
      OperationType2[OperationType2["ACK_USER_WRITE"] = 2] = "ACK_USER_WRITE";
      OperationType2[OperationType2["LISTEN_COMPLETE"] = 3] = "LISTEN_COMPLETE";
    })(OperationType || (OperationType = {}));
    AckUserWrite = class {
      constructor(path, affectedTree, revert) {
        this.path = path;
        this.affectedTree = affectedTree;
        this.revert = revert;
        this.type = OperationType.ACK_USER_WRITE;
        this.source = newOperationSourceUser();
      }
      operationForChild(childName) {
        if (!pathIsEmpty(this.path)) {
          assert(pathGetFront(this.path) === childName, "operationForChild called for unrelated child.");
          return new AckUserWrite(pathPopFront(this.path), this.affectedTree, this.revert);
        } else if (this.affectedTree.value != null) {
          assert(this.affectedTree.children.isEmpty(), "affectedTree should not have overlapping affected paths.");
          return this;
        } else {
          const childTree = this.affectedTree.subtree(new Path(childName));
          return new AckUserWrite(newEmptyPath(), childTree, this.revert);
        }
      }
    };
    Overwrite = class {
      constructor(source, path, snap) {
        this.source = source;
        this.path = path;
        this.snap = snap;
        this.type = OperationType.OVERWRITE;
      }
      operationForChild(childName) {
        if (pathIsEmpty(this.path)) {
          return new Overwrite(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));
        } else {
          return new Overwrite(this.source, pathPopFront(this.path), this.snap);
        }
      }
    };
    Merge = class {
      constructor(source, path, children) {
        this.source = source;
        this.path = path;
        this.children = children;
        this.type = OperationType.MERGE;
      }
      operationForChild(childName) {
        if (pathIsEmpty(this.path)) {
          const childTree = this.children.subtree(new Path(childName));
          if (childTree.isEmpty()) {
            return null;
          } else if (childTree.value) {
            return new Overwrite(this.source, newEmptyPath(), childTree.value);
          } else {
            return new Merge(this.source, newEmptyPath(), childTree);
          }
        } else {
          assert(pathGetFront(this.path) === childName, "Can't get a merge for a child not on the path of the operation");
          return new Merge(this.source, pathPopFront(this.path), this.children);
        }
      }
      toString() {
        return "Operation(" + this.path + ": " + this.source.toString() + " merge: " + this.children.toString() + ")";
      }
    };
    CacheNode = class {
      constructor(node_, fullyInitialized_, filtered_) {
        this.node_ = node_;
        this.fullyInitialized_ = fullyInitialized_;
        this.filtered_ = filtered_;
      }
      isFullyInitialized() {
        return this.fullyInitialized_;
      }
      isFiltered() {
        return this.filtered_;
      }
      isCompleteForPath(path) {
        if (pathIsEmpty(path)) {
          return this.isFullyInitialized() && !this.filtered_;
        }
        const childKey = pathGetFront(path);
        return this.isCompleteForChild(childKey);
      }
      isCompleteForChild(key) {
        return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(key);
      }
      getNode() {
        return this.node_;
      }
    };
    EmptyChildren = () => {
      if (!emptyChildrenSingleton) {
        emptyChildrenSingleton = new SortedMap(stringCompare);
      }
      return emptyChildrenSingleton;
    };
    ImmutableTree = class {
      constructor(value, children = EmptyChildren()) {
        this.value = value;
        this.children = children;
      }
      static fromObject(obj) {
        let tree = new ImmutableTree(null);
        each2(obj, (childPath, childSnap) => {
          tree = tree.set(new Path(childPath), childSnap);
        });
        return tree;
      }
      isEmpty() {
        return this.value === null && this.children.isEmpty();
      }
      findRootMostMatchingPathAndValue(relativePath, predicate) {
        if (this.value != null && predicate(this.value)) {
          return { path: newEmptyPath(), value: this.value };
        } else {
          if (pathIsEmpty(relativePath)) {
            return null;
          } else {
            const front = pathGetFront(relativePath);
            const child = this.children.get(front);
            if (child !== null) {
              const childExistingPathAndValue = child.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);
              if (childExistingPathAndValue != null) {
                const fullPath = pathChild(new Path(front), childExistingPathAndValue.path);
                return { path: fullPath, value: childExistingPathAndValue.value };
              } else {
                return null;
              }
            } else {
              return null;
            }
          }
        }
      }
      findRootMostValueAndPath(relativePath) {
        return this.findRootMostMatchingPathAndValue(relativePath, () => true);
      }
      subtree(relativePath) {
        if (pathIsEmpty(relativePath)) {
          return this;
        } else {
          const front = pathGetFront(relativePath);
          const childTree = this.children.get(front);
          if (childTree !== null) {
            return childTree.subtree(pathPopFront(relativePath));
          } else {
            return new ImmutableTree(null);
          }
        }
      }
      set(relativePath, toSet) {
        if (pathIsEmpty(relativePath)) {
          return new ImmutableTree(toSet, this.children);
        } else {
          const front = pathGetFront(relativePath);
          const child = this.children.get(front) || new ImmutableTree(null);
          const newChild = child.set(pathPopFront(relativePath), toSet);
          const newChildren = this.children.insert(front, newChild);
          return new ImmutableTree(this.value, newChildren);
        }
      }
      remove(relativePath) {
        if (pathIsEmpty(relativePath)) {
          if (this.children.isEmpty()) {
            return new ImmutableTree(null);
          } else {
            return new ImmutableTree(null, this.children);
          }
        } else {
          const front = pathGetFront(relativePath);
          const child = this.children.get(front);
          if (child) {
            const newChild = child.remove(pathPopFront(relativePath));
            let newChildren;
            if (newChild.isEmpty()) {
              newChildren = this.children.remove(front);
            } else {
              newChildren = this.children.insert(front, newChild);
            }
            if (this.value === null && newChildren.isEmpty()) {
              return new ImmutableTree(null);
            } else {
              return new ImmutableTree(this.value, newChildren);
            }
          } else {
            return this;
          }
        }
      }
      get(relativePath) {
        if (pathIsEmpty(relativePath)) {
          return this.value;
        } else {
          const front = pathGetFront(relativePath);
          const child = this.children.get(front);
          if (child) {
            return child.get(pathPopFront(relativePath));
          } else {
            return null;
          }
        }
      }
      setTree(relativePath, newTree) {
        if (pathIsEmpty(relativePath)) {
          return newTree;
        } else {
          const front = pathGetFront(relativePath);
          const child = this.children.get(front) || new ImmutableTree(null);
          const newChild = child.setTree(pathPopFront(relativePath), newTree);
          let newChildren;
          if (newChild.isEmpty()) {
            newChildren = this.children.remove(front);
          } else {
            newChildren = this.children.insert(front, newChild);
          }
          return new ImmutableTree(this.value, newChildren);
        }
      }
      fold(fn2) {
        return this.fold_(newEmptyPath(), fn2);
      }
      fold_(pathSoFar, fn2) {
        const accum = {};
        this.children.inorderTraversal((childKey, childTree) => {
          accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn2);
        });
        return fn2(pathSoFar, this.value, accum);
      }
      findOnPath(path, f) {
        return this.findOnPath_(path, newEmptyPath(), f);
      }
      findOnPath_(pathToFollow, pathSoFar, f) {
        const result = this.value ? f(pathSoFar, this.value) : false;
        if (result) {
          return result;
        } else {
          if (pathIsEmpty(pathToFollow)) {
            return null;
          } else {
            const front = pathGetFront(pathToFollow);
            const nextChild = this.children.get(front);
            if (nextChild) {
              return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);
            } else {
              return null;
            }
          }
        }
      }
      foreachOnPath(path, f) {
        return this.foreachOnPath_(path, newEmptyPath(), f);
      }
      foreachOnPath_(pathToFollow, currentRelativePath, f) {
        if (pathIsEmpty(pathToFollow)) {
          return this;
        } else {
          if (this.value) {
            f(currentRelativePath, this.value);
          }
          const front = pathGetFront(pathToFollow);
          const nextChild = this.children.get(front);
          if (nextChild) {
            return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);
          } else {
            return new ImmutableTree(null);
          }
        }
      }
      foreach(f) {
        this.foreach_(newEmptyPath(), f);
      }
      foreach_(currentRelativePath, f) {
        this.children.inorderTraversal((childName, childTree) => {
          childTree.foreach_(pathChild(currentRelativePath, childName), f);
        });
        if (this.value) {
          f(currentRelativePath, this.value);
        }
      }
      foreachChild(f) {
        this.children.inorderTraversal((childName, childTree) => {
          if (childTree.value) {
            f(childName, childTree.value);
          }
        });
      }
    };
    CompoundWrite = class {
      constructor(writeTree_) {
        this.writeTree_ = writeTree_;
      }
      static empty() {
        return new CompoundWrite(new ImmutableTree(null));
      }
    };
    ChildChangeAccumulator = class {
      constructor() {
        this.changeMap = new Map();
      }
      trackChildChange(change) {
        const type = change.type;
        const childKey = change.childName;
        assert(type === "child_added" || type === "child_changed" || type === "child_removed", "Only child changes supported for tracking");
        assert(childKey !== ".priority", "Only non-priority child changes can be tracked.");
        const oldChange = this.changeMap.get(childKey);
        if (oldChange) {
          const oldType = oldChange.type;
          if (type === "child_added" && oldType === "child_removed") {
            this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));
          } else if (type === "child_removed" && oldType === "child_added") {
            this.changeMap.delete(childKey);
          } else if (type === "child_removed" && oldType === "child_changed") {
            this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));
          } else if (type === "child_changed" && oldType === "child_added") {
            this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));
          } else if (type === "child_changed" && oldType === "child_changed") {
            this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));
          } else {
            throw assertionError("Illegal combination of changes: " + change + " occurred after " + oldChange);
          }
        } else {
          this.changeMap.set(childKey, change);
        }
      }
      getChanges() {
        return Array.from(this.changeMap.values());
      }
    };
    NoCompleteChildSource_ = class {
      getCompleteChild(childKey) {
        return null;
      }
      getChildAfterChild(index, child, reverse) {
        return null;
      }
    };
    NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();
    WriteTreeCompleteChildSource = class {
      constructor(writes_, viewCache_, optCompleteServerCache_ = null) {
        this.writes_ = writes_;
        this.viewCache_ = viewCache_;
        this.optCompleteServerCache_ = optCompleteServerCache_;
      }
      getCompleteChild(childKey) {
        const node = this.viewCache_.eventCache;
        if (node.isCompleteForChild(childKey)) {
          return node.getNode().getImmediateChild(childKey);
        } else {
          const serverNode = this.optCompleteServerCache_ != null ? new CacheNode(this.optCompleteServerCache_, true, false) : this.viewCache_.serverCache;
          return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);
        }
      }
      getChildAfterChild(index, child, reverse) {
        const completeServerData = this.optCompleteServerCache_ != null ? this.optCompleteServerCache_ : viewCacheGetCompleteServerSnap(this.viewCache_);
        const nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child, 1, reverse, index);
        if (nodes.length === 0) {
          return null;
        } else {
          return nodes[0];
        }
      }
    };
    SyncTree = class {
      constructor(listenProvider_) {
        this.listenProvider_ = listenProvider_;
        this.syncPointTree_ = new ImmutableTree(null);
        this.pendingWriteTree_ = newWriteTree();
        this.tagToQueryMap = new Map();
        this.queryToTagMap = new Map();
      }
    };
    ExistingValueProvider = class {
      constructor(node_) {
        this.node_ = node_;
      }
      getImmediateChild(childName) {
        const child = this.node_.getImmediateChild(childName);
        return new ExistingValueProvider(child);
      }
      node() {
        return this.node_;
      }
    };
    DeferredValueProvider = class {
      constructor(syncTree, path) {
        this.syncTree_ = syncTree;
        this.path_ = path;
      }
      getImmediateChild(childName) {
        const childPath = pathChild(this.path_, childName);
        return new DeferredValueProvider(this.syncTree_, childPath);
      }
      node() {
        return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);
      }
    };
    generateWithValues = function(values) {
      values = values || {};
      values["timestamp"] = values["timestamp"] || new Date().getTime();
      return values;
    };
    resolveDeferredLeafValue = function(value, existingVal, serverValues) {
      if (!value || typeof value !== "object") {
        return value;
      }
      assert(".sv" in value, "Unexpected leaf node or priority contents");
      if (typeof value[".sv"] === "string") {
        return resolveScalarDeferredValue(value[".sv"], existingVal, serverValues);
      } else if (typeof value[".sv"] === "object") {
        return resolveComplexDeferredValue(value[".sv"], existingVal);
      } else {
        assert(false, "Unexpected server value: " + JSON.stringify(value, null, 2));
      }
    };
    resolveScalarDeferredValue = function(op, existing, serverValues) {
      switch (op) {
        case "timestamp":
          return serverValues["timestamp"];
        default:
          assert(false, "Unexpected server value: " + op);
      }
    };
    resolveComplexDeferredValue = function(op, existing, unused) {
      if (!op.hasOwnProperty("increment")) {
        assert(false, "Unexpected server value: " + JSON.stringify(op, null, 2));
      }
      const delta = op["increment"];
      if (typeof delta !== "number") {
        assert(false, "Unexpected increment value: " + delta);
      }
      const existingNode = existing.node();
      assert(existingNode !== null && typeof existingNode !== "undefined", "Expected ChildrenNode.EMPTY_NODE for nulls");
      if (!existingNode.isLeafNode()) {
        return delta;
      }
      const leaf = existingNode;
      const existingVal = leaf.getValue();
      if (typeof existingVal !== "number") {
        return delta;
      }
      return existingVal + delta;
    };
    resolveDeferredValueTree = function(path, node, syncTree, serverValues) {
      return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);
    };
    resolveDeferredValueSnapshot = function(node, existing, serverValues) {
      return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);
    };
    Tree = class {
      constructor(name22 = "", parent2 = null, node = { children: {}, childCount: 0 }) {
        this.name = name22;
        this.parent = parent2;
        this.node = node;
      }
    };
    INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/;
    INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/;
    MAX_LEAF_SIZE_ = 10 * 1024 * 1024;
    isValidKey2 = function(key) {
      return typeof key === "string" && key.length !== 0 && !INVALID_KEY_REGEX_.test(key);
    };
    isValidPathString = function(pathString) {
      return typeof pathString === "string" && pathString.length !== 0 && !INVALID_PATH_REGEX_.test(pathString);
    };
    isValidRootPathString = function(pathString) {
      if (pathString) {
        pathString = pathString.replace(/^\/*\.info(\/|$)/, "/");
      }
      return isValidPathString(pathString);
    };
    validateFirebaseData = function(errorPrefix2, data, path_) {
      const path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix2) : path_;
      if (data === void 0) {
        throw new Error(errorPrefix2 + "contains undefined " + validationPathToErrorString(path));
      }
      if (typeof data === "function") {
        throw new Error(errorPrefix2 + "contains a function " + validationPathToErrorString(path) + " with contents = " + data.toString());
      }
      if (isInvalidJSONNumber(data)) {
        throw new Error(errorPrefix2 + "contains " + data.toString() + " " + validationPathToErrorString(path));
      }
      if (typeof data === "string" && data.length > MAX_LEAF_SIZE_ / 3 && stringLength(data) > MAX_LEAF_SIZE_) {
        throw new Error(errorPrefix2 + "contains a string greater than " + MAX_LEAF_SIZE_ + " utf8 bytes " + validationPathToErrorString(path) + " ('" + data.substring(0, 50) + "...')");
      }
      if (data && typeof data === "object") {
        let hasDotValue = false;
        let hasActualChild = false;
        each2(data, (key, value) => {
          if (key === ".value") {
            hasDotValue = true;
          } else if (key !== ".priority" && key !== ".sv") {
            hasActualChild = true;
            if (!isValidKey2(key)) {
              throw new Error(errorPrefix2 + " contains an invalid key (" + key + ") " + validationPathToErrorString(path) + `.  Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`);
            }
          }
          validationPathPush(path, key);
          validateFirebaseData(errorPrefix2, value, path);
          validationPathPop(path);
        });
        if (hasDotValue && hasActualChild) {
          throw new Error(errorPrefix2 + ' contains ".value" child ' + validationPathToErrorString(path) + " in addition to actual children.");
        }
      }
    };
    validateUrl = function(fnName, parsedUrl) {
      const pathString = parsedUrl.path.toString();
      if (!(typeof parsedUrl.repoInfo.host === "string") || parsedUrl.repoInfo.host.length === 0 || !isValidKey2(parsedUrl.repoInfo.namespace) && parsedUrl.repoInfo.host.split(":")[0] !== "localhost" || pathString.length !== 0 && !isValidRootPathString(pathString)) {
        throw new Error(errorPrefix(fnName, "url") + `must be a valid firebase URL and the path can't contain ".", "#", "$", "[", or "]".`);
      }
    };
    EventQueue = class {
      constructor() {
        this.eventLists_ = [];
        this.recursionDepth_ = 0;
      }
    };
    INTERRUPT_REASON = "repo_interrupt";
    MAX_TRANSACTION_RETRIES = 25;
    Repo = class {
      constructor(repoInfo_, forceRestClient_, authTokenProvider_, appCheckProvider_) {
        this.repoInfo_ = repoInfo_;
        this.forceRestClient_ = forceRestClient_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckProvider_ = appCheckProvider_;
        this.dataUpdateCount = 0;
        this.statsListener_ = null;
        this.eventQueue_ = new EventQueue();
        this.nextWriteId_ = 1;
        this.interceptServerDataCallback_ = null;
        this.onDisconnect_ = newSparseSnapshotTree();
        this.transactionQueueTree_ = new Tree();
        this.persistentConnection_ = null;
        this.key = this.repoInfo_.toURLString();
      }
      toString() {
        return (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host;
      }
    };
    parseRepoInfo = function(dataURL, nodeAdmin) {
      const parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;
      if (parsedUrl.domain === "firebase.com") {
        fatal(parsedUrl.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");
      }
      if ((!namespace || namespace === "undefined") && parsedUrl.domain !== "localhost") {
        fatal("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");
      }
      if (!parsedUrl.secure) {
        warnIfPageIsSecure();
      }
      const webSocketOnly = parsedUrl.scheme === "ws" || parsedUrl.scheme === "wss";
      return {
        repoInfo: new RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, nodeAdmin, webSocketOnly, "", namespace !== parsedUrl.subdomain),
        path: new Path(parsedUrl.pathString)
      };
    };
    parseDatabaseURL = function(dataURL) {
      let host = "", domain = "", subdomain = "", pathString = "", namespace = "";
      let secure = true, scheme2 = "https", port = 443;
      if (typeof dataURL === "string") {
        let colonInd = dataURL.indexOf("//");
        if (colonInd >= 0) {
          scheme2 = dataURL.substring(0, colonInd - 1);
          dataURL = dataURL.substring(colonInd + 2);
        }
        let slashInd = dataURL.indexOf("/");
        if (slashInd === -1) {
          slashInd = dataURL.length;
        }
        let questionMarkInd = dataURL.indexOf("?");
        if (questionMarkInd === -1) {
          questionMarkInd = dataURL.length;
        }
        host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));
        if (slashInd < questionMarkInd) {
          pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));
        }
        const queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));
        colonInd = host.indexOf(":");
        if (colonInd >= 0) {
          secure = scheme2 === "https" || scheme2 === "wss";
          port = parseInt(host.substring(colonInd + 1), 10);
        } else {
          colonInd = host.length;
        }
        const hostWithoutPort = host.slice(0, colonInd);
        if (hostWithoutPort.toLowerCase() === "localhost") {
          domain = "localhost";
        } else if (hostWithoutPort.split(".").length <= 2) {
          domain = hostWithoutPort;
        } else {
          const dotInd = host.indexOf(".");
          subdomain = host.substring(0, dotInd).toLowerCase();
          domain = host.substring(dotInd + 1);
          namespace = subdomain;
        }
        if ("ns" in queryParams) {
          namespace = queryParams["ns"];
        }
      }
      return {
        host,
        port,
        domain,
        subdomain,
        secure,
        scheme: scheme2,
        pathString,
        namespace
      };
    };
    QueryImpl = class {
      constructor(_repo, _path, _queryParams, _orderByCalled) {
        this._repo = _repo;
        this._path = _path;
        this._queryParams = _queryParams;
        this._orderByCalled = _orderByCalled;
      }
      get key() {
        if (pathIsEmpty(this._path)) {
          return null;
        } else {
          return pathGetBack(this._path);
        }
      }
      get ref() {
        return new ReferenceImpl(this._repo, this._path);
      }
      get _queryIdentifier() {
        const obj = queryParamsGetQueryObject(this._queryParams);
        const id2 = ObjectToUniqueKey(obj);
        return id2 === "{}" ? "default" : id2;
      }
      get _queryObject() {
        return queryParamsGetQueryObject(this._queryParams);
      }
      isEqual(other) {
        other = getModularInstance(other);
        if (!(other instanceof QueryImpl)) {
          return false;
        }
        const sameRepo = this._repo === other._repo;
        const samePath = pathEquals(this._path, other._path);
        const sameQueryIdentifier = this._queryIdentifier === other._queryIdentifier;
        return sameRepo && samePath && sameQueryIdentifier;
      }
      toJSON() {
        return this.toString();
      }
      toString() {
        return this._repo.toString() + pathToUrlEncodedString(this._path);
      }
    };
    ReferenceImpl = class extends QueryImpl {
      constructor(repo, path) {
        super(repo, path, new QueryParams(), false);
      }
      get parent() {
        const parentPath = pathParent(this._path);
        return parentPath === null ? null : new ReferenceImpl(this._repo, parentPath);
      }
      get root() {
        let ref = this;
        while (ref.parent !== null) {
          ref = ref.parent;
        }
        return ref;
      }
    };
    syncPointSetReferenceConstructor(ReferenceImpl);
    syncTreeSetReferenceConstructor(ReferenceImpl);
    FIREBASE_DATABASE_EMULATOR_HOST_VAR = "FIREBASE_DATABASE_EMULATOR_HOST";
    repos = {};
    useRestClient = false;
    Database = class {
      constructor(_repoInternal, app) {
        this._repoInternal = _repoInternal;
        this.app = app;
        this["type"] = "database";
        this._instanceStarted = false;
      }
      get _repo() {
        if (!this._instanceStarted) {
          repoStart(this._repoInternal, this.app.options.appId, this.app.options["databaseAuthVariableOverride"]);
          this._instanceStarted = true;
        }
        return this._repoInternal;
      }
      get _root() {
        if (!this._rootInternal) {
          this._rootInternal = new ReferenceImpl(this._repo, newEmptyPath());
        }
        return this._rootInternal;
      }
      _delete() {
        if (this._rootInternal !== null) {
          repoManagerDeleteRepo(this._repo, this.app.name);
          this._repoInternal = null;
          this._rootInternal = null;
        }
        return Promise.resolve();
      }
      _checkNotDeleted(apiName) {
        if (this._rootInternal === null) {
          fatal("Cannot call " + apiName + " on a deleted database.");
        }
      }
    };
    PersistentConnection.prototype.simpleListen = function(pathString, onComplete) {
      this.sendRequest("q", { p: pathString }, onComplete);
    };
    PersistentConnection.prototype.echo = function(data, onEcho) {
      this.sendRequest("echo", { d: data }, onEcho);
    };
    setWebSocketImpl(websocket.Client);
    registerDatabase("node");
    RenderlessMyDocUpdater = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$unsubscribe_browserTabID;
      let $user, $$unsubscribe_user;
      let $isFirestoreDocCreated, $$unsubscribe_isFirestoreDocCreated;
      $$unsubscribe_browserTabID = subscribe(browserTabID, (value) => value);
      $$unsubscribe_user = subscribe(user, (value) => $user = value);
      $$unsubscribe_isFirestoreDocCreated = subscribe(isFirestoreDocCreated, (value) => $isFirestoreDocCreated = value);
      let { classID } = $$props;
      let { roomID } = $$props;
      let myFirestoreRef;
      onDestroy(() => {
        if ($isFirestoreDocCreated) {
          mh(myFirestoreRef);
          isFirestoreDocCreated.set(false);
        }
      });
      if ($$props.classID === void 0 && $$bindings.classID && classID !== void 0)
        $$bindings.classID(classID);
      if ($$props.roomID === void 0 && $$bindings.roomID && roomID !== void 0)
        $$bindings.roomID(roomID);
      $user.name ? $user.name : "Beaver #";
      {
        if ($isFirestoreDocCreated && $user.name) {
          _h(myFirestoreRef, { currentRoomID: roomID, name: $user.name });
        }
      }
      $$unsubscribe_browserTabID();
      $$unsubscribe_user();
      $$unsubscribe_isFirestoreDocCreated();
      return ``;
    });
    API_KEY_SECRET = "0ac8a98cf9bef2827f5beef5cd36c4f42a442863ce904a2469de12caa9097fa1";
    DailyVideoConference = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $dailyRoomParticipants, $$unsubscribe_dailyRoomParticipants;
      let $browserTabID, $$unsubscribe_browserTabID;
      let $dailyMicStream, $$unsubscribe_dailyMicStream;
      let $user, $$unsubscribe_user;
      $$unsubscribe_dailyRoomParticipants = subscribe(dailyRoomParticipants, (value) => $dailyRoomParticipants = value);
      $$unsubscribe_browserTabID = subscribe(browserTabID, (value) => $browserTabID = value);
      $$unsubscribe_dailyMicStream = subscribe(dailyMicStream, (value) => $dailyMicStream = value);
      $$unsubscribe_user = subscribe(user, (value) => $user = value);
      let { roomID } = $$props;
      let CallObject;
      let firestoreIDToDailyID;
      let prevCallState;
      let currentCallState;
      let dailyRoomID;
      let activeSpeakerID = "";
      onDestroy(() => {
        if (currentCallState === "connected") {
          leaveConferenceRoom();
        }
      });
      async function initCallObject() {
        return new Promise(async (resolve2, reject2) => {
          if (!$dailyMicStream) {
            try {
              const micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
              dailyMicStream.set(micStream);
            } catch (error22) {
              alert(`Don't forget to enable your your mic! Click the "aA" / "i" button beside the URL bar "https://explain.mit.edu", then click "website settings" / "microphone"`);
              return reject2("Can't access mic stream");
            }
          }
          const [micMediaStreamTrack] = $dailyMicStream.getAudioTracks();
          CallObject = import_daily_js.default.createCallObject({
            audioSource: micMediaStreamTrack,
            videoSource: false
          });
          const participantEvents = ["participant-joined", "participant-updated", "participant-left"];
          for (const e of participantEvents) {
            CallObject.on(e, () => {
              dailyRoomParticipants.set(CallObject.participants());
              const temp = {};
              for (const dailyID of Object.keys($dailyRoomParticipants)) {
                const dailyParticipant = $dailyRoomParticipants[dailyID];
                const browserTabID2 = dailyParticipant.user_name;
                if (browserTabID2) {
                  temp[browserTabID2] = dailyParticipant.user_id;
                }
              }
              firestoreIDToDailyID = temp;
            });
          }
          CallObject.on("track-started", mountNewTrack);
          CallObject.on("track-stopped", unmountTrack);
          CallObject.on("active-speaker-change", ({ activeSpeaker }) => {
            activeSpeakerID = activeSpeaker.peerId;
          });
          CallObject.on("load-attempt-failed", ({ action, errorMsg }) => {
            alert(action + ": " + errorMsg);
          });
          CallObject.on("error", ({ action, errorMsg }) => {
            alert(action + ": " + errorMsg);
          });
          resolve2();
        });
      }
      async function publicJoinRoom() {
        prevCallState = "not_connected";
        currentCallState = "connecting";
        dailyRoomID = roomID;
        const { url: url2 } = await fetchOrCreateDailyRoom();
        if (url2) {
          await joinDailyRoom(url2);
          prevCallState = "connecting";
          currentCallState = "connected";
        }
      }
      function fetchOrCreateDailyRoom() {
        return new Promise(async (resolve2) => {
          try {
            const SECONDS_IN_TWO_HOURS = 2 * 60 * 60;
            const response = await fetch("https://api.daily.co/v1/rooms", {
              "method": "POST",
              "headers": {
                "content-type": "application/json",
                "Authorization": "Bearer " + API_KEY_SECRET
              },
              body: JSON.stringify({
                name: roomID,
                properties: {
                  exp: Math.round(Date.now() / 1e3) + SECONDS_IN_TWO_HOURS,
                  eject_at_room_exp: true,
                  start_video_off: true
                }
              })
            });
            const room = await response.json();
            if (room.error === "invalid-request-error" && room.info === `a room named ${roomID} already exists`) {
              resolve2({
                url: `https://feynman.daily.co/${roomID}`
              });
            } else {
              resolve2(room);
            }
          } catch (error22) {
            console.error(error22);
            alert(error22);
            reject({ url: "" });
          }
        });
      }
      function joinDailyRoom(roomURL) {
        return new Promise(async (resolve2, reject2) => {
          try {
            await CallObject.join({ url: roomURL, userName: $browserTabID });
            resolve2();
          } catch (error22) {
            console.log("error)");
            alert(error22);
            reject2();
          }
        });
      }
      function toggleMic() {
        CallObject.setLocalAudio(!$dailyRoomParticipants.local.audio);
        dailyRoomParticipants.set(CallObject.participants());
      }
      function leaveConferenceRoom() {
        const micAudioElems = document.querySelectorAll("audio");
        for (const micAudioElem of micAudioElems) {
          micAudioElem.remove();
        }
        cleanUpCallObject();
        prevCallState = "connected";
        currentCallState = "not_connected";
      }
      function cleanUpCallObject() {
        CallObject.leave();
        dailyRoomParticipants.set({});
        activeSpeakerID = "";
      }
      if ($$props.roomID === void 0 && $$bindings.roomID && roomID !== void 0)
        $$bindings.roomID(roomID);
      {
        if (dailyRoomID !== roomID && currentCallState === "connected" && prevCallState === "connecting") {
          leaveConferenceRoom();
        }
      }
      {
        if (dailyRoomID !== roomID && currentCallState === "not_connected" && prevCallState === "connected") {
          publicJoinRoom();
        }
      }
      {
        if ($user.uid) {
          async function initDaily() {
            await initCallObject();
            publicJoinRoom();
          }
          initDaily();
        }
      }
      $$unsubscribe_dailyRoomParticipants();
      $$unsubscribe_browserTabID();
      $$unsubscribe_dailyMicStream();
      $$unsubscribe_user();
      return `${slots.default ? slots.default({
        toggleMic,
        activeSpeakerID,
        firestoreIDToDailyID
      }) : `

`}`;
    });
    css6 = {
      code: ".question-item.svelte-ms4my9{color:rgb(19, 145, 230)}.selected.svelte-ms4my9{font-weight:500;background-color:rgb(45, 44, 44);color:white}.speaking.svelte-ms4my9{font-weight:800}",
      map: null
    };
    _layout2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $roomToPeople, $$unsubscribe_roomToPeople;
      let $$unsubscribe_willPreventPageLeave;
      let $user, $$unsubscribe_user;
      let $dailyRoomParticipants, $$unsubscribe_dailyRoomParticipants;
      let $browserTabID, $$unsubscribe_browserTabID;
      $$unsubscribe_roomToPeople = subscribe(roomToPeople, (value) => $roomToPeople = value);
      $$unsubscribe_willPreventPageLeave = subscribe(willPreventPageLeave, (value) => value);
      $$unsubscribe_user = subscribe(user, (value) => $user = value);
      $$unsubscribe_dailyRoomParticipants = subscribe(dailyRoomParticipants, (value) => $dailyRoomParticipants = value);
      $$unsubscribe_browserTabID = subscribe(browserTabID, (value) => $browserTabID = value);
      let { classID } = $$props;
      let { roomID } = $$props;
      let unsubFuncs = [];
      let nameOfClass = "";
      let descriptionOfClass = "";
      let rooms = [];
      let DropdownMenu;
      function unsubDbListeners() {
        for (const unsubFunc of unsubFuncs) {
          unsubFunc();
        }
        unsubFuncs = [];
      }
      async function fetchClassDoc() {
        const classDocRef = va(Oa(), `classes/${classID}`);
        const classDoc = await ch(classDocRef);
        nameOfClass = classDoc.data().name;
        descriptionOfClass = classDoc.data().description;
      }
      onDestroy(() => {
        unsubDbListeners();
      });
      function fetchParticipants() {
        const participantsRef = ba(Oa(), `classes/${classID}/participants`);
        unsubFuncs.push(yh(participantsRef, (snapshot) => {
          snapshot.docChanges().forEach((change) => {
            const person = change.doc.data();
            const roomID2 = person.currentRoomID;
            switch (change.type) {
              case "added":
                if (!$roomToPeople[roomID2])
                  set_store_value(roomToPeople, $roomToPeople[roomID2] = [], $roomToPeople);
                set_store_value(roomToPeople, $roomToPeople[roomID2] = [...$roomToPeople[roomID2], person], $roomToPeople);
                break;
              case "modified":
                for (const id2 of Object.keys($roomToPeople)) {
                  for (const p2 of $roomToPeople[id2]) {
                    if (p2.browserTabID === person.browserTabID) {
                      set_store_value(roomToPeople, $roomToPeople[id2] = $roomToPeople[id2].filter((p22) => p22.browserTabID !== person.browserTabID), $roomToPeople);
                    }
                  }
                }
                if (!$roomToPeople[roomID2])
                  set_store_value(roomToPeople, $roomToPeople[roomID2] = [], $roomToPeople);
                set_store_value(roomToPeople, $roomToPeople[roomID2] = [...$roomToPeople[roomID2], person], $roomToPeople);
                break;
              case "removed":
                set_store_value(roomToPeople, $roomToPeople[roomID2] = $roomToPeople[roomID2].filter((p2) => p2.browserTabID !== person.browserTabID), $roomToPeople);
                break;
            }
          });
        }));
      }
      function fetchRooms() {
        const roomsRef = ba(Oa(), `classes/${classID}/rooms`);
        const roomsQuery = Mu(roomsRef, qu("date", "asc"));
        unsubFuncs.push(yh(roomsQuery, async (snapshot) => {
          const docs = [];
          snapshot.forEach((doc) => {
            docs.push({
              id: doc.id,
              ref: doc.ref.path,
              ...doc.data()
            });
          });
          rooms = docs;
          if (rooms.length === 0) {
            const roomsRef2 = ba(Oa(), `classes/${classID}/rooms`);
            const rooms2 = [];
            const roomsResult = await lh(roomsRef2);
            roomsResult.docs.forEach((doc) => {
              rooms2.push({ id: doc.id, ...doc.data() });
            });
            for (const room of rooms2) {
              const roomRef = va(Oa(), `classes/${classID}/rooms/${room.id}`);
              _h(roomRef, { date: Date.now() });
            }
          }
        }));
      }
      if ($$props.classID === void 0 && $$bindings.classID && classID !== void 0)
        $$bindings.classID(classID);
      if ($$props.roomID === void 0 && $$bindings.roomID && roomID !== void 0)
        $$bindings.roomID(roomID);
      $$result.css.add(css6);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          if (classID) {
            unsubDbListeners();
            set_store_value(roomToPeople, $roomToPeople = [], $roomToPeople);
            fetchClassDoc();
            fetchParticipants();
            fetchRooms();
          }
        }
        {
          if (roomID && $user.uid) {
            const userRef = va(Oa(), `users/${$user.uid}`);
            _h(userRef, {
              mostRecentClassAndRoomID: `/${classID}/${roomID}`
            });
          }
        }
        $$rendered = `
${$user.uid ? `${validate_component(RenderlessMyDocUpdater, "RenderlessMyDocUpdater").$$render($$result, { classID, roomID }, {}, {})}` : ``}

<div id="${"container-for-audio-elements"}"></div>

${validate_component(DailyVideoConference, "DailyVideoConference").$$render($$result, { roomID }, {}, {
          default: ({ activeSpeakerID, toggleMic, firestoreIDToDailyID }) => `${validate_component(LeftDrawer, "LeftDrawer").$$render($$result, { nameOfClass, descriptionOfClass }, {}, {
            default: () => `
    ${each(rooms, (room) => `<div style="${"padding: 6px;"}">
        <div class="${escape(null_to_empty(room.id === roomID ? "selected" : "")) + " svelte-ms4my9"}" style="${"padding-bottom: 6px; opacity: 90%; border-radius: 5px;"}">
          <div style="${"display: flex; align-items: center; padding-left: 8px; padding-right: 5px; padding-top: 6px;"}">${room.name ? `<div class="${[
              "my-truncated-text svelte-ms4my9",
              room.name.charAt(room.name.length - 1) === "?" && room.id !== roomID ? "question-item" : ""
            ].join(" ").trim()}" style="${"margin-bottom: 2px; "}">${escape(room.name)}
              </div>` : `${room.name === "" ? `<div style="${"margin-bottom: 2px;"}">(empty room)</div>` : ``}`}

            ${room.id === roomID && $user.uid ? `<span class="${"material-icons"}" style="${"margin-right: 0px; margin-left: auto; color: white; font-size: 1.5rem;"}">more_vert
              </span>

              ${validate_component(Menu, "Menu").$$render($$result, {
              style: "width: 300px",
              this: DropdownMenu
            }, {
              this: ($$value) => {
                DropdownMenu = $$value;
                $$settled = false;
              }
            }, {
              default: () => `${validate_component(List, "List").$$render($$result, {}, {}, {
                default: () => `${validate_component(Item, "Item").$$render($$result, {}, {}, {
                  default: () => `Delete room
                  `
                })}
                `
              })} 
              `
            })}` : ``}</div>

          ${$roomToPeople[room.id] ? `${each($roomToPeople[room.id], (person) => `<div style="${"display: flex; align-items: center; padding-left: 8px; padding-right: 8px;"}"><div style="${"font-size: 0.7rem; margin-left: 6px;"}" class="${[
              "svelte-ms4my9",
              firestoreIDToDailyID && firestoreIDToDailyID[person.browserTabID] && firestoreIDToDailyID[person.browserTabID] === activeSpeakerID ? "speaking" : ""
            ].join(" ").trim()}">${escape(person.name)}</div> 
                ${Object.keys($dailyRoomParticipants).length > 0 ? `${person.browserTabID === $browserTabID ? `<div style="${"display: flex; align-items: center; margin-right: 6px; margin-left: auto"}"><div style="${"padding-top: 5px"}">${validate_component(Switch, "Switch").$$render($$result, {
              checked: $dailyRoomParticipants.local.audio,
              style: "margin: 0 !important"
            }, {}, {})}</div>
                      ${$dailyRoomParticipants.local.audio ? `<div style="${"font-size: 0.7rem; margin-left: 6px; color: #33ff33"}">voice on
                        </div>` : `<div style="${"font-size: 0.7rem; margin-left: 6px; color: red"}">muted
                        </div>`}
                    </div>` : `${$dailyRoomParticipants[firestoreIDToDailyID[person.browserTabID]] ? `${$dailyRoomParticipants[firestoreIDToDailyID[person.browserTabID]].audio ? `<span class="${"material-icons"}" style="${"margin-right: 0; margin-left: auto; font-size: 1.1rem; color: " + escape(firestoreIDToDailyID && firestoreIDToDailyID[person.browserTabID] && firestoreIDToDailyID[person.browserTabID] === activeSpeakerID ? "white" : "")}">mic
                      </span>` : `<span class="${"material-icons"}" style="${"margin-right: 0; margin-left: auto; font-size: 1.1rem; color: red"}">mic_off
                      </span>`}` : ``}`}` : ``}
              </div>`)}` : ``}</div>
      </div>`)}

    
    ${$user.uid ? `<div style="${"padding: 6px; display: flex; align-items: center;"}"><span class="${"material-icons"}" style="${"margin-left: 6px; margin-right: 5px; margin-top: 2.5px; font-size: 1.2rem;"}">add
        </span>
        new room
      </div>` : ``}`
          })}`
        })}

${slots.default ? slots.default({}) : `

`}`;
      } while (!$$settled);
      $$unsubscribe_roomToPeople();
      $$unsubscribe_willPreventPageLeave();
      $$unsubscribe_user();
      $$unsubscribe_dailyRoomParticipants();
      $$unsubscribe_browserTabID();
      return $$rendered;
    });
  }
});

// node_modules/svelte-css-vars/dist/index.js
var require_dist = __commonJS({
  "node_modules/svelte-css-vars/dist/index.js"(exports, module2) {
    init_shims();
    "use strict";
    var index = (e, t2) => (Object.entries(t2).forEach(([t3, r]) => {
      e.style.setProperty(`--${t3}`, r);
    }), { update(r) {
      Object.entries(r).forEach(([r2, s2]) => {
        e.style.setProperty(`--${r2}`, s2), delete t2[r2];
      }), Object.keys(t2).forEach((t3) => e.style.removeProperty(`--${t3}`)), t2 = r;
    } });
    module2.exports = index;
  }
});

// .svelte-kit/output/server/chunks/index-17ad71ad.js
var index_17ad71ad_exports = {};
__export(index_17ad71ad_exports, {
  default: () => U5Broomu5D,
  load: () => load3
});
function convertDocToStroke(doc) {
  const strokeObject = { id: doc.id, ...doc.data() };
  strokeObject.startTime = 0;
  strokeObject.endTime = 0;
  if (!doc.data().isErasing) {
    strokeObject.endTime += 0.5;
  }
  return strokeObject;
}
async function load3({ page: page2 }) {
  return {
    props: {
      classID: page2.params.class,
      roomID: page2.params.room
    }
  };
}
function hasQuestionMark(string) {
  if (!string)
    return false;
  return string.charAt(string.length - 1) === "?";
}
var import_svelte_css_vars, import_cookie8, import_node_fetch8, counter2, HelperText, css$2, BlackboardToolbar, Blackboard, RenderlessAudioRecorder, css$12, TextAreaAutoResizing, CircularProgress, RenderlessListenToStrokes, css7, U5Broomu5D;
var init_index_17ad71ad = __esm({
  ".svelte-kit/output/server/chunks/index-17ad71ad.js"() {
    init_shims();
    init_app_dafecf1b();
    init_RenderlessFetchStrokes_a2b1dd16();
    init_store_85fd0788();
    init_SelectionGroupIcon_51f30423();
    init_index_node_esm_4a860b07();
    init_DoodleVideo_svelte_svelte_type_style_lang_1ac60caf();
    import_svelte_css_vars = __toModule(require_dist());
    import_cookie8 = __toModule(require_cookie());
    init_dist();
    import_node_fetch8 = __toModule(require_lib2());
    counter2 = 0;
    HelperText = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "class", "id", "persistent", "validationMsg", "getElement"]);
      forwardEventsBuilder(get_current_component());
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { id: id2 = "SMUI-textfield-helper-text-" + counter2++ } = $$props;
      let { persistent = false } = $$props;
      let { validationMsg = false } = $$props;
      let element;
      let internalClasses = {};
      let internalAttrs = {};
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.persistent === void 0 && $$bindings.persistent && persistent !== void 0)
        $$bindings.persistent(persistent);
      if ($$props.validationMsg === void 0 && $$bindings.validationMsg && validationMsg !== void 0)
        $$bindings.validationMsg(validationMsg);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<div${spread([
        {
          class: escape_attribute_value(classMap({
            [className]: true,
            "mdc-text-field-helper-text": true,
            "mdc-text-field-helper-text--persistent": persistent,
            "mdc-text-field-helper-text--validation-msg": validationMsg,
            ...internalClasses
          }))
        },
        {
          "aria-hidden": escape_attribute_value(persistent ? void 0 : "true")
        },
        { id: escape_attribute_value(id2) },
        escape_object(internalAttrs),
        escape_object($$restProps)
      ])}${add_attribute("this", element, 0)}>${`${slots.default ? slots.default({}) : ``}`}
</div>`;
    });
    css$2 = {
      code: "svg.svelte-1bgxyxs{max-height:30px}.pencil-selected.svelte-1bgxyxs{background-color:white}.eraser-selected.svelte-1bgxyxs{filter:invert(1)\r\n}",
      map: null
    };
    BlackboardToolbar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $onlyAllowApplePencil, $$unsubscribe_onlyAllowApplePencil;
      let $user, $$unsubscribe_user;
      let $currentTool, $$unsubscribe_currentTool;
      $$unsubscribe_onlyAllowApplePencil = subscribe(onlyAllowApplePencil, (value) => $onlyAllowApplePencil = value);
      $$unsubscribe_user = subscribe(user, (value) => $user = value);
      $$unsubscribe_currentTool = subscribe(currentTool, (value) => $currentTool = value);
      $$result.css.add(css$2);
      $$unsubscribe_onlyAllowApplePencil();
      $$unsubscribe_user();
      $$unsubscribe_currentTool();
      return `<div style="${"position: absolute; display: flex; align-items: center; height: 50px; left: 0; right: auto; top: 0; bottom: auto; z-index: 2; background-color: grey; padding-left: 10px; border-radius: 2px;"}"><div style="${"margin-right: 10px; text-align: center"}">
    ${validate_component(Switch, "Switch").$$render($$result, {
        icons: false,
        checked: !$onlyAllowApplePencil,
        style: "margin: 0 !important"
      }, {}, {})}
    <div style="${"margin-top: 2px; font-size: 0.55rem; font-family: Roboto,sans-serif; color: white;"}">${escape($onlyAllowApplePencil ? "No touch" : "Touch draw")}</div></div>
  ${Object.keys($user).length > 0 ? `${each($user.pencilColors, (color) => `<div style="${"margin: 0 4px; width: 30px; height: 42px; border-radius: 3px; align-items: center; display: flex; justify-content: center;"}" class="${["svelte-1bgxyxs", $currentTool.color === color ? "pencil-selected" : ""].join(" ").trim()}"><svg preserveAspectRatio="${"none"}" version="${"1.1"}" id="${"Layer_1"}" xmlns="${"http://www.w3.org/2000/svg"}" xmlns:xlink="${"http://www.w3.org/1999/xlink"}" x="${"0px"}" y="${"0px"}" width="${"16px"}" height="${"30px"}" viewBox="${"0 0 100 230"}" style="${"enable-background:new 0 0 100 230;"}" xml:space="${"preserve"}" class="${"svelte-1bgxyxs"}"><g><path d="${"M0,0v72.377c0,1.588,0.234,3.169,0.698,4.706l45.416,150.032C46.633,228.828,48.212,230,50,230s3.367-1.172,3.886-2.883\r\n              L99.31,77.079c0.457-1.525,0.69-3.108,0.69-4.702V0.002"}"></path>;
            <polygon${add_attribute("style", `fill: ${color};`, 0)} points="${"50,211.978 38.879,175.24 61.122,175.24"}"></polygon><path style="${"fill:#424242;"}" d="${"M63.581,167.118H36.42L8.765,75.761l10.924-9.63l12.5,11.015c1.54,1.353,3.835,1.35,5.375-0.002\r\n                l12.468-11.007l12.464,11.005c1.54,1.357,3.839,1.357,5.377,0l12.465-11.005l10.9,9.623L63.581,167.118z"}"></path><path${add_attribute("style", `fill: ${color};`, 0)} d="${"M91.878,0v65.486l-8.852-7.813c-1.539-1.353-3.838-1.354-5.377,0.002L65.185,68.679L52.72,57.674\r\n                c-1.539-1.356-3.838-1.354-5.377-0.002L34.871,68.683L22.375,57.67c-0.769-0.676-1.725-1.013-2.685-1.013\r\n                c-0.959,0-1.919,0.339-2.685,1.013L8.121,65.5L8.098,0.024L91.878,0z"}"></path></g></svg> 
      </div>`)}

    <img width="${"46"}" height="${"33"}" style="${"margin-left: 8px; margin-right: 8px;"}" src="${"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR30G9gEErDXNf8qxm0-vvSLs2zaE8V6v-pDqxNg-CUaoeORwmoosKPF-DC2SUG772Tm3A&usqp=CAU"}" alt="${"eraser"}" class="${["svelte-1bgxyxs", $currentTool.type === "eraser" ? "eraser-selected" : ""].join(" ").trim()}">` : ``}
  
  ${slots.default ? slots.default({}) : `

  `}

  ${slots["dropdown-menu"] ? slots["dropdown-menu"]({}) : `

  `}  
</div>`;
    });
    Blackboard = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $canvasHeight, $$unsubscribe_canvasHeight;
      let $canvasWidth, $$unsubscribe_canvasWidth;
      let $$unsubscribe_currentTool;
      let $$unsubscribe_onlyAllowApplePencil;
      $$unsubscribe_canvasHeight = subscribe(canvasHeight, (value) => $canvasHeight = value);
      $$unsubscribe_canvasWidth = subscribe(canvasWidth, (value) => $canvasWidth = value);
      $$unsubscribe_currentTool = subscribe(currentTool, (value) => value);
      $$unsubscribe_onlyAllowApplePencil = subscribe(onlyAllowApplePencil, (value) => value);
      let { strokesArray } = $$props;
      let { currentTime = 0 } = $$props;
      let { backgroundImageDownloadURL = "" } = $$props;
      let { recordState = "" } = $$props;
      createEventDispatcher();
      let canvas;
      let bgCanvas;
      let DropdownMenu;
      onDestroy(() => {
        window.removeEventListener("popstate", onBackOrForward);
      });
      function onBackOrForward() {
        if (recordState === "mid_record") {
          if (confirm("This will interrupt your current recording, are you sure?"))
            ;
          else {
            history.pushState(null, document.title, location.href);
          }
        }
      }
      if ($$props.strokesArray === void 0 && $$bindings.strokesArray && strokesArray !== void 0)
        $$bindings.strokesArray(strokesArray);
      if ($$props.currentTime === void 0 && $$bindings.currentTime && currentTime !== void 0)
        $$bindings.currentTime(currentTime);
      if ($$props.backgroundImageDownloadURL === void 0 && $$bindings.backgroundImageDownloadURL && backgroundImageDownloadURL !== void 0)
        $$bindings.backgroundImageDownloadURL(backgroundImageDownloadURL);
      if ($$props.recordState === void 0 && $$bindings.recordState && recordState !== void 0)
        $$bindings.recordState(recordState);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `
${strokesArray ? `${validate_component(BlackboardToolbar, "BlackboardToolbar").$$render($$result, {}, {}, {
          "dropdown-menu": () => `<div slot="${"dropdown-menu"}">${recordState === "pre_record" ? `<span class="${"material-icons"}" style="${"margin-right: 10px; color: white; font-size: 2rem;"}">more_vert
        </span>` : ``}
    
      <input style="${"display: none"}" type="${"file"}" accept="${"image/gif, image/jpeg, image/png"}">
      
      ${validate_component(Menu, "Menu").$$render($$result, {
            style: "width: 300px",
            this: DropdownMenu
          }, {
            this: ($$value) => {
              DropdownMenu = $$value;
              $$settled = false;
            }
          }, {
            default: () => `${validate_component(List, "List").$$render($$result, {}, {}, {
              default: () => `${backgroundImageDownloadURL ? `${validate_component(Item, "Item").$$render($$result, {}, {}, {
                default: () => `Remove background
            `
              })}` : `${validate_component(Item, "Item").$$render($$result, {}, {}, {
                default: () => `Set background
            `
              })}`}

          ${validate_component(Item, "Item").$$render($$result, {}, {}, {
                default: () => `Wipe board
          `
              })}    

          ${validate_component(Item, "Item").$$render($$result, {}, {}, {
                default: () => `Delete board 
          `
              })}`
            })}`
          })}</div>`,
          default: () => `${slots.default ? slots.default({}) : `

    `}`
        })}` : ``}

<canvas${add_attribute("style", `position: absolute; z-index: 1; margin-top: 0; margin-left: 0; width: ${$canvasWidth}px; height: ${$canvasHeight}px`, 0)}${add_attribute("this", canvas, 0)}></canvas>
  
<canvas${add_attribute("style", `position: absolute;
  top: 0;
  left: 0;
  z-index: 0;
  display: block;
  background-color: rgb(46, 49, 49); width: ${$canvasWidth}px; height: ${$canvasHeight}px`, 0)}${add_attribute("this", bgCanvas, 0)}></canvas>`;
      } while (!$$settled);
      $$unsubscribe_canvasHeight();
      $$unsubscribe_canvasWidth();
      $$unsubscribe_currentTool();
      $$unsubscribe_onlyAllowApplePencil();
      return $$rendered;
    });
    RenderlessAudioRecorder = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $dailyMicStream, $$unsubscribe_dailyMicStream;
      let $dailyRoomParticipants, $$unsubscribe_dailyRoomParticipants;
      $$unsubscribe_dailyMicStream = subscribe(dailyMicStream, (value) => $dailyMicStream = value);
      $$unsubscribe_dailyRoomParticipants = subscribe(dailyRoomParticipants, (value) => $dailyRoomParticipants = value);
      let currentTime = 0;
      let timer;
      const dispatch2 = createEventDispatcher();
      let recorder = null;
      function startRecording() {
        return new Promise(async (resolve2, reject2) => {
          let micStreamCopy;
          if (!$dailyMicStream) {
            try {
              micStreamCopy = await navigator.mediaDevices.getUserMedia({ audio: true });
            } catch (error3) {
              alert(`Don't forget to enable your your mic! Click the "aA" / "i" button beside the URL bar "https://explain.mit.edu", then click "website settings" / "microphone"`);
              return reject2("Can't access mic stream");
            }
          } else if (!$dailyRoomParticipants.local.audio) {
            alert('Cannot start recording because your mic is muted - click the switch next to your "beaver #n" to unmute');
            reject2("Cannot start recording because mic stream is muted");
            return;
          } else {
            micStreamCopy = $dailyMicStream.clone();
          }
          recorder = new MediaRecorder(micStreamCopy);
          recorder.start();
          timer = setInterval(() => currentTime += 0.1, 100);
          dispatch2("record-start");
          resolve2();
        });
      }
      function stopRecording() {
        return new Promise((resolve2, reject2) => {
          clearTimeout(timer);
          recorder.addEventListener("dataavailable", (e) => {
            const audioBlob = e.data;
            dispatch2("record-end", { audioBlob });
            resolve2();
          });
          recorder.stop();
          for (const track of recorder.stream.getTracks()) {
            track.stop();
          }
        });
      }
      $$unsubscribe_dailyMicStream();
      $$unsubscribe_dailyRoomParticipants();
      return `${slots.default ? slots.default({
        startRecording,
        stopRecording,
        currentTime
      }) : `

`}`;
    });
    css$12 = {
      code: '.grow-wrap.svelte-1xi77cs.svelte-1xi77cs::after{visibility:hidden;content:attr(data-replicated-value) " "}.grow-wrap.svelte-1xi77cs>textarea.svelte-1xi77cs,.grow-wrap.svelte-1xi77cs.svelte-1xi77cs::after{width:var(--width);overflow-wrap:break-word;white-space:pre-wrap;box-sizing:border-box;border:1px solid black;border-radius:2px;padding:6px;font-size:1rem;font-family:Roboto, sans-serif;color:rgb(60 55 56 / 87%);grid-area:1 / 1 / 2 / 2;resize:none;overflow:hidden}',
      map: null
    };
    TextAreaAutoResizing = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $canvasWidth, $$unsubscribe_canvasWidth;
      $$unsubscribe_canvasWidth = subscribe(canvasWidth, (value2) => $canvasWidth = value2);
      let { value } = $$props;
      let autogrowWrapper;
      createEventDispatcher();
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      $$result.css.add(css$12);
      $$unsubscribe_canvasWidth();
      return `
<div class="${"grow-wrap svelte-1xi77cs"}" style="${"display: grid;"}"${add_attribute("this", autogrowWrapper, 0)}>
  
  <textarea rows="${"1"}" style="${"width: " + escape($canvasWidth) + "px;"}" class="${"svelte-1xi77cs"}">${escape(value)}</textarea>
</div>`;
    });
    CircularProgress = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["use", "class", "indeterminate", "closed", "progress", "fourColor", "getElement"]);
      forwardEventsBuilder(get_current_component());
      let { use = [] } = $$props;
      let { class: className = "" } = $$props;
      let { indeterminate = false } = $$props;
      let { closed = false } = $$props;
      let { progress = 0 } = $$props;
      let { fourColor = false } = $$props;
      let element;
      let internalClasses = {};
      let internalAttrs = {};
      let determinateCircleAttrs = {};
      let determinateCircle;
      function getElement() {
        return element;
      }
      if ($$props.use === void 0 && $$bindings.use && use !== void 0)
        $$bindings.use(use);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.indeterminate === void 0 && $$bindings.indeterminate && indeterminate !== void 0)
        $$bindings.indeterminate(indeterminate);
      if ($$props.closed === void 0 && $$bindings.closed && closed !== void 0)
        $$bindings.closed(closed);
      if ($$props.progress === void 0 && $$bindings.progress && progress !== void 0)
        $$bindings.progress(progress);
      if ($$props.fourColor === void 0 && $$bindings.fourColor && fourColor !== void 0)
        $$bindings.fourColor(fourColor);
      if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
        $$bindings.getElement(getElement);
      return `<div${spread([
        {
          class: escape_attribute_value(classMap({
            [className]: true,
            "mdc-circular-progress": true,
            "mdc-circular-progress--indeterminate": indeterminate,
            "mdc-circular-progress--closed": closed,
            ...internalClasses
          }))
        },
        { role: "progressbar" },
        {
          "aria-valuemin": escape_attribute_value(0)
        },
        {
          "aria-valuemax": escape_attribute_value(1)
        },
        {
          "aria-valuenow": escape_attribute_value(indeterminate ? void 0 : progress)
        },
        escape_object(internalAttrs),
        escape_object($$restProps)
      ])}${add_attribute("this", element, 0)}><div class="${"mdc-circular-progress__determinate-container"}"><svg class="${"mdc-circular-progress__determinate-circle-graphic"}" viewBox="${"0 0 48 48"}" xmlns="${"http://www.w3.org/2000/svg"}"><circle class="${"mdc-circular-progress__determinate-track"}" cx="${"24"}" cy="${"24"}" r="${"18"}" stroke-width="${"4"}"></circle><circle${spread([
        {
          class: "mdc-circular-progress__determinate-circle"
        },
        { cx: "24" },
        { cy: "24" },
        { r: "18" },
        { "stroke-dasharray": "113.097" },
        { "stroke-dashoffset": "113.097" },
        { "stroke-width": "4" },
        escape_object(determinateCircleAttrs)
      ])}${add_attribute("this", determinateCircle, 0)}></circle></svg></div>
  <div class="${"mdc-circular-progress__indeterminate-container"}">${each(fourColor ? [1, 2, 3, 4] : [1], (color) => `<div${add_attribute("class", classMap({
        [className]: true,
        "mdc-circular-progress__spinner-layer": true,
        ["mdc-circular-progress__color-" + color]: fourColor
      }), 0)}><div class="${"mdc-circular-progress__circle-clipper mdc-circular-progress__circle-left"}"><svg class="${"mdc-circular-progress__indeterminate-circle-graphic"}" viewBox="${"0 0 48 48"}" xmlns="${"http://www.w3.org/2000/svg"}"><circle cx="${"24"}" cy="${"24"}" r="${"18"}" stroke-dasharray="${"113.097"}" stroke-dashoffset="${"56.549"}" stroke-width="${"4"}"></circle></svg></div>
        <div class="${"mdc-circular-progress__gap-patch"}"><svg class="${"mdc-circular-progress__indeterminate-circle-graphic"}" viewBox="${"0 0 48 48"}" xmlns="${"http://www.w3.org/2000/svg"}"><circle cx="${"24"}" cy="${"24"}" r="${"18"}" stroke-dasharray="${"113.097"}" stroke-dashoffset="${"56.549"}" stroke-width="${"3.2"}"></circle></svg></div>
        <div class="${"mdc-circular-progress__circle-clipper mdc-circular-progress__circle-right"}"><svg class="${"mdc-circular-progress__indeterminate-circle-graphic"}" viewBox="${"0 0 48 48"}" xmlns="${"http://www.w3.org/2000/svg"}"><circle cx="${"24"}" cy="${"24"}" r="${"18"}" stroke-dasharray="${"113.097"}" stroke-dashoffset="${"56.549"}" stroke-width="${"4"}"></circle></svg></div>
      </div>`)}</div>
</div>`;
    });
    RenderlessListenToStrokes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { dbPath } = $$props;
      let strokesArray;
      let unsubStrokesListener;
      const strokesRef = ba(Oa(), `${dbPath}/strokes`);
      const strokesQuery = Mu(strokesRef, qu("timestamp"));
      onDestroy(() => {
        if (unsubStrokesListener) {
          unsubStrokesListener();
        }
      });
      async function listenToStrokes() {
        unsubStrokesListener = yh(strokesQuery, async (snapshot) => {
          const removedDocs = snapshot.docChanges().filter((change) => change.type === "removed");
          if (removedDocs.length > 0) {
            strokesArray = [];
            await tick();
            if (snapshot.docs.length > 0) {
              snapshot.docs.forEach((doc) => {
                strokesArray.push(convertDocToStroke(doc));
              });
            }
          } else {
            if (!strokesArray) {
              strokesArray = [];
            }
            if (snapshot.docs.length === strokesArray.length)
              ;
            else {
              snapshot.docChanges().filter((change) => change.type === "added").forEach((change) => {
                strokesArray = [...strokesArray, convertDocToStroke(change.doc)];
              });
            }
          }
        });
      }
      function handleNewlyDrawnStroke(stroke) {
        strokesArray.push(stroke);
        try {
          wh(va(Oa(), `${dbPath}/strokes/${stroke.id}`), { timestamp: bh(), ...stroke });
        } catch (error3) {
          alert(error3);
        }
      }
      async function deleteAllStrokesFromDb2() {
        return new Promise(async (resolve2) => {
          const batchDeleteRequests = [];
          let currentBatch = Sh(Oa());
          let currentBatchSize = 0;
          for (const stroke of strokesArray) {
            if (currentBatchSize >= 500) {
              batchDeleteRequests.push(currentBatch.commit());
              currentBatch = Sh(Oa());
              currentBatchSize = 0;
            }
            const ref = va(Oa(), `${dbPath}/strokes/${stroke.id}`);
            currentBatch.delete(ref);
            currentBatchSize += 1;
          }
          batchDeleteRequests.push(currentBatch.commit());
          await Promise.all(batchDeleteRequests);
          strokesArray = [];
          resolve2();
        });
      }
      if ($$props.dbPath === void 0 && $$bindings.dbPath && dbPath !== void 0)
        $$bindings.dbPath(dbPath);
      return `${slots.default ? slots.default({
        listenToStrokes,
        strokesArray,
        handleNewlyDrawnStroke,
        deleteAllStrokesFromDb: deleteAllStrokesFromDb2
      }) : `

`}`;
    });
    css7 = {
      code: ".room-title input{font-size:2rem}.question input{color:rgb(19, 145, 230) !important}.unclickable.svelte-53fhoc{pointer-events:none}",
      map: null
    };
    U5Broomu5D = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let boardsDbPath;
      let roomsDbPath;
      let roomRef;
      let $user, $$unsubscribe_user;
      let $browserTabID, $$unsubscribe_browserTabID;
      let $canvasWidth, $$unsubscribe_canvasWidth;
      let $canvasHeight, $$unsubscribe_canvasHeight;
      $$unsubscribe_user = subscribe(user, (value) => $user = value);
      $$unsubscribe_browserTabID = subscribe(browserTabID, (value) => $browserTabID = value);
      $$unsubscribe_canvasWidth = subscribe(canvasWidth, (value) => $canvasWidth = value);
      $$unsubscribe_canvasHeight = subscribe(canvasHeight, (value) => $canvasHeight = value);
      let { classID } = $$props;
      let { roomID } = $$props;
      let unsubRoomListener;
      let roomDoc = { name: "", blackboards: [] };
      async function createRoomListener() {
        if (unsubRoomListener)
          unsubRoomListener();
        unsubRoomListener = yh(roomRef, (snapshot) => {
          if (!snapshot.exists()) {
            goto(`/${classID}/${classID}`);
          } else {
            roomDoc = { id: snapshot.id, ...snapshot.data() };
          }
        });
      }
      onDestroy(() => {
        unsubRoomListener();
      });
      if ($$props.classID === void 0 && $$bindings.classID && classID !== void 0)
        $$bindings.classID(classID);
      if ($$props.roomID === void 0 && $$bindings.roomID && roomID !== void 0)
        $$bindings.roomID(roomID);
      $$result.css.add(css7);
      boardsDbPath = `classes/${classID}/blackboards/`;
      roomsDbPath = `classes/${classID}/rooms/`;
      roomRef = va(Oa(), roomsDbPath + roomID);
      {
        createRoomListener();
      }
      $$unsubscribe_user();
      $$unsubscribe_browserTabID();
      $$unsubscribe_canvasWidth();
      $$unsubscribe_canvasHeight();
      return `${roomDoc ? `<div style="${"padding: 16px;"}"${add_classes([hasQuestionMark(roomDoc.name) ? "question" : ""].join(" ").trim())}>${validate_component(Textfield, "Textfield").$$render($$result, {
        disabled: hasQuestionMark(roomDoc.name) && roomDoc.askerUID && $user.uid !== roomDoc.askerUID,
        value: roomDoc.name,
        class: "room-title",
        style: `width: ${$canvasWidth}px;`
      }, {}, {
        helper: () => `${validate_component(HelperText, "HelperText").$$render($$result, { slot: "helper", persistent: true }, {}, {
          default: () => `${!roomDoc.askerUID ? `To ask a question, just use a question mark &quot;?&quot;` : `${`${`${roomDoc.askerName && roomDoc.askerUID && roomDoc.date ? `${escape(roomDoc.askerName)} asked on ${escape(displayDate(roomDoc.dateAsked))}` : ``}`}`}`}

        ${roomDoc.dateResolved ? `, resolved ${escape(displayDate(roomDoc.dateResolved))}` : ``}`
        })}`
      })}

    <div style="${"margin-bottom: 20px;"}"></div>

		${each(roomDoc.blackboards, (boardID, i) => `${validate_component(RenderlessListenToBoard, "RenderlessListenToBoard").$$render($$result, { dbPath: boardsDbPath + boardID }, {}, {
        default: ({ boardDoc }) => `${boardDoc ? `<div style="${"margin-top: 10px;"}"></div>
          ${validate_component(TextAreaAutoResizing, "TextAreaAutoResizing").$$render($$result, { value: boardDoc.description || "" }, {}, {})}
          <div style="${"margin-bottom: 10px;"}"></div>
          ${boardDoc.audioDownloadURL ? `${validate_component(RenderlessFetchStrokes, "RenderlessFetchStrokes").$$render($$result, { dbPath: boardsDbPath + boardID }, {}, {
          default: ({ fetchStrokes, strokesArray, deleteAllStrokesFromDb: deleteAllStrokesFromDb2 }) => `<div${add_attribute("style", `width: ${$canvasWidth}px; height: ${$canvasHeight + 40}px; position: relative`, 0)}>${validate_component(DoodleVideo, "DoodleVideo").$$render($$result, {
            strokesArray,
            audioDownloadURL: boardDoc.audioDownloadURL,
            backgroundImageDownloadURL: boardDoc.backgroundImageDownloadURL
          }, {}, {
            default: () => `${$user.uid === boardDoc.creatorUID || !boardDoc.creatorUID ? `${validate_component(Button_1, "Button").$$render($$result, { color: "primary" }, {}, {
              default: () => `Delete video
                    `
            })}` : ``}
                `
          })}</div>
            `
        })}` : `${validate_component(RenderlessListenToStrokes, "RenderlessListenToStrokes").$$render($$result, { dbPath: boardsDbPath + boardID }, {}, {
          default: ({ listenToStrokes, strokesArray, handleNewlyDrawnStroke, deleteAllStrokesFromDb: deleteAllStrokesFromDb2 }) => `<div${add_attribute("style", `width: ${$canvasWidth}px; height: ${$canvasHeight}px; position: relative`, 0)}>${validate_component(RenderlessAudioRecorder, "RenderlessAudioRecorder").$$render($$result, {}, {}, {
            default: ({ startRecording, stopRecording, currentTime }) => `${validate_component(Blackboard, "Blackboard").$$render($$result, {
              strokesArray,
              currentTime,
              backgroundImageDownloadURL: boardDoc.backgroundImageDownloadURL,
              recordState: boardDoc.recordState
            }, {}, {
              default: () => `${boardDoc.recordState === "pre_record" ? `<span class="${"material-icons"}" style="${"font-size: 2.5rem; color: cyan; margin-left: 22px; margin-right: 26px"}">album
                        </span>` : `${boardDoc.recordState === "mid_record" ? `<span class="${[
                "material-icons svelte-53fhoc",
                $browserTabID !== boardDoc.recorderBrowserTabID ? "unclickable" : ""
              ].join(" ").trim()}" style="${"font-size: 2.5rem; color: cyan; margin-left: 22px; margin-right: 26px"}">stop_circle
                        </span>` : `<div style="${"display: flex; justify-content: center; margin-left: 20px; margin-right: 20px"}">${validate_component(CircularProgress, "CircularProgress").$$render($$result, {
                class: "my-four-colors",
                style: "height: 32px; width: 32px;",
                indeterminate: true,
                fourColor: true
              }, {}, {})}
                        </div>`}`}
         
                  `
            })}
                `
          })}</div>
            `
        })}`}

          ${i === roomDoc.blackboards.length - 1 ? ` 
            <div style="${"display: flex; justify-content: center; align-items: center; margin-top: 40px; background-color: #2e3131; font-family: Roboto, sans-serif; text-transform: uppercase; color: white; height: 35px; width: " + escape($canvasWidth) + "px;"}">New blackboard
            </div>` : ``}` : ``}
      `
      })}`)}</div>` : ``}`;
    });
  }
});

// .svelte-kit/output/server/chunks/app-dafecf1b.js
function get_single_valued_header(headers2, key) {
  const value = headers2[key];
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return void 0;
    }
    if (value.length > 1) {
      throw new Error(`Multiple headers provided for ${key}. Multiple may be provided only for set-cookie`);
    }
    return value[0];
  }
  return value;
}
function resolve(base22, path) {
  if (scheme.test(path))
    return path;
  const base_match = absolute.exec(base22);
  const path_match = absolute.exec(path);
  if (!base_match) {
    throw new Error(`bad base path: "${base22}"`);
  }
  const baseparts = path_match ? [] : base22.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path.slice(path_match[0].length).split("/") : path.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
function is_root_relative(path) {
  return path[0] === "/" && path[1] !== "/";
}
function coalesce_to_error(err) {
  return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error2(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
function is_string(s2) {
  return typeof s2 === "string" || s2 instanceof String;
}
function is_content_type_textual(content_type) {
  if (!content_type)
    return true;
  const [type] = content_type.split(";");
  return type === "text/plain" || type === "application/json" || type === "application/x-www-form-urlencoded" || type === "multipart/form-data";
}
async function render_endpoint(request, route, match) {
  const mod = await route.load();
  const handler = mod[request.method.toLowerCase().replace("delete", "del")];
  if (!handler) {
    return;
  }
  const params = route.params(match);
  const response = await handler({ ...request, params });
  const preface = `Invalid response from route ${request.path}`;
  if (!response) {
    return;
  }
  if (typeof response !== "object") {
    return error2(`${preface}: expected an object, got ${typeof response}`);
  }
  let { status = 200, body, headers: headers2 = {} } = response;
  headers2 = lowercase_keys(headers2);
  const type = get_single_valued_header(headers2, "content-type");
  const is_type_textual = is_content_type_textual(type);
  if (!is_type_textual && !(body instanceof Uint8Array || is_string(body))) {
    return error2(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if ((typeof body === "object" || typeof body === "undefined") && !(body instanceof Uint8Array) && (!type || type.startsWith("application/json"))) {
    headers2 = { ...headers2, "content-type": "application/json; charset=utf-8" };
    normalized_body = JSON.stringify(typeof body === "undefined" ? {} : body);
  } else {
    normalized_body = body;
  }
  return { status, body: normalized_body, headers: headers2 };
}
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify2(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify2(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v2, i) {
          return i in thing ? stringify2(v2) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify2).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify2(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify2(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name6, thing) {
      params_1.push(name6);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify2(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v2, i) {
            statements_1.push(name6 + "[" + i + "]=" + stringify2(v2));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name6 + "." + Array.from(thing).map(function(v2) {
            return "add(" + stringify2(v2) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name6 + "." + Array.from(thing).map(function(_a2) {
            var k2 = _a2[0], v2 = _a2[1];
            return "set(" + stringify2(k2) + ", " + stringify2(v2) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name6 + safeProp(key) + "=" + stringify2(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name6 = "";
  do {
    name6 = chars[num % chars.length] + name6;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name6) ? name6 + "_" : name6;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop$1() {
}
function safe_not_equal$1(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function writable2(value, start2 = noop$1) {
  let stop2;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal$1(value, new_value)) {
      value = new_value;
      if (stop2) {
        const run_queue = !subscriber_queue2.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue2.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue2.length; i += 2) {
            subscriber_queue2[i][0](subscriber_queue2[i + 1]);
          }
          subscriber_queue2.length = 0;
        }
      }
    }
  }
  function update2(fn2) {
    set(fn2(value));
  }
  function subscribe2(run2, invalidate = noop$1) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop2 = start2(set) || noop$1;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop2();
        stop2 = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
function escape_json_string_in_html(str) {
  return escape$1(str, escape_json_string_in_html_dict, (code) => `\\u${code.toString(16).toUpperCase()}`);
}
function escape_html_attr(str) {
  return '"' + escape$1(str, escape_html_attr_dict, (code) => `&#${code};`) + '"';
}
function escape$1(str, dict, unicode_encoder) {
  let result = "";
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code = char.charCodeAt(0);
    if (char in dict) {
      result += dict[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += unicode_encoder(code);
      }
    } else {
      result += char;
    }
  }
  return result;
}
async function render_response({
  branch,
  options: options2,
  $session,
  page_config,
  status,
  error: error22,
  page: page2
}) {
  const css22 = new Set(options2.entry.css);
  const js2 = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error22) {
    error22.stack = options2.get_stack(error22);
  }
  if (page_config.ssr) {
    branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url2) => css22.add(url2));
      if (node.js)
        node.js.forEach((url2) => js2.add(url2));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable2($session);
    const props = {
      stores: {
        page: writable2(null),
        navigating: writable2(null),
        session
      },
      page: page2,
      components: branch.map(({ node }) => node.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js2.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js2).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css22).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
    init2 += options2.service_worker ? '<script async custom-element="amp-install-serviceworker" src="https://cdn.ampproject.org/v0/amp-install-serviceworker-0.1.js"><\/script>' : "";
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error3) => {
      throw new Error(`Failed to serialize session data: ${error3.message}`);
    })},
				host: ${page2 && page2.host ? s$1(page2.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error22)},
					nodes: [
						${(branch || []).map(({ node }) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page2 && page2.host ? s$1(page2.host) : "location.host"}, // TODO this is redundant
						path: ${page2 && page2.path ? try_serialize(page2.path, (error3) => {
      throw new Error(`Failed to serialize page.path: ${error3.message}`);
    }) : null},
						query: new URLSearchParams(${page2 && page2.query ? s$1(page2.query.toString()) : ""}),
						params: ${page2 && page2.params ? try_serialize(page2.params, (error3) => {
      throw new Error(`Failed to serialize page.params: ${error3.message}`);
    }) : null}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  if (options2.service_worker) {
    init2 += options2.amp ? `<amp-install-serviceworker src="${options2.service_worker}" layout="nodisplay"></amp-install-serviceworker>` : `<script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('${options2.service_worker}');
			}
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url: url2, body: body2, json }) => {
    let attributes = `type="application/json" data-type="svelte-data" data-url=${escape_html_attr(url2)}`;
    if (body2)
      attributes += ` data-body="${hash(body2)}"`;
    return `<script ${attributes}>${json}<\/script>`;
  }).join("\n\n	")}
		`;
  const headers2 = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers2["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers2["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers: headers2,
    body: options2.template({ head, body })
  };
}
function try_serialize(data, fail2) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail2)
      fail2(coalesce_to_error(err));
    return null;
  }
}
function serialize_error(error22) {
  if (!error22)
    return null;
  let serialized = try_serialize(error22);
  if (!serialized) {
    const { name: name6, message: message2, stack } = error22;
    serialized = try_serialize({ ...error22, name: name6, message: message2, stack });
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error22 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error22 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error22}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error22 };
    }
    return { status, error: error22 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  if (loaded.context) {
    throw new Error('You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.');
  }
  return loaded;
}
async function load_node({
  request,
  options: options2,
  state,
  route,
  page: page2,
  node,
  $session,
  stuff,
  prerender_enabled,
  is_leaf,
  is_error,
  status,
  error: error22
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let set_cookie_headers = [];
  let loaded;
  const page_proxy = new Proxy(page2, {
    get: (target, prop, receiver) => {
      if (prop === "query" && prerender_enabled) {
        throw new Error("Cannot access query on a page with prerendering enabled");
      }
      return Reflect.get(target, prop, receiver);
    }
  });
  if (module2.load) {
    const load_input = {
      page: page_proxy,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url2;
        if (typeof resource === "string") {
          url2 = resource;
        } else {
          url2 = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        const resolved = resolve(request.path, url2.split("?")[0]);
        let response;
        const prefix = options2.paths.assets || options2.paths.base;
        const filename = (resolved.startsWith(prefix) ? resolved.slice(prefix.length) : resolved).slice(1);
        const filename_html = `${filename}/index.html`;
        const asset = options2.manifest.assets.find((d2) => d2.file === filename || d2.file === filename_html);
        if (asset) {
          response = options2.read ? new Response(options2.read(asset.file), {
            headers: asset.type ? { "content-type": asset.type } : {}
          }) : await fetch(`http://${page2.host}/${asset.file}`, opts);
        } else if (is_root_relative(resolved)) {
          const relative = resolved;
          const headers2 = {
            ...opts.headers
          };
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            headers2.cookie = request.headers.cookie;
            if (!headers2.authorization) {
              headers2.authorization = request.headers.authorization;
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          const search = url2.includes("?") ? url2.slice(url2.indexOf("?") + 1) : "";
          const rendered = await respond({
            host: request.host,
            method: opts.method || "GET",
            headers: headers2,
            path: relative,
            rawBody: opts.body == null ? null : new TextEncoder().encode(opts.body),
            query: new URLSearchParams(search)
          }, options2, {
            fetched: url2,
            initiator: route
          });
          if (rendered) {
            if (state.prerender) {
              state.prerender.dependencies.set(relative, rendered);
            }
            response = new Response(rendered.body, {
              status: rendered.status,
              headers: rendered.headers
            });
          }
        } else {
          if (resolved.startsWith("//")) {
            throw new Error(`Cannot request protocol-relative URL (${url2}) in server-side fetch`);
          }
          if (typeof request.host !== "undefined") {
            const { hostname: fetch_hostname } = new URL(url2);
            const [server_hostname] = request.host.split(":");
            if (`.${fetch_hostname}`.endsWith(`.${server_hostname}`) && opts.credentials !== "omit") {
              uses_credentials = true;
              opts.headers = {
                ...opts.headers,
                cookie: request.headers.cookie
              };
            }
          }
          const external_request = new Request(url2, opts);
          response = await options2.hooks.externalFetch.call(null, external_request);
        }
        if (response) {
          const proxy2 = new Proxy(response, {
            get(response2, key, _receiver) {
              async function text() {
                const body = await response2.text();
                const headers2 = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 === "set-cookie") {
                    set_cookie_headers = set_cookie_headers.concat(value);
                  } else if (key2 !== "etag") {
                    headers2[key2] = value;
                  }
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url: url2,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers2)},"body":"${escape_json_string_in_html(body)}"}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy2;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      stuff: { ...stuff }
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error22;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  if (!loaded) {
    throw new Error(`${node.entry} - load must return a value except for page fall through`);
  }
  return {
    node,
    loaded: normalize(loaded),
    stuff: loaded.stuff || stuff,
    fetched,
    set_cookie_headers,
    uses_credentials
  };
}
async function respond_with_error({ request, options: options2, state, $session, status, error: error22 }) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page2 = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page: page2,
    node: default_layout,
    $session,
    stuff: {},
    prerender_enabled: is_prerender_enabled(options2, default_error, state),
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page: page2,
      node: default_error,
      $session,
      stuff: loaded ? loaded.stuff : {},
      prerender_enabled: is_prerender_enabled(options2, default_error, state),
      is_leaf: false,
      is_error: true,
      status,
      error: error22
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error22,
      branch,
      page: page2
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return {
      status: 500,
      headers: {},
      body: error3.stack
    };
  }
}
function is_prerender_enabled(options2, node, state) {
  return options2.prerender && (!!node.module.prerender || !!state.prerender && state.prerender.all);
}
async function respond$1(opts) {
  const { request, options: options2, state, $session, route } = opts;
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id2) => id2 ? options2.load_component(id2) : void 0));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error3
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options2);
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {}
    };
  }
  let branch = [];
  let status = 200;
  let error22;
  let set_cookie_headers = [];
  ssr:
    if (page_config.ssr) {
      let stuff = {};
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              ...opts,
              node,
              stuff,
              prerender_enabled: is_prerender_enabled(options2, node, state),
              is_leaf: i === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
            if (loaded.loaded.redirect) {
              return with_cookies({
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              }, set_cookie_headers);
            }
            if (loaded.loaded.error) {
              ({ status, error: error22 } = loaded.loaded);
            }
          } catch (err) {
            const e = coalesce_to_error(err);
            options2.handle_error(e, request);
            status = 500;
            error22 = e;
          }
          if (loaded && !error22) {
            branch.push(loaded);
          }
          if (error22) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options2.load_component(route.b[i]);
                let node_loaded;
                let j2 = i;
                while (!(node_loaded = branch[j2])) {
                  j2 -= 1;
                }
                try {
                  const error_loaded = await load_node({
                    ...opts,
                    node: error_node,
                    stuff: node_loaded.stuff,
                    prerender_enabled: is_prerender_enabled(options2, error_node, state),
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error22
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  page_config = get_page_config(error_node.module, options2);
                  branch = branch.slice(0, j2 + 1).concat(error_loaded);
                  break ssr;
                } catch (err) {
                  const e = coalesce_to_error(err);
                  options2.handle_error(e, request);
                  continue;
                }
              }
            }
            return with_cookies(await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error22
            }), set_cookie_headers);
          }
        }
        if (loaded && loaded.loaded.stuff) {
          stuff = {
            ...stuff,
            ...loaded.loaded.stuff
          };
        }
      }
    }
  try {
    return with_cookies(await render_response({
      ...opts,
      page_config,
      status,
      error: error22,
      branch: branch.filter(Boolean)
    }), set_cookie_headers);
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return with_cookies(await respond_with_error({
      ...opts,
      status: 500,
      error: error3
    }), set_cookie_headers);
  }
}
function get_page_config(leaf, options2) {
  return {
    ssr: "ssr" in leaf ? !!leaf.ssr : options2.ssr,
    router: "router" in leaf ? !!leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options2.hydrate
  };
}
function with_cookies(response, set_cookie_headers) {
  if (set_cookie_headers.length) {
    response.headers["set-cookie"] = set_cookie_headers;
  }
  return response;
}
async function render_page(request, route, match, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const params = route.params(match);
  const page2 = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  const $session = await options2.hooks.getSession(request);
  const response = await respond$1({
    request,
    options: options2,
    state,
    $session,
    route,
    page: page2
  });
  if (response) {
    return response;
  }
  if (state.fetched) {
    return {
      status: 500,
      headers: {},
      body: `Bad request in load function: failed to fetch ${state.fetched}`
    };
  }
}
function read_only_form_data() {
  const map2 = new Map();
  return {
    append(key, value) {
      if (map2.has(key)) {
        (map2.get(key) || []).push(value);
      } else {
        map2.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map2)
  };
}
function parse_body(raw, headers2) {
  if (!raw)
    return raw;
  const content_type = headers2["content-type"];
  const [type, ...directives] = content_type ? content_type.split(/;\s*/) : [];
  const text = () => new TextDecoder(headers2["content-encoding"] || "utf-8").decode(raw);
  switch (type) {
    case "text/plain":
      return text();
    case "application/json":
      return JSON.parse(text());
    case "application/x-www-form-urlencoded":
      return get_urlencoded(text());
    case "multipart/form-data": {
      const boundary = directives.find((directive) => directive.startsWith("boundary="));
      if (!boundary)
        throw new Error("Missing boundary");
      return get_multipart(text(), boundary.slice("boundary=".length));
    }
    default:
      return raw;
  }
}
function get_urlencoded(text) {
  const { data, append } = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    throw new Error("Malformed form data");
  }
  const { data, append } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    if (!match) {
      throw new Error("Malformed form data");
    }
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    const headers2 = {};
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name6, value] = raw_header.split(": ");
      name6 = name6.toLowerCase();
      headers2[name6] = value;
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name22, value2] = raw_directive.split("=");
        directives[name22] = JSON.parse(value2);
      });
      if (name6 === "content-disposition") {
        if (value !== "form-data")
          throw new Error("Malformed form data");
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      throw new Error("Malformed form data");
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !(incoming.path.split("/").pop() || "").includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q2 = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: options2.paths.base + path + (q2 ? `?${q2}` : "")
        }
      };
    }
  }
  const headers2 = lowercase_keys(incoming.headers);
  const request = {
    ...incoming,
    headers: headers2,
    body: parse_body(incoming.rawBody, headers2),
    params: {},
    locals: {}
  };
  try {
    return await options2.hooks.handle({
      request,
      resolve: async (request2) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request2),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            branch: []
          });
        }
        const decoded = decodeURI(request2.path);
        for (const route of options2.manifest.routes) {
          const match = route.pattern.exec(decoded);
          if (!match)
            continue;
          const response = route.type === "endpoint" ? await render_endpoint(request2, route, match) : await render_page(request2, route, match, options2, state);
          if (response) {
            if (response.status === 200) {
              const cache_control = get_single_valued_header(response.headers, "cache-control");
              if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
                let if_none_match_value = request2.headers["if-none-match"];
                if (if_none_match_value?.startsWith('W/"')) {
                  if_none_match_value = if_none_match_value.substring(2);
                }
                const etag = `"${hash(response.body || "")}"`;
                if (if_none_match_value === etag) {
                  return {
                    status: 304,
                    headers: {}
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        const $session = await options2.hooks.getSession(request2);
        return await respond_with_error({
          request: request2,
          options: options2,
          state,
          $session,
          status: 404,
          error: new Error(`Not found: ${request2.path}`)
        });
      }
    });
  } catch (err) {
    const e = coalesce_to_error(err);
    options2.handle_error(e, request);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e.stack : e.message
    };
  }
}
function noop() {
}
function run(fn2) {
  return fn2();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function subscribe(store2, ...callbacks) {
  if (store2 == null) {
    return noop;
  }
  const unsub = store2.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k2 in props)
    if (!keys.has(k2) && k2[0] !== "$")
      rest[k2] = props[k2];
  return rest;
}
function compute_slots(slots) {
  const result = {};
  for (const key in slots) {
    result[key] = true;
  }
  return result;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store2, ret, value) {
  store2.set(value);
  return ret;
}
function listen(node, event2, handler, options2) {
  node.addEventListener(event2, handler, options2);
  return () => node.removeEventListener(event2, handler, options2);
}
function prevent_default(fn2) {
  return function(event2) {
    event2.preventDefault();
    return fn2.call(this, event2);
  };
}
function stop_propagation(fn2) {
  return function(event2) {
    event2.stopPropagation();
    return fn2.call(this, event2);
  };
}
function custom_event(type, detail, bubbles = false) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, false, detail);
  return e;
}
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onDestroy(fn2) {
  get_current_component().$$.on_destroy.push(fn2);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event2 = custom_event(type, detail);
      callbacks.slice().forEach((fn2) => {
        fn2.call(component, event2);
      });
    }
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event2) {
  const callbacks = component.$$.callbacks[event2.type];
  if (callbacks) {
    callbacks.slice().forEach((fn2) => fn2.call(this, event2));
  }
}
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn2) {
  render_callbacks.push(fn2);
}
function flush() {
  if (flushing)
    return;
  flushing = true;
  do {
    for (let i = 0; i < dirty_components.length; i += 1) {
      const component = dirty_components[i];
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  flushing = false;
  seen_callbacks.clear();
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function spread(args, classes_to_add) {
  const attributes = Object.assign({}, ...args);
  if (classes_to_add) {
    if (attributes.class == null) {
      attributes.class = classes_to_add;
    } else {
      attributes.class += " " + classes_to_add;
    }
  }
  let str = "";
  Object.keys(attributes).forEach((name6) => {
    if (invalid_attribute_name_character.test(name6))
      return;
    const value = attributes[name6];
    if (value === true)
      str += " " + name6;
    else if (boolean_attributes.has(name6.toLowerCase())) {
      if (value)
        str += " " + name6;
    } else if (value != null) {
      str += ` ${name6}="${value}"`;
    }
  });
  return str;
}
function escape(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped[match]);
}
function escape_attribute_value(value) {
  return typeof value === "string" ? escape(value) : value;
}
function escape_object(obj) {
  const result = {};
  for (const key in obj) {
    result[key] = escape_attribute_value(obj[key]);
  }
  return result;
}
function each(items, fn2) {
  let str = "";
  for (let i = 0; i < items.length; i += 1) {
    str += fn2(items[i], i);
  }
  return str;
}
function validate_component(component, name6) {
  if (!component || !component.$$render) {
    if (name6 === "svelte:component")
      name6 += " this={...}";
    throw new Error(`<${name6}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
function create_ssr_component(fn2) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn2(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css22) => css22.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name6, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name6}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
}
function add_classes(classes) {
  return classes ? ` class="${classes}"` : "";
}
function afterUpdate() {
}
function set_paths(paths) {
  base2 = paths.base;
  assets = paths.assets || base2;
}
function set_prerendering(value) {
}
function init(settings = default_settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  const hooks = get_hooks(user_hooks);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: assets + "/_app/start-6a1717c7.js",
      css: [assets + "/_app/assets/start-61d1577b.css"],
      js: [assets + "/_app/start-6a1717c7.js", assets + "/_app/chunks/vendor-271324cb.js", assets + "/_app/chunks/preload-helper-ec9aa979.js", assets + "/_app/chunks/singletons-12a22614.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id2) => assets + "/_app/" + entry_lookup[id2],
    get_stack: (error22) => String(error22),
    handle_error: (error22, request) => {
      hooks.handleError({ error: error22, request });
      error22.stack = options.get_stack(error22);
    },
    hooks,
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    prerender: true,
    read: settings.read,
    root: Root,
    service_worker: null,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
async function load_component(file) {
  const { entry, css: css22, js: js2, styles } = metadata_lookup[file];
  return {
    module: await module_lookup[file](),
    entry: assets + "/_app/" + entry,
    css: css22.map((dep) => assets + "/_app/" + dep),
    js: js2.map((dep) => assets + "/_app/" + dep),
    styles
  };
}
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond({ ...request, host }, options, { prerender });
}
var import_cookie9, __accessCheck, __privateGet, __privateAdd, __privateSet, _map, absolute, scheme, chars, unsafeChars, reserved, escaped$1, objectProtoOwnPropertyNames, subscriber_queue2, escape_json_string_in_html_dict, escape_html_attr_dict, s$1, s, ReadOnlyFormData, current_component, dirty_components, binding_callbacks, render_callbacks, flush_callbacks, resolved_promise, update_scheduled, flushing, seen_callbacks, globals, boolean_attributes, invalid_attribute_name_character, escaped, missing_component, on_destroy, css8, Root, base2, assets, handle, user_hooks, template, options, default_settings, d, empty, manifest, get_hooks, module_lookup, metadata_lookup;
var init_app_dafecf1b = __esm({
  ".svelte-kit/output/server/chunks/app-dafecf1b.js"() {
    init_shims();
    import_cookie9 = __toModule(require_cookie());
    init_dist();
    __accessCheck = (obj, member, msg) => {
      if (!member.has(obj))
        throw TypeError("Cannot " + msg);
    };
    __privateGet = (obj, member, getter) => {
      __accessCheck(obj, member, "read from private field");
      return getter ? getter.call(obj) : member.get(obj);
    };
    __privateAdd = (obj, member, value) => {
      if (member.has(obj))
        throw TypeError("Cannot add the same private member more than once");
      member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    };
    __privateSet = (obj, member, value, setter) => {
      __accessCheck(obj, member, "write to private field");
      setter ? setter.call(obj, value) : member.set(obj, value);
      return value;
    };
    absolute = /^([a-z]+:)?\/?\//;
    scheme = /^[a-z]+:/;
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
    unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
    reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
    escaped$1 = {
      "<": "\\u003C",
      ">": "\\u003E",
      "/": "\\u002F",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    Promise.resolve();
    subscriber_queue2 = [];
    escape_json_string_in_html_dict = {
      '"': '\\"',
      "<": "\\u003C",
      ">": "\\u003E",
      "/": "\\u002F",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    escape_html_attr_dict = {
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    s$1 = JSON.stringify;
    s = JSON.stringify;
    ReadOnlyFormData = class {
      constructor(map2) {
        __privateAdd(this, _map, void 0);
        __privateSet(this, _map, map2);
      }
      get(key) {
        const value = __privateGet(this, _map).get(key);
        return value && value[0];
      }
      getAll(key) {
        return __privateGet(this, _map).get(key);
      }
      has(key) {
        return __privateGet(this, _map).has(key);
      }
      *[Symbol.iterator]() {
        for (const [key, value] of __privateGet(this, _map)) {
          for (let i = 0; i < value.length; i += 1) {
            yield [key, value[i]];
          }
        }
      }
      *entries() {
        for (const [key, value] of __privateGet(this, _map)) {
          for (let i = 0; i < value.length; i += 1) {
            yield [key, value[i]];
          }
        }
      }
      *keys() {
        for (const [key] of __privateGet(this, _map))
          yield key;
      }
      *values() {
        for (const [, value] of __privateGet(this, _map)) {
          for (let i = 0; i < value.length; i += 1) {
            yield value[i];
          }
        }
      }
    };
    _map = new WeakMap();
    dirty_components = [];
    binding_callbacks = [];
    render_callbacks = [];
    flush_callbacks = [];
    resolved_promise = Promise.resolve();
    update_scheduled = false;
    flushing = false;
    seen_callbacks = new Set();
    globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
    boolean_attributes = new Set([
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]);
    invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
    escaped = {
      '"': "&quot;",
      "'": "&#39;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;"
    };
    missing_component = {
      $$render: () => ""
    };
    css8 = {
      code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
      map: null
    };
    Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { stores } = $$props;
      let { page: page2 } = $$props;
      let { components } = $$props;
      let { props_0 = null } = $$props;
      let { props_1 = null } = $$props;
      let { props_2 = null } = $$props;
      let { props_3 = null } = $$props;
      setContext("__svelte__", stores);
      afterUpdate(stores.page.notify);
      if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
        $$bindings.stores(stores);
      if ($$props.page === void 0 && $$bindings.page && page2 !== void 0)
        $$bindings.page(page2);
      if ($$props.components === void 0 && $$bindings.components && components !== void 0)
        $$bindings.components(components);
      if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
        $$bindings.props_0(props_0);
      if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
        $$bindings.props_1(props_1);
      if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
        $$bindings.props_2(props_2);
      if ($$props.props_3 === void 0 && $$bindings.props_3 && props_3 !== void 0)
        $$bindings.props_3(props_3);
      $$result.css.add(css8);
      {
        stores.page.set(page2);
      }
      return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
        default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
          default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {
            default: () => `${components[3] ? `${validate_component(components[3] || missing_component, "svelte:component").$$render($$result, Object.assign(props_3 || {}), {}, {})}` : ``}`
          })}` : ``}`
        })}` : ``}`
      })}

${``}`;
    });
    base2 = "";
    assets = "";
    handle = async ({ request, resolve: resolve2 }) => {
      const cookies = import_cookie9.default.parse(request.headers.cookie || "");
      request.locals.userid = cookies.userid || v4();
      if (request.query.has("_method")) {
        request.method = request.query.get("_method").toUpperCase();
      }
      const response = await resolve2(request);
      if (!cookies.userid) {
        response.headers["set-cookie"] = import_cookie9.default.serialize("userid", request.locals.userid, {
          path: "/",
          httpOnly: true
        });
      }
      return response;
    };
    user_hooks = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      [Symbol.toStringTag]: "Module",
      handle
    });
    template = ({ head, body }) => '<!DOCTYPE html>\r\n<html lang="en">\r\n	<head>\r\n		<meta charset="utf-8" />\r\n		<meta name="description" content="Svelte demo app" />\r\n		<link rel="icon" href="/favicon.ico" />\r\n\r\n		<script>\r\n			// fixes the `global is not defined` but with importing DailyJS (spent 3 hours)\r\n			var global = global || window;\r\n		<\/script>\r\n\r\n		<!-- Material Icons -->\r\n		<link\r\n			rel="stylesheet"\r\n			href="https://fonts.googleapis.com/icon?family=Material+Icons"\r\n		/>\r\n		<!-- Roboto -->\r\n		<link\r\n			rel="stylesheet"\r\n			href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,600,700"\r\n		/>\r\n		<!-- Roboto Mono -->\r\n		<link\r\n			rel="stylesheet"\r\n			href="https://fonts.googleapis.com/css?family=Roboto+Mono"\r\n		/>\r\n\r\n		<!-- SMUI includes it in their setup guide, but it just throws an error at the moment -->\r\n		<!-- \r\n		<link\r\n			rel="stylesheet"\r\n			href="https://cdn.jsdelivr.net/npm/svelte-material-ui@6.0.0/bare.css"\r\n		/> -->\r\n\r\n		<!-- SMUI Styles -->\r\n		<!-- media="(prefers-color-scheme: light)" -->\r\n		<link rel="stylesheet" href="/smui.css" />\r\n\r\n		<!-- <link\r\n			rel="stylesheet"\r\n			href="/smui-dark.css"\r\n			media="screen and (prefers-color-scheme: dark)"\r\n		/> -->\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\r\n		' + head + '\r\n	</head>\r\n	<body>\r\n		<div id="svelte">' + body + "</div>\r\n	</body>\r\n</html>\r\n";
    options = null;
    default_settings = { paths: { "base": "", "assets": "" } };
    d = (s2) => s2.replace(/%23/g, "#").replace(/%3[Bb]/g, ";").replace(/%2[Cc]/g, ",").replace(/%2[Ff]/g, "/").replace(/%3[Ff]/g, "?").replace(/%3[Aa]/g, ":").replace(/%40/g, "@").replace(/%26/g, "&").replace(/%3[Dd]/g, "=").replace(/%2[Bb]/g, "+").replace(/%24/g, "$");
    empty = () => ({});
    manifest = {
      assets: [{ "file": "favicon.ico", "size": 15406, "type": "image/vnd.microsoft.icon" }, { "file": "favicon.png", "size": 1571, "type": "image/png" }, { "file": "logo.png", "size": 38761, "type": "image/png" }, { "file": "robots.txt", "size": 70, "type": "text/plain" }, { "file": "smui.css", "size": 251366, "type": "text/css" }],
      layout: "src/routes/__layout.svelte",
      error: ".svelte-kit/build/components/error.svelte",
      routes: [
        {
          type: "page",
          pattern: /^\/$/,
          params: empty,
          a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "endpoint",
          pattern: /^\/api\.json$/,
          params: empty,
          load: () => Promise.resolve().then(() => (init_api_json_d90de77a(), api_json_d90de77a_exports))
        },
        {
          type: "page",
          pattern: /^\/explore\/?$/,
          params: empty,
          a: ["src/routes/__layout.svelte", "src/routes/explore.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/learn\/?$/,
          params: empty,
          a: ["src/routes/__layout.svelte", "src/routes/learn.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/teach\/?$/,
          params: empty,
          a: ["src/routes/__layout.svelte", "src/routes/teach.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/([^/]+?)\/([^/]+?)\/?$/,
          params: (m) => ({ class: d(m[1]), room: d(m[2]) }),
          a: ["src/routes/__layout.svelte", "src/routes/[class]/__layout.svelte", "src/routes/[class]/[room]/index.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "endpoint",
          pattern: /^\/([^/]+?)\/([^/]+?)\/DailyRoom\.json$/,
          params: (m) => ({ class: d(m[1]), room: d(m[2]) }),
          load: () => Promise.resolve().then(() => (init_DailyRoom_json_5588df4b(), DailyRoom_json_5588df4b_exports))
        }
      ]
    };
    get_hooks = (hooks) => ({
      getSession: hooks.getSession || (() => ({})),
      handle: hooks.handle || (({ request, resolve: resolve2 }) => resolve2(request)),
      handleError: hooks.handleError || (({ error: error22 }) => console.error(error22.stack)),
      externalFetch: hooks.externalFetch || fetch
    });
    module_lookup = {
      "src/routes/__layout.svelte": () => Promise.resolve().then(() => (init_layout_a4c93375(), layout_a4c93375_exports)),
      ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(() => (init_error_565ff2fd(), error_565ff2fd_exports)),
      "src/routes/index.svelte": () => Promise.resolve().then(() => (init_index_910f8a98(), index_910f8a98_exports)),
      "src/routes/explore.svelte": () => Promise.resolve().then(() => (init_explore_f3de6569(), explore_f3de6569_exports)),
      "src/routes/learn.svelte": () => Promise.resolve().then(() => (init_learn_8f566fe1(), learn_8f566fe1_exports)),
      "src/routes/teach.svelte": () => Promise.resolve().then(() => (init_teach_47c4046f(), teach_47c4046f_exports)),
      "src/routes/[class]/__layout.svelte": () => Promise.resolve().then(() => (init_layout_cdc2bbe6(), layout_cdc2bbe6_exports)),
      "src/routes/[class]/[room]/index.svelte": () => Promise.resolve().then(() => (init_index_17ad71ad(), index_17ad71ad_exports))
    };
    metadata_lookup = { "src/routes/__layout.svelte": { "entry": "pages/__layout.svelte-707cbe0f.js", "css": ["assets/pages/__layout.svelte-8d662a74.css"], "js": ["pages/__layout.svelte-707cbe0f.js", "chunks/vendor-271324cb.js", "chunks/navigation-7e077723.js", "chunks/singletons-12a22614.js"], "styles": [] }, ".svelte-kit/build/components/error.svelte": { "entry": "error.svelte-3d6ec224.js", "css": [], "js": ["error.svelte-3d6ec224.js", "chunks/vendor-271324cb.js"], "styles": [] }, "src/routes/index.svelte": { "entry": "pages/index.svelte-b92a59c0.js", "css": ["assets/pages/index.svelte-839a29ef.css", "assets/DoodleVideo.svelte_svelte_type_style_lang-aaa9ff7f.css"], "js": ["pages/index.svelte-b92a59c0.js", "chunks/vendor-271324cb.js", "chunks/navigation-7e077723.js", "chunks/singletons-12a22614.js", "chunks/canvas-74f91cf9.js"], "styles": [] }, "src/routes/explore.svelte": { "entry": "pages/explore.svelte-299c32c1.js", "css": ["assets/pages/explore.svelte-05304d75.css", "assets/DoodleVideo.svelte_svelte_type_style_lang-aaa9ff7f.css"], "js": ["pages/explore.svelte-299c32c1.js", "chunks/vendor-271324cb.js", "chunks/navigation-7e077723.js", "chunks/singletons-12a22614.js", "chunks/canvas-74f91cf9.js", "chunks/RenderlessFetchStrokes-ede1c779.js"], "styles": [] }, "src/routes/learn.svelte": { "entry": "pages/learn.svelte-c3b057be.js", "css": ["assets/pages/learn.svelte-93b57da7.css", "assets/DoodleVideo.svelte_svelte_type_style_lang-aaa9ff7f.css"], "js": ["pages/learn.svelte-c3b057be.js", "chunks/vendor-271324cb.js", "chunks/navigation-7e077723.js", "chunks/singletons-12a22614.js", "chunks/canvas-74f91cf9.js", "chunks/RenderlessFetchStrokes-ede1c779.js"], "styles": [] }, "src/routes/teach.svelte": { "entry": "pages/teach.svelte-e3fe32ea.js", "css": ["assets/pages/learn.svelte-93b57da7.css", "assets/DoodleVideo.svelte_svelte_type_style_lang-aaa9ff7f.css"], "js": ["pages/teach.svelte-e3fe32ea.js", "chunks/vendor-271324cb.js", "chunks/navigation-7e077723.js", "chunks/singletons-12a22614.js", "chunks/canvas-74f91cf9.js", "chunks/RenderlessFetchStrokes-ede1c779.js"], "styles": [] }, "src/routes/[class]/__layout.svelte": { "entry": "pages/_class_/__layout.svelte-c3ee8baa.js", "css": ["assets/pages/_class_/__layout.svelte-f73c5b3e.css"], "js": ["pages/_class_/__layout.svelte-c3ee8baa.js", "chunks/vendor-271324cb.js", "chunks/navigation-7e077723.js", "chunks/singletons-12a22614.js", "chunks/canvas-74f91cf9.js"], "styles": [] }, "src/routes/[class]/[room]/index.svelte": { "entry": "pages/_class_/_room_/index.svelte-4e4f4ccc.js", "css": ["assets/pages/_class_/_room_/index.svelte-5d3f2b74.css", "assets/DoodleVideo.svelte_svelte_type_style_lang-aaa9ff7f.css"], "js": ["pages/_class_/_room_/index.svelte-4e4f4ccc.js", "chunks/vendor-271324cb.js", "chunks/RenderlessFetchStrokes-ede1c779.js", "chunks/canvas-74f91cf9.js", "chunks/navigation-7e077723.js", "chunks/singletons-12a22614.js", "chunks/preload-helper-ec9aa979.js"], "styles": [] } };
  }
});

// .svelte-kit/vercel/entry.js
__export(exports, {
  default: () => entry_default
});
init_shims();

// node_modules/@sveltejs/kit/dist/node.js
init_shims();
function getRawBody(req) {
  return new Promise((fulfil, reject2) => {
    const h = req.headers;
    if (!h["content-type"]) {
      return fulfil(null);
    }
    req.on("error", reject2);
    const length = Number(h["content-length"]);
    if (isNaN(length) && h["transfer-encoding"] == null) {
      return fulfil(null);
    }
    let data = new Uint8Array(length || 0);
    if (length > 0) {
      let offset = 0;
      req.on("data", (chunk) => {
        const new_len = offset + Buffer.byteLength(chunk);
        if (new_len > length) {
          return reject2({
            status: 413,
            reason: 'Exceeded "Content-Length" limit'
          });
        }
        data.set(chunk, offset);
        offset = new_len;
      });
    } else {
      req.on("data", (chunk) => {
        const new_data = new Uint8Array(data.length + chunk.length);
        new_data.set(data, 0);
        new_data.set(chunk, data.length);
        data = new_data;
      });
    }
    req.on("end", () => {
      fulfil(data);
    });
  });
}

// .svelte-kit/output/server/app.js
init_shims();
init_app_dafecf1b();
var import_cookie10 = __toModule(require_cookie());
init_dist();

// .svelte-kit/vercel/entry.js
init();
var entry_default = async (req, res) => {
  const { pathname, searchParams } = new URL(req.url || "", "http://localhost");
  let body;
  try {
    body = await getRawBody(req);
  } catch (err) {
    res.statusCode = err.status || 400;
    return res.end(err.reason || "Invalid request body");
  }
  const rendered = await render({
    method: req.method,
    headers: req.headers,
    path: pathname,
    query: searchParams,
    rawBody: body
  });
  if (rendered) {
    const { status, headers: headers2, body: body2 } = rendered;
    return res.writeHead(status, headers2).end(body2);
  }
  return res.writeHead(404).end();
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
